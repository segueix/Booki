<!DOCTYPE html>
<html lang="ca">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Conte IA</title>
<style>
  :root {
    --bg:       #0f0f13;
    --surface:  #1a1a24;
    --surface2: #22222f;
    --border:   #2e2e42;
    --accent:   #7c6af7;
    --accent2:  #a78bfa;
    --text:     #e8e8f0;
    --text2:    #9898b0;
    --success:  #4ade80;
    --warning:  #fbbf24;
    --radius:   12px;
    --font:     'Segoe UI', system-ui, sans-serif;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--font);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 24px 16px 60px;
  }

  /* â”€â”€ Header â”€â”€ */
  header {
    width: 100%;
    max-width: 860px;
    text-align: center;
    margin-bottom: 32px;
  }
  header h1 {
    font-size: 2rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 6px;
  }
  header p { color: var(--text2); font-size: .95rem; }

  /* â”€â”€ Progress bar â”€â”€ */
  #progress-wrap {
    width: 100%;
    max-width: 860px;
    margin-bottom: 28px;
  }
  .progress-steps {
    display: flex;
    gap: 6px;
    align-items: center;
    overflow-x: auto;
    padding-bottom: 4px;
  }
  .step-pill {
    flex-shrink: 0;
    padding: 5px 14px;
    border-radius: 99px;
    font-size: .75rem;
    font-weight: 600;
    background: var(--surface2);
    color: var(--text2);
    border: 1px solid var(--border);
    transition: all .3s;
  }
  .step-pill.done   { background: #2a2a3d; color: var(--accent2); border-color: var(--accent); }
  .step-pill.active { background: var(--accent); color: #fff; border-color: var(--accent); }
  .step-arrow { color: var(--border); font-size: .8rem; flex-shrink: 0; }

  /* â”€â”€ Card â”€â”€ */
  .card {
    width: 100%;
    max-width: 860px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 28px;
    margin-bottom: 20px;
  }
  .card h2 {
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 18px;
    color: var(--accent2);
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .card h2 .icon { font-size: 1.4rem; }

  /* â”€â”€ Select â”€â”€ */
  select {
    width: 100%;
    padding: 12px 16px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-size: 1rem;
    font-family: var(--font);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8'%3E%3Cpath fill='%239898b0' d='M6 8L0 0h12z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 16px center;
    padding-right: 40px;
  }
  select:focus { outline: none; border-color: var(--accent); }

  input[type=text],
  input[type=password] {
    width: 100%;
    padding: 12px 16px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-size: .95rem;
    font-family: var(--font);
  }
  input[type=text]:focus,
  input[type=password]:focus { outline: none; border-color: var(--accent); }

  .field-label {
    display: block;
    font-size: .85rem;
    color: var(--text2);
    margin: 14px 0 8px;
  }

  /* â”€â”€ Botons â”€â”€ */
  .btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 11px 24px;
    border-radius: 8px;
    font-size: .95rem;
    font-weight: 600;
    cursor: pointer;
    border: none;
    transition: all .2s;
    font-family: var(--font);
  }
  .btn-primary   { background: var(--accent); color: #fff; }
  .btn-primary:hover { background: #6b5be0; transform: translateY(-1px); }
  .btn-secondary { background: var(--surface2); color: var(--text); border: 1px solid var(--border); }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent2); }
  .btn-ghost { background: transparent; color: var(--text2); border: 1px solid var(--border); }
  .btn-ghost:hover { color: var(--text); border-color: var(--text2); }
  .btn:disabled { opacity: .4; cursor: not-allowed; transform: none !important; }
  .btn-row { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 20px; }

  /* â”€â”€ Pills de selecciÃ³ (estil narratiu) â”€â”€ */
  .opts-row {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 4px;
  }
  .opt-pill {
    flex: 1;
    min-width: 130px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 2px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    text-align: center;
    font-size: .88rem;
    font-weight: 600;
    transition: all .2s;
    line-height: 1.4;
    user-select: none;
  }
  .opt-pill small {
    display: block;
    font-weight: 400;
    color: var(--text2);
    font-size: .75rem;
    margin-top: 4px;
  }
  .opt-pill:hover   { border-color: var(--accent); }
  .opt-pill.chosen  { border-color: var(--accent); background: #1e1b38; color: var(--accent2); }
  .opt-pill.chosen small { color: var(--accent2); }

  /* â”€â”€ Llista de premisses â”€â”€ */
  .premise-list { display: flex; flex-direction: column; gap: 10px; }
  .premise-item {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 2px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    transition: all .2s;
  }
  .premise-item:hover  { border-color: var(--accent); }
  .premise-item.chosen { border-color: var(--accent); background: #1e1b38; }
  .premise-item input[type=radio] { margin-top: 2px; accent-color: var(--accent); flex-shrink: 0; }
  .premise-item label { cursor: pointer; line-height: 1.5; font-size: .95rem; }

  /* â”€â”€ Badge Recomanat â”€â”€ */
  .badge-recomanat {
    display: inline-block;
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    color: #fff;
    font-size: .68rem;
    font-weight: 700;
    padding: 2px 9px;
    border-radius: 99px;
    text-transform: uppercase;
    letter-spacing: .07em;
    margin-right: 8px;
    vertical-align: middle;
    flex-shrink: 0;
  }

  /* â”€â”€ Loader â”€â”€ */
  .loader-wrap {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    padding: 32px 0;
    color: var(--text2);
    font-size: .9rem;
  }
  .loader-wrap.visible { display: flex; }
  .spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin .8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* â”€â”€ Toast â”€â”€ */
  #toast {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%) translateY(80px);
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 12px 24px;
    border-radius: 99px;
    font-size: .9rem;
    transition: transform .3s;
    z-index: 9999;
    pointer-events: none;
  }
  #toast.show { transform: translateX(-50%) translateY(0); }

  /* â”€â”€ Reader del conte â”€â”€ */
  .conte-reader {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 40px 48px;
    font-family: 'Georgia', 'Times New Roman', serif;
    font-size: 1.05rem;
    line-height: 1.9;
    color: var(--text);
    max-height: 72vh;
    overflow-y: auto;
  }
  .conte-reader p {
    margin-bottom: 1.1em;
    text-indent: 1.8em;
  }
  .conte-reader p:first-child { text-indent: 0; }
  @media (max-width: 600px) {
    .conte-reader { padding: 24px 20px; font-size: .97rem; }
  }
  .conte-wordcount {
    font-size: .78rem;
    color: var(--text2);
    margin-top: 10px;
    text-align: right;
  }

  /* â”€â”€ Millora â”€â”€ */
  .millora-row {
    display: flex;
    gap: 10px;
    margin-top: 14px;
  }
  .millora-row input {
    flex: 1;
    padding: 10px 14px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-size: .9rem;
    font-family: var(--font);
  }
  .millora-row input:focus { outline: none; border-color: var(--accent); }
  .millora-row input::placeholder { color: var(--text2); }

  /* â”€â”€ Export â”€â”€ */
  .export-link {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    color: var(--accent2);
    text-decoration: none;
    font-size: .9rem;
    font-weight: 600;
    padding: 8px 16px;
    border: 1px solid var(--accent);
    border-radius: 8px;
    transition: all .2s;
  }
  .export-link:hover { background: #1e1b38; }

  /* â”€â”€ Worldbuilding multi-select â”€â”€ */
  .world-item {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 2px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    transition: all .2s;
  }
  .world-item:hover  { border-color: var(--accent); }
  .world-item.chosen { border-color: var(--accent); background: #1e1b38; }
  .world-item input[type=checkbox] { margin-top: 3px; accent-color: var(--accent); flex-shrink: 0; width: 16px; height: 16px; cursor: pointer; }
  .world-item label { cursor: pointer; line-height: 1.5; font-size: .95rem; }

  /* â”€â”€ Resultat worldbuilding â”€â”€ */
  .worldbuilding-result {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 28px 32px;
    font-size: .95rem;
    line-height: 1.85;
    color: var(--text);
  }
  .worldbuilding-result .world-bloc {
    margin-bottom: 22px;
  }
  .worldbuilding-result .world-bloc:last-child {
    margin-bottom: 0;
  }
  .worldbuilding-result .world-bloc-titol {
    color: var(--accent2);
    font-weight: 700;
    font-size: 1rem;
    margin-bottom: 6px;
  }
  .worldbuilding-result .world-bloc-desc {
    color: var(--text);
    padding-left: 12px;
    border-left: 2px solid var(--border);
  }

  /* â”€â”€ Estils de parla (fase 9) â”€â”€ */
  .veu-result {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  .veu-card {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 22px 26px;
  }
  .veu-card-nom {
    color: var(--accent2);
    font-weight: 700;
    font-size: 1.05rem;
    margin-bottom: 14px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border);
  }
  .veu-card-camps {
    display: flex;
    flex-direction: column;
    gap: 10px;
    font-size: .92rem;
    line-height: 1.6;
  }
  .veu-camp-label {
    color: var(--text2);
    font-size: .75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .07em;
    margin-bottom: 3px;
  }
  .veu-camp-val {
    color: var(--text);
    padding-left: 10px;
    border-left: 2px solid var(--border);
  }
  .veu-exemple {
    margin-top: 4px;
    padding: 10px 16px;
    background: var(--surface);
    border-radius: 8px;
    font-family: 'Georgia', serif;
    font-style: italic;
    color: var(--accent2);
    font-size: .95rem;
    line-height: 1.65;
    border-left: 3px solid var(--accent);
  }

  /* â”€â”€ SecciÃ³ amagada â”€â”€ */
  .hidden { display: none !important; }

  /* â”€â”€ Badges de model (Sonnet / Opus) â”€â”€ */
  .badge-model {
    display: inline-flex;
    align-items: center;
    padding: 2px 10px;
    border-radius: 99px;
    font-size: .68rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .06em;
    vertical-align: middle;
    margin-left: 8px;
  }
  .badge-sonnet { background: rgba(124,106,247,.2); color: var(--accent2); border: 1px solid var(--accent); }
  .badge-opus   { background: rgba(96,165,250,.15); color: #93c5fd;        border: 1px solid #60a5fa; }

  /* â”€â”€ Modal overlay (Llibre de Registre) â”€â”€ */
  .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.78);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }
  .modal-overlay.hidden { display: none !important; }
  .modal-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 28px;
    max-width: 680px;
    width: 100%;
    max-height: 82vh;
    overflow-y: auto;
  }

  /* â”€â”€ Llista de capÃ­tols â”€â”€ */
  .capitol-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 9px 14px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: .85rem;
    transition: all .2s;
  }
  .capitol-item.actiu { border-color: var(--accent); background: #1e1b38; }
  .capitol-item.fet   { border-color: var(--success); }
  .capitol-num   { font-weight: 700; color: var(--text2); min-width: 26px; font-size: .8rem; flex-shrink: 0; }
  .capitol-titol { flex: 1; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .capitol-item.actiu .capitol-titol { color: var(--accent2); font-weight: 600; }
  .capitol-item.fet   .capitol-num   { color: var(--success); }
  .capitol-copy { background:none; border:none; color:var(--text2); cursor:pointer; padding:2px 6px; border-radius:4px; font-size:.85rem; opacity:.55; transition:opacity .15s; flex-shrink:0; }
  .capitol-copy:hover { opacity:1; color:var(--accent2); }

  /* â”€â”€ Panel de revisiÃ³ (Opus) â”€â”€ */
  .review-panel {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 18px 22px;
    margin-top: 14px;
  }

  /* â”€â”€ Checkbox gran de configuraciÃ³ â”€â”€ */
  .checkbox-row {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    cursor: pointer;
    margin-top: 14px;
    transition: border-color .2s;
  }
  .checkbox-row:hover { border-color: var(--accent); }
  .checkbox-row input[type=checkbox] {
    width: 18px; height: 18px;
    accent-color: var(--accent);
    flex-shrink: 0;
    cursor: pointer;
    margin-top: 2px;
  }
  .checkbox-row label { cursor: pointer; line-height: 1.5; }

  /* â”€â”€ Camps de config per proveÃ¯dor â”€â”€ */
  .config-section { margin-top: 4px; }
</style>
</head>
<body>

<header>
  <h1>ğŸ“– Conte IA</h1>
  <p>Crea el teu conte pas a pas amb intelÂ·ligÃ¨ncia artificial</p>
</header>

<!-- CONFIGURACIÃ“ INICIAL -->
<div class="card" id="card-config">
  <h2><span class="icon">âš™ï¸</span> ConfiguraciÃ³</h2>

  <label class="field-label" for="config-provider">ProveÃ¯dor</label>
  <select id="config-provider" onchange="actualitzarConfigProvider()">
    <option value="anthropic">Anthropic (Claude) â€” Sistema dual Sonnet + Opus</option>
    <option value="openai">OpenAI (GPT-4o)</option>
    <option value="gemini">Google (Gemini 1.5)</option>
  </select>

  <!-- Camps especÃ­fics Anthropic (model dual) -->
  <div id="config-anthropic-fields" class="config-section">
    <label class="field-label" for="config-model-generacio">
      Model de generaciÃ³ <span style="color:var(--text2);font-size:.78rem;">â€” escriptura creativa</span>
    </label>
    <input type="text" id="config-model-generacio" value="claude-sonnet-4-6" placeholder="claude-sonnet-4-6">

    <label class="field-label" for="config-model-arquitectura">
      Model d'arquitectura <span style="color:var(--text2);font-size:.78rem;">â€” disseny i revisiÃ³</span>
    </label>
    <input type="text" id="config-model-arquitectura" value="claude-opus-4-6" placeholder="claude-opus-4-6">

    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px;">
      <div>
        <label class="field-label" for="config-provider-generacio" style="margin-bottom:4px;">ProveÃ¯dor GeneraciÃ³</label>
        <select id="config-provider-generacio">
          <option value="anthropic">Anthropic (Claude)</option>
          <option value="gemini">Google (Gemini)</option>
          <option value="openai">OpenAI (GPT)</option>
        </select>
      </div>
      <div>
        <label class="field-label" for="config-provider-arquitectura" style="margin-bottom:4px;">ProveÃ¯dor Arquitectura</label>
        <select id="config-provider-arquitectura">
          <option value="anthropic">Anthropic (Claude)</option>
          <option value="gemini">Google (Gemini)</option>
          <option value="openai">OpenAI (GPT)</option>
        </select>
      </div>
    </div>

    <div class="checkbox-row" onclick="document.getElementById('config-flux-automatic').click()">
      <input type="checkbox" id="config-flux-automatic" onclick="event.stopPropagation()">
      <label for="config-flux-automatic">
        <strong>Flux automÃ tic</strong> â€” Opus revisa cada capÃ­tol i Sonnet el corregeix si cal
        <small style="display:block;color:var(--text2);font-size:.78rem;margin-top:2px;">Si estÃ  desactivat, la revisiÃ³ Ã©s manual (botons per capÃ­tol)</small>
      </label>
    </div>

    <!-- Panell de selecciÃ³ de models flexible v5.1 -->
    <div id="panellModels" style="margin-top:14px;padding:14px;border:1px solid var(--border);border-radius:8px;">
      <h3 style="margin:0 0 10px;font-size:1em;">âš™ï¸ ConfiguraciÃ³ de Models</h3>

      <div style="margin-bottom:10px;">
        <label style="font-weight:bold;font-size:.85em;">Presets rÃ pids:</label>
        <div style="display:flex;gap:6px;margin-top:4px;flex-wrap:wrap;">
          <button onclick="aplicarPreset('economic')"   class="btn" style="padding:3px 8px;font-size:.78rem;" title="Haiku+Sonnet+Sonnet">ğŸ’° EconÃ²mic</button>
          <button onclick="aplicarPreset('equilibrat')" class="btn" style="padding:3px 8px;font-size:.78rem;" title="Sonnet+Sonnet+Sonnet">âš–ï¸ Equilibrat</button>
          <button onclick="aplicarPreset('premium')"    class="btn" style="padding:3px 8px;font-size:.78rem;" title="Sonnet+Sonnet+Opus">ğŸ‘‘ Premium</button>
          <button onclick="aplicarPreset('maxim')"      class="btn" style="padding:3px 8px;font-size:.78rem;" title="Sonnet+Opus+Opus">ğŸ”¬ MÃ xim</button>
          <button onclick="aplicarPreset('barat_gpt')"  class="btn" style="padding:3px 8px;font-size:.78rem;" title="GPT-5.2 per tot">ğŸ¤– GPT-5.2</button>
          <button onclick="aplicarPreset('gemini')"     class="btn" style="padding:3px 8px;font-size:.78rem;" title="Gemini 3 Pro per tot">ğŸŒ Gemini 3</button>
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-bottom:10px;">
        <div>
          <label style="font-size:.82em;font-weight:bold;">ğŸ“ Draft / ExtracciÃ³</label>
          <p style="font-size:.73em;color:var(--text2);margin:2px 0 4px;">Esquelets, fets NKG</p>
          <select id="selectModelDraft" onchange="setModelPerRol('draft', this.value)" style="width:100%;font-size:.78rem;"></select>
          <div id="qualitatDraft" style="font-size:.78em;margin-top:3px;"></div>
        </div>
        <div>
          <label style="font-size:.82em;font-weight:bold;">âœï¸ GeneraciÃ³ LiterÃ ria</label>
          <p style="font-size:.73em;color:var(--text2);margin:2px 0 4px;">Prosa, expansiÃ³</p>
          <select id="selectModelGen" onchange="setModelPerRol('generacio', this.value)" style="width:100%;font-size:.78rem;"></select>
          <div id="qualitatGen" style="font-size:.78em;margin-top:3px;"></div>
        </div>
        <div>
          <label style="font-size:.82em;font-weight:bold;">ğŸ—ï¸ Arquitecte / Revisor</label>
          <p style="font-size:.73em;color:var(--text2);margin:2px 0 4px;">Estructura, diagnÃ²stic</p>
          <select id="selectModelArq" onchange="setModelPerRol('arquitecte', this.value)" style="width:100%;font-size:.78rem;"></select>
          <div id="qualitatArq" style="font-size:.78em;margin-top:3px;"></div>
        </div>
      </div>

      <div id="panellEstimacio" style="background:var(--surface2);border-radius:6px;padding:10px;font-size:.88em;"></div>
      <div id="panellAvisos" style="margin-top:6px;font-size:.82em;"></div>
    </div>
  </div>

  <!-- Camp Ãºnic per a OpenAI / Gemini -->
  <div id="config-single-model-field" class="config-section hidden">
    <label class="field-label" for="config-model-single">Model</label>
    <input type="text" id="config-model-single" placeholder="gpt-4o" value="gpt-4o">
  </div>

  <label class="field-label" for="anthropicApiKey">ğŸ”‘ Anthropic API Key</label>
  <input type="password" id="anthropicApiKey" placeholder="sk-ant-..." oninput="guardarClausAPI()">

  <label class="field-label" for="geminiApiKey" style="margin-top:6px;">ğŸ”‘ Google Gemini API Key <span style="color:var(--text2);font-size:.78rem;">(opcional â€” per a models Gemini)</span></label>
  <input type="password" id="geminiApiKey" placeholder="AIza..." oninput="guardarClausAPI()">

  <label class="field-label" for="openaiApiKey" style="margin-top:6px;">ğŸ”‘ OpenAI API Key <span style="color:var(--text2);font-size:.78rem;">(opcional â€” per a models GPT)</span></label>
  <input type="password" id="openaiApiKey" placeholder="sk-..." oninput="guardarClausAPI()">

  <div style="margin-top:20px;padding-top:16px;border-top:1px solid var(--border);">
    <h3 style="margin:0 0 10px;font-size:1em;">ğŸ­ Estil i To Global del Projecte</h3>

    <label class="field-label" for="config-genere">GÃ¨nere Literari</label>
    <input type="text" id="config-genere" value="Thriller / Nordic Noir" placeholder="ex: CiÃ¨ncia-FicciÃ³, Nordic Noir...">

    <label class="field-label" for="config-autor">Autor de ReferÃ¨ncia</label>
    <input type="text" id="config-autor" value="Stieg Larsson" placeholder="ex: Stieg Larsson, Tolkien...">

    <label class="field-label" for="config-focus-climax">Focus del ClÃ­max (Cost acumulat)</label>
    <input type="text" id="config-focus-climax" value="Cost fÃ­sic extrem, esgotament mental, entorns freds i hostils, cinisme" placeholder="ex: Esgotament fÃ­sic, xoc moral...">
  </div>

  <div class="btn-row">
    <button class="btn btn-primary" onclick="guardarIComencar()">Guardar i ComenÃ§ar Nou</button>
    <button id="btn-reprendre" class="btn btn-secondary hidden" onclick="reprendreProjecteLocal()">ğŸ“‚ Reprendre projecte anterior</button>
  </div>
</div>

<!-- Progress -->
<div id="progress-wrap" class="hidden">
  <div class="progress-steps" id="steps-bar">
    <div class="step-pill active" data-step="0">GÃ¨nere</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="1">Premissa</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="2">Estil</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="3">Protagonista</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="4">LocalitzaciÃ³</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="5">Final</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="6">Escriptura</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="7">MÃ³n</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="8">Personatges</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="9">Veus</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="9.5">Trames</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="10">Estructura</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="10.5">Escaleta</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="11">CapÃ­tols</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="12">Control d'Arcs</div>
  </div>
</div>

<!-- FASE 0: SelecciÃ³ de gÃ¨nere -->
<div class="card hidden" id="fase-0">
  <h2><span class="icon">ğŸ­</span> Tria el gÃ¨nere</h2>
  <label class="field-label" for="sel-tematica">Tipus de conte</label>
  <select id="sel-tematica">
    <option value="">â€” Selecciona un autor â€”</option>
    <option value="conte negre nÃ²rdic (Stieg Larsson)">Stieg Larsson â€” Noir, misteri i crÃ­tica social</option>
    <option value="conte fantÃ stic Ã¨pic (J.R.R. Tolkien)">J.R.R. Tolkien â€” Fantasia Ã¨pica</option>
    <option value="conte de ciÃ¨ncia-ficciÃ³ distÃ²pica (Philip K. Dick)">Philip K. Dick â€” Distopia, paranoia i drogues</option>
    <option value="conte de misticisme xamÃ nic (Carlos Castaneda)">Carlos Castaneda â€” Misticisme xamÃ nic</option>
  </select>
  <div class="btn-row">
    <button class="btn btn-primary" onclick="iniciarFase1()">âœ¨ Generar premisses</button>
  </div>
</div>

<!-- FASE 1: SelecciÃ³ de premissa -->
<div class="card hidden" id="fase-1">
  <h2><span class="icon">ğŸ’¡</span> Tria la premissa</h2>
  <div class="loader-wrap" id="loader-1">
    <div class="spinner"></div>
    <span>Generant 10 premissesâ€¦</span>
  </div>
  <div id="llista-premisses" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase1" onclick="iniciarFase2()">ğŸ¨ Triar estil narratiu</button>
  </div>
</div>

<!-- FASE 2: Estil narratiu (sense crida a LLM) -->
<div class="card hidden" id="fase-2">
  <h2><span class="icon">ğŸ¨</span> Estil narratiu</h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:4px;">Defineix el to, la perspectiva i la longitud del conte.</p>

  <label class="field-label">To i atmosfera</label>
  <select id="sel-to">
    <option value="">â€” Tria el to â€”</option>
    <option value="misteri i suspens creixent">Misteri i suspens</option>
    <option value="terror psicolÃ²gic i claustrofÃ²bic">Terror psicolÃ²gic</option>
    <option value="realisme mÃ gic poÃ¨tic">Realisme mÃ gic</option>
    <option value="humor negre i irÃ²nic">Humor negre</option>
    <option value="melancolia i bittersweet">Melancolia / bittersweet</option>
    <option value="thriller emocional d'alta tensiÃ³">Thriller emocional</option>
    <option value="tendresa i vulnerabilitat">Tendresa i vulnerabilitat</option>
    <option value="absurd i kafkiÃ ">Absurd / kafkiÃ </option>
    <option value="meravella i mÃ gia continguda">MÃ gia i meravella</option>
    <option value="rÃ bia i tensiÃ³ social">RÃ bia i tensiÃ³ social</option>
  </select>

  <label class="field-label">Perspectiva narrativa</label>
  <div class="opts-row" id="opts-perspectiva">
    <div class="opt-pill" data-group="perspectiva" data-val="primera persona (narrador protagonista)" onclick="triarPill(this)">
      1a persona
      <small>Jo narrador</small>
    </div>
    <div class="opt-pill" data-group="perspectiva" data-val="tercera persona limitada (focalitzaciÃ³ Ãºnica en el protagonista)" onclick="triarPill(this)">
      3a persona
      <small>FocalitzaciÃ³ Ãºnica</small>
    </div>
    <div class="opt-pill" data-group="perspectiva" data-val="segona persona (el lector Ã©s el protagonista)" onclick="triarPill(this)">
      2a persona
      <small>Tu ets el protagonista</small>
    </div>
  </div>

  <label class="field-label">Longitud del conte</label>
  <div class="opts-row" id="opts-paraules">
    <div class="opt-pill" data-group="paraules" data-val="500" onclick="triarPill(this)">
      Microconte
      <small>~500 paraules</small>
    </div>
    <div class="opt-pill" data-group="paraules" data-val="1500" onclick="triarPill(this)">
      Conte curt
      <small>~1.500 paraules</small>
    </div>
    <div class="opt-pill" data-group="paraules" data-val="3000" onclick="triarPill(this)">
      Conte llarg
      <small>~3.000 paraules</small>
    </div>
  </div>

  <!-- Veu Semilla (opcional) -->
  <div style="margin-top:20px;padding-top:16px;border-top:1px solid var(--border);">
    <label class="field-label">Veu de ReferÃ¨ncia (opcional) <span style="font-weight:400;color:var(--text2)">â€” Enganxa 2-3 pÃ gines d'un autor que t'agradi</span></label>
    <textarea id="veuSemilla" style="width:100%;min-height:120px;background:var(--surface2);border:1px solid var(--border);border-radius:8px;color:var(--text);padding:12px;font-size:.88rem;resize:vertical;" placeholder="Opcional: enganxa un fragment d'un autor de referÃ¨ncia (mÃ­nim 200 carÃ cters). Opus analitzarÃ  el seu estil i en generarÃ  un manual per guiar l'escriptura."></textarea>
    <button class="btn btn-secondary" style="margin-top:8px;" onclick="processarVeuSemilla()">ğŸ­ Analitzar estil de referÃ¨ncia <span class="badge-model badge-opus">Opus</span></button>
    <div id="veuSemilla-result" style="margin-top:8px;font-size:.83rem;color:var(--success);"></div>
  </div>
  <div class="btn-row">
    <button class="btn btn-primary" onclick="iniciarFase3()">ğŸ‘¤ Triar protagonista</button>
  </div>
</div>

<!-- FASE 3: Protagonista -->
<div class="card hidden" id="fase-3">
  <h2><span class="icon">ğŸ‘¤</span> Tria el protagonista</h2>
  <div class="loader-wrap" id="loader-3">
    <div class="spinner"></div>
    <span>Generant protagonistesâ€¦</span>
  </div>
  <div id="llista-personatges" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase3" onclick="iniciarFase4()">ğŸ“ Triar la localitzaciÃ³</button>
  </div>
</div>

<!-- FASE 4: Localitzacions -->
<div class="card hidden" id="fase-4">
  <h2><span class="icon">ğŸ“</span> Tria la localitzaciÃ³</h2>
  <div class="loader-wrap" id="loader-4">
    <div class="spinner"></div>
    <span>Generant 5 localitzacionsâ€¦</span>
  </div>
  <div id="llista-localitzacions" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase4" onclick="iniciarFase5()">ğŸ Triar el final</button>
  </div>
</div>

<!-- FASE 5: Finals -->
<div class="card hidden" id="fase-5">
  <h2><span class="icon">ğŸ</span> Tria el final</h2>
  <div class="loader-wrap" id="loader-5">
    <div class="spinner"></div>
    <span>Generant 5 finals possiblesâ€¦</span>
  </div>
  <div id="llista-finals" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase5" onclick="iniciarEscriptura()">âœï¸ Escriure el conte</button>
  </div>
</div>

<!-- FASE 6: Escriptura -->
<div class="card hidden" id="fase-6">
  <h2><span class="icon">âœï¸</span> El teu conte</h2>
  <div class="loader-wrap" id="loader-6">
    <div class="spinner"></div>
    <span id="loader-6-text">Escrivint el conteâ€¦</span>
  </div>
  <div id="conte-wrap" class="hidden">
    <div class="conte-reader" id="conte-cos"></div>
    <div class="conte-wordcount" id="conte-wordcount"></div>

    <!-- Millora -->
    <div class="millora-row">
      <input type="text" id="millora-input" placeholder="Vols millorar alguna cosa? (ex: Â«fes l'ending mÃ©s abrupteÂ»)">
      <button class="btn btn-secondary" onclick="handleMillorarConte()">âœ¨ Millorar</button>
    </div>

    <div class="btn-row">
      <button class="btn btn-secondary" onclick="regenerarConte()">ğŸ”„ Regenerar</button>
      <button class="btn btn-secondary" onclick="exportarDoc()">ğŸ“„ Descarregar DOCX</button>
      <button class="btn btn-primary"   onclick="iniciarFase7()">ğŸŒ Expandir a novelÂ·la</button>
    </div>
    <div id="export-link-wrap" class="hidden" style="margin-top:14px;"></div>
  </div>
</div>

<!-- FASE 7: Worldbuilding -->
<div class="card hidden" id="fase-7">
  <h2><span class="icon">ğŸŒ</span> ExpansiÃ³ del mÃ³n</h2>
  <div class="loader-wrap" id="loader-7">
    <div class="spinner"></div>
    <span id="loader-7-text">Analitzant el conte per proposar elements de mÃ³nâ€¦</span>
  </div>

  <div id="world-selector" class="hidden">
    <p style="color:var(--text2);font-size:.9rem;margin-bottom:16px;">Selecciona els elements que vols expandir a la bÃ­blia de mÃ³n. Els <span style="color:var(--accent2);font-weight:600;">Recomanats</span> ja estan marcats:</p>
    <div id="llista-world" class="premise-list"></div>
    <div class="btn-row">
      <button class="btn btn-primary" onclick="expandirElementsSeleccionats()">ğŸŒ Expandir seleccionats</button>
    </div>
  </div>

  <div id="world-result-wrap" class="hidden">
    <div class="worldbuilding-result" id="world-result-cos"></div>
    <div class="btn-row" style="margin-top:20px;">
      <button class="btn btn-secondary" onclick="tornarASeleccioWorld()">â† Tornar a la selecciÃ³</button>
      <button class="btn btn-primary"   onclick="iniciarFase8()">ğŸ‘¥ Crear elenc de personatges</button>
    </div>
  </div>
</div>


<!-- FASE 8: Elenc de personatges -->
<div class="card hidden" id="fase-8">
  <h2><span class="icon">ğŸ‘¥</span> Elenc de personatges</h2>
  <div class="loader-wrap" id="loader-8">
    <div class="spinner"></div>
    <span id="loader-8-text">Proposant el cast de personatgesâ€¦</span>
  </div>

  <div id="elenc-selector" class="hidden">
    <p style="color:var(--text2);font-size:.9rem;margin-bottom:16px;">Selecciona els personatges que formaran part de la novelÂ·la. Els <span style="color:var(--accent2);font-weight:600;">Recomanats</span> ja estan marcats:</p>
    <div id="llista-elenc" class="premise-list"></div>
    <div class="btn-row">
      <button class="btn btn-primary" onclick="generarEstilsParla()">ğŸ—£ï¸ Definir estils de parla</button>
    </div>
  </div>
</div>

<!-- FASE 9: Estils de parla -->
<div class="card hidden" id="fase-9">
  <h2><span class="icon">ğŸ—£ï¸</span> Estils de parla</h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Perfil de veu i registre narratiu per a cada personatge de l'elenc.</p>
  <div class="loader-wrap" id="loader-9">
    <div class="spinner"></div>
    <span>Definint la veu de cada personatgeâ€¦</span>
  </div>

  <div id="estils-result" class="hidden">
    <div class="veu-result" id="estils-cos"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-secondary" onclick="tornarAElenc()">â† Tornar a l'elenc</button>
      <button class="btn btn-primary" onclick="iniciarFaseTrames()">ğŸ•¸ï¸ Dissenyar Trames <span class="badge-model badge-opus">Opus</span></button>
    </div>
  </div>
</div>

<!-- FASE 9.5: Disseny de Trames (Opus) -->
<div class="card hidden" id="fase-9-5">
  <h2><span class="icon">ğŸ•¸ï¸</span> Disseny de Trames <span class="badge-model badge-opus">Opus</span></h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Opus dissenya la trama principal i les subtrames abans d'estructurar els capÃ­tols.</p>
  <div class="loader-wrap" id="loader-9-5">
    <div class="spinner" style="border-top-color:#60a5fa;"></div>
    <span id="loader-9-5-text">ğŸ”µ Opus dissenyant les tramesâ€¦</span>
  </div>
  <div id="trames-result" class="hidden">
    <div id="trames-cos"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-primary" onclick="iniciarFase10()">ğŸ“ Crear Estructura <span class="badge-model badge-opus">Opus</span></button>
    </div>
  </div>
</div>

<!-- FASE 10: Estructura de la novelÂ·la (Opus) -->
<div class="card hidden" id="fase-10">
  <h2><span class="icon">ğŸ“</span> Estructura de la novelÂ·la <span class="badge-model badge-opus">Opus</span></h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Opus dissenya l'arquitectura narrativa completa â€” capÃ­tols, arcs i fils â€” a partir de tot el material generat.</p>
  <div class="loader-wrap" id="loader-10">
    <div class="spinner" style="border-top-color:#60a5fa;"></div>
    <span id="loader-10-text">ğŸ”µ Opus dissenyant l'estructuraâ€¦</span>
  </div>
  <div id="estructura-wrap" class="hidden">
    <div id="estructura-cos"></div>
    <div id="estimacio-cost" style="white-space:pre;font-family:monospace;font-size:.82rem;color:var(--text2);background:var(--surface2);border-radius:8px;padding:12px 16px;margin:16px 0;border-left:3px solid var(--accent2);display:block;"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-primary" onclick="iniciarFaseEscaleta()">ğŸ“– Escriure capÃ­tols <span class="badge-model badge-sonnet">Sonnet</span></button>
    </div>
  </div>
</div>

<!-- FASE 10.5: Escaleta per Escenes (Opus) -->
<div class="card hidden" id="fase-10-5">
  <h2>ğŸ“‹ Fase 10.5 â€” Escaleta per Escenes</h2>
  <p>Opus genera l'escaleta detallada per escenes de tots els capÃ­tols, incloent objectiu de paraules i funciÃ³ narrativa de cada escena.</p>
  <div class="loader-wrap" id="loader-10-5"><span class="spinner"></span><span id="loader-10-5-text">Generant escaletaâ€¦</span></div>
  <div id="escaleta-result"></div>
  <button class="btn hidden" id="btn-fase11" onclick="iniciarFase11()">Continuar â†’ Escriptura</button>
</div>

<!-- FASE 11: Escriptura de capÃ­tols (Sonnet + registre) -->
<div class="card hidden" id="fase-11">
  <h2><span class="icon">ğŸ“–</span> Escriptura de capÃ­tols</h2>

  <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:14px;flex-wrap:wrap;gap:8px;">
    <div id="capitol-progress-text" style="color:var(--text2);font-size:.88rem;"></div>
    <button class="btn btn-ghost" style="padding:7px 14px;font-size:.82rem;" onclick="obrirLlibreRegistre()">ğŸ““ Llibre de Registre</button>
    <button class="btn btn-ghost" style="padding:7px 14px;font-size:.82rem;" onclick="obrirBiblia()">ğŸ“š BÃ­blia Narrativa</button>
  </div>

  <div id="capitol-llista" style="display:flex;flex-direction:column;gap:6px;margin-bottom:20px;max-height:260px;overflow-y:auto;"></div>

  <div class="loader-wrap" id="loader-11">
    <div class="spinner"></div>
    <span id="loader-11-text">ğŸŸ£ Sonnet escrivint el capÃ­tolâ€¦</span>
  </div>

  <div id="capitol-actual-wrap" class="hidden">
    <div id="capitol-actual-titol" style="font-size:1.05rem;font-weight:700;color:var(--accent2);margin-bottom:14px;padding-bottom:10px;border-bottom:1px solid var(--border);"></div>
    <div class="conte-reader" id="capitol-actual-cos"></div>
    <div class="conte-wordcount" id="capitol-actual-wordcount"></div>
    <div id="revisio-panel" class="hidden review-panel"></div>
    <div id="checkpoint-intermedi-panel" class="hidden" style="margin-top:16px;padding:16px;background:var(--surface2);border-radius:10px;border-left:3px solid #f59e0b;"></div>
    <div class="btn-row" id="capitol-accions" style="margin-top:16px;"></div>
  </div>

  <div id="btn-control-arcs-wrap" class="hidden" style="margin-top:24px;padding-top:20px;border-top:1px solid var(--border);">
    <p style="color:var(--text2);font-size:.88rem;margin-bottom:14px;text-align:center;">Tots els capÃ­tols estan escrits.</p>

    <!-- RevisiÃ³ Global (loader) -->
    <div id="revisio-global-loader" class="hidden" style="display:flex;align-items:center;gap:10px;color:var(--text2);font-size:.88rem;margin-bottom:16px;padding:14px;background:var(--surface2);border-radius:8px;">
      <div class="spinner" style="border-top-color:#60a5fa;width:24px;height:24px;border-width:2px;"></div>
      <span>ğŸ”µ Opus fent revisiÃ³ global transversalâ€¦</span>
    </div>

    <!-- Resultats de la RevisiÃ³ Global -->
    <div id="revisio-global-result" class="hidden" style="margin-bottom:16px;"></div>

    <!-- Botons de reescriptura suggerits per Opus -->
    <div id="revisio-global-reescriptures" style="margin-bottom:16px;display:flex;gap:10px;flex-wrap:wrap;"></div>

    <!-- Botons de flux -->
    <div style="text-align:center;display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
      <button class="btn btn-primary hidden" id="btn-control-arcs" onclick="iniciarFase12()">ğŸ“‹ Control d'Arcs Narratius <span class="badge-model badge-opus">Opus</span></button>
      <button class="btn btn-secondary" onclick="descarregarNovella()">ğŸ“– Descarregar NovelÂ·la</button>
    </div>
  </div>
</div>

<!-- FASE 12: Control d'Arcs Narratius (Opus - light) -->
<div class="card hidden" id="fase-12">
  <h2><span class="icon">ğŸ“‹</span> Control d'Arcs Narratius <span class="badge-model badge-opus">Opus</span></h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Opus avalua la novelÂ·la a partir dels resums â€” sense llegir el text complet â€” per estalviar tokens.</p>
  <div class="loader-wrap" id="loader-12">
    <div class="spinner" style="border-top-color:#60a5fa;"></div>
    <span>ğŸ”µ Opus analitzant els arcs narratiusâ€¦</span>
  </div>
  <div id="arcs-result" class="hidden">
    <div id="arcs-cos"></div>
    <div class="btn-row" style="margin-top:20px;">
      <button class="btn btn-primary hidden" id="btn-epileg" onclick="escriureEpileg()">âœ¨ Escriure EpÃ­leg Resolutiu <span class="badge-model badge-sonnet">Sonnet</span></button>
    </div>
  </div>
  <div id="epileg-loader-wrap" class="hidden" style="padding:20px 0;border-top:1px solid var(--border);margin-top:20px;">
    <div style="display:flex;align-items:center;gap:10px;color:var(--text2);font-size:.88rem;margin-bottom:14px;">
      <div class="spinner" style="width:24px;height:24px;border-width:2px;"></div>
      <span>ğŸŸ£ Sonnet escrivint l'epÃ­legâ€¦</span>
    </div>
  </div>
  <div id="epileg-cos" class="hidden" style="margin-top:20px;padding-top:20px;border-top:1px solid var(--border);">
    <h3 style="font-size:1rem;font-weight:600;color:var(--accent2);margin-bottom:14px;">EpÃ­leg</h3>
    <div class="conte-reader" id="epileg-text"></div>
    <div class="btn-row" style="margin-top:20px;">
      <button class="btn btn-primary" onclick="descarregarNovella()">ğŸ“– Descarregar NovelÂ·la Completa</button>
    </div>
  </div>
</div>

<!-- Modal: Llibre de Registre -->
<div class="modal-overlay hidden" id="modal-registre">
  <div class="modal-box">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px;">
      <h3 style="font-size:1.1rem;font-weight:600;color:var(--accent2);">ğŸ““ Llibre de Registre</h3>
      <button class="btn btn-ghost" style="padding:6px 14px;" onclick="tancarModalRegistre()">âœ• Tancar</button>
    </div>
    <div id="registre-cos"></div>
  </div>
</div>

<!-- Modal: BÃ­blia Narrativa -->
<div class="modal-overlay hidden" id="modal-biblia">
  <div class="modal-box" style="max-width:760px;">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px;">
      <h3 style="font-size:1.1rem;font-weight:600;color:var(--accent2);">ğŸ“š BÃ­blia Narrativa</h3>
      <button class="btn btn-ghost" style="padding:6px 14px;" onclick="tancarModalBiblia()">âœ• Tancar</button>
    </div>
    <div id="biblia-cos"></div>
  </div>
</div>

<div id="toast"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     FRONTEND â€” utilitats i lÃ²gica de navegaciÃ³
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITATS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function escHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function showCard(id)  { document.getElementById(id).classList.remove('hidden'); }
function hideCard(id)  { document.getElementById(id).classList.add('hidden'); }
function showLoader(n) { document.getElementById('loader-' + n).classList.add('visible'); }
function hideLoader(n) {
  document.getElementById('loader-' + n).classList.remove('visible');
  // Autoguardat cada cop que un procÃ©s de la IA acaba
  guardarProjecteLocal();
}
function showBtn(id)   { document.getElementById(id).classList.remove('hidden'); }

// --- SISTEMA DE PERSISTÃˆNCIA ---
function guardarProjecteLocal() {
  if (ESTAT.fase === 0) return; // No guardem si no ha comenÃ§at
  try {
    const dades = { estat: ESTAT, config: USER_CONFIG };
    localStorage.setItem('booki_projecte_actual', JSON.stringify(dades));
  } catch (e) {
    console.warn("No s'ha pogut guardar a localStorage:", e);
  }
}

function comprovarProjecteGuardat() {
  const guardat = localStorage.getItem('booki_projecte_actual');
  if (guardat) {
    document.getElementById('btn-reprendre').classList.remove('hidden');
  }
}

function reprendreProjecteLocal() {
  const guardat = localStorage.getItem('booki_projecte_actual');
  if (!guardat) return;
  try {
    const dades = JSON.parse(guardat);
    Object.assign(ESTAT, dades.estat);
    USER_CONFIG = dades.config;

    // Restaurar Claus API a la UI (opcional perÃ² Ãºtil)
    if (ESTAT._anthropicApiKey) document.getElementById('anthropicApiKey').value = ESTAT._anthropicApiKey;
    if (ESTAT._openaiApiKey) document.getElementById('openaiApiKey').value = ESTAT._openaiApiKey;
    if (ESTAT._geminiApiKey) document.getElementById('geminiApiKey').value = ESTAT._geminiApiKey;

    restaurarInterficieDesDeEstat();
    toast('Projecte recuperat amb Ã¨xit.');
  } catch (e) {
    toast('Error en recuperar el projecte: ' + e.message);
  }
}

function restaurarInterficieDesDeEstat() {
  hideCard('card-config');
  document.getElementById('progress-wrap').classList.remove('hidden');

  const fase = ESTAT.fase;
  updateProgress(fase);

  // Amagar totes les fases i mostrar nomÃ©s l'actual
  document.querySelectorAll('.card').forEach(c => {
    if (c.id !== 'card-config') c.classList.add('hidden');
  });
  showCard('fase-' + Math.floor(fase));

  // Reconstruir l'estat visual depenent de la fase
  if (fase >= 1 && ESTAT._premissaLista.length > 0) renderPremisses(ESTAT._premissaLista.map((p, i) => `${i+1}. ${p}`).join('\\n'));
  if (fase >= 3 && ESTAT._llistaProtagonistes.length > 0) renderProtagonistes(ESTAT._llistaProtagonistes.map((p, i) => `${i+1}. ${p}`).join('\\n'));
  if (fase >= 4 && ESTAT._llistaLocalitzacions.length > 0) renderLlistaAmbRecomanat(ESTAT._llistaLocalitzacions.map((p, i) => `${i+1}. ${p}`).join('\\n'), 'llista-localitzacions', '_llistaLocalitzacions', '_idxLocalitzacio', 'btn-fase4');
  if (fase >= 5 && ESTAT._llistaFinals.length > 0) renderLlistaAmbRecomanat(ESTAT._llistaFinals.map((p, i) => `${i+1}. ${p}`).join('\\n'), 'llista-finals', '_llistaFinals', '_idxFinal', 'btn-fase5');
  if (fase >= 6 && ESTAT.conteText) mostrarConte(ESTAT.conteText);
  if (fase >= 7 && ESTAT.worldbuilding) mostrarResultatWorldbuilding(ESTAT.worldbuilding);
  if (fase >= 9 && ESTAT.estilsParla) mostrarEstilsParla(ESTAT.estilsParla);
  if (fase >= 10 && ESTAT._estructuraCapitols.length > 0) mostrarEstructura('ReconstruÃ¯t des de memÃ²ria (dades en JSON actiu)');
  if (fase >= 10.5 && ESTAT._escaletes.length > 0) {
    mostrarEscaleta(ESTAT._escaletes);
    document.getElementById('btn-fase11').classList.remove('hidden');
  }
  if (fase >= 11) {
    renderLlistaCapitols();
    if (ESTAT._nkg) nkgInicialitzar(); // Re-assigna objectes de memÃ²ria
    ESTAT._nkg = ESTAT._nkg; // MantÃ© el reference si ja hi era

    // Si estem a meitat d'escriure
    const capActual = ESTAT._capitolActual || 0;
    if (ESTAT._capitols_generats[capActual]) {
      mostrarCapitol(capActual, ESTAT._capitols_generats[capActual]);
      mostrarAccionsCapitolSimple(capActual, capActual >= ESTAT._estructuraCapitols.length - 1);
    }
  }
}

function toast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 3200);
}

function updateProgress(fase) {
  document.querySelectorAll('.step-pill').forEach(el => {
    const s = parseFloat(el.dataset.step);
    el.classList.remove('active', 'done');
    if (s < fase)  el.classList.add('done');
    if (s === fase) el.classList.add('active');
  });
}

function compteParaules(text) {
  return text.trim().split(/\s+/).filter(w => w.length > 0).length;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ESTAT GLOBAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let USER_CONFIG = null;

const ESTAT = {
  fase:             0,
  tematica:         '',
  history:          [],
  premissaTriada:   '',
  _premissaLista:   [],
  _premissaIdx:     undefined,
  estil: {
    to:          '',
    perspectiva: '',
    paraules:    1500,
    desc:        ''
  },
  _llistaProtagonistes:  [],
  _idxProtagonista:      null,
  protagonistaTriat:     '',
  _llistaLocalitzacions: [],
  _idxLocalitzacio:      null,
  localitzacioTriada:    '',
  _llistaFinals:         [],
  _idxFinal:             null,
  finalTriat:            '',
  // Escriptura per parts
  _historyBeforeEscriptura: [],
  _totalParts:              1,
  _partActual:              1,
  _partsTexts:              [],
  conteText:                '',
  // Worldbuilding
  worldbuilding:            null,
  // Elenc de personatges (fase 8)
  _elencPersonatges:        [],
  // Estils de parla (fase 9)
  _personatgesSeleccionats: [],
  estilsParla:              null,
  // NovelÂ·la (fases 10-12)
  estructuraNovella:        null,
  _estructuraCapitols:      [],
  _capitolActual:           0,
  _capitols_generats:       [],
  _revisioInstruccions:     {},
  _controlArcs:             null,
  _checkpointIntermedi:     null,
  epileg:                   null,
  // NovelÂ·la: dades de l'estructura JSON
  _arcGlobal:               '',
  _arcMoral:                null,
  _temesCentrals:           [],
  _prefiguracions:          [],
  _corbaTensio:             [],
  _revisioGlobal:           null,
  _ajustosRumb:             null,
  // BÃ­blia Narrativa Persistent (sistema 1)
  bibliaNarrativa: {
    regles_mon:         [],
    llocs_importants:   [],
    objectes_clau:      [],
    fitxes_personatges: [],
    timeline:           [],
    xarxa_relacions:    [],
    fets_canonics:      []
  },
  // Trames i subtrames (sistema 2)
  trames: {
    trama_principal: null,
    subtrames:        [],
    mapa_entrellacat: []
  },
  llibreRegistre: {
    capitols:          [],
    estat_personatges: [],
    fils_oberts:       [],
    fils_tancats:      []
  },
  _escaletes: [],
  _memoriasComprimides: [],
  _goldenPassage: null,
  _goldenPassageCapitol: -1,
  // NKG (Narrative Knowledge Graph) â€” v4
  _nkg: null,
  _resumCompacte: '',
  _escenes_generades: {},
  // Veu Semilla â€” v4 (fase 6)
  _veuSemilla: null,
  _manualEstil: null,
  // CapÃ­tols adaptatius (v5)
  _nombreCapitols: 12,
  _justificacioCapitols: '',
  // Models per rol (v5.1 â€” selector flexible)
  _modelDraft:      'claude-haiku-4-5-20251001',
  _modelGeneracio:  'claude-sonnet-4-6',
  _modelArquitecte: 'claude-sonnet-4-6',
  // Claus API per proveÃ¯dor (v5.1)
  _anthropicApiKey: '',
  _geminiApiKey:    '',
  _openaiApiKey:    '',
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIGURACIÃ“
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MODEL_DEFAULTS = {
  anthropic: { generacio: 'claude-sonnet-4-6', arquitectura: 'claude-opus-4-6' },
  openai:    { single: 'gpt-4o' },
  gemini:    { single: 'gemini-1.5-pro' }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  REGISTRE DE MODELS â€” v5.1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MODEL_REGISTRY = {
  'claude-haiku-4-5-20251001': {
    nom: 'Claude Haiku 4.5', nomCurt: 'Haiku 4.5',
    proveidor: 'anthropic',
    input_per_m: 1.00, output_per_m: 5.00,
    context_max: 200000, max_output: 4096,
    qualitat: { draft: 72, prosa: 62, arquitectura: 65, extraccio: 78 },
    velocitat: 'molt_rapida',
    notes: 'RÃ pid i barat. Bo per tasques mecÃ niques. Prosa plana.'
  },
  'claude-sonnet-4-6': {
    nom: 'Claude Sonnet 4.6', nomCurt: 'Sonnet 4.6',
    proveidor: 'anthropic',
    input_per_m: 3.00, output_per_m: 15.00,
    context_max: 1000000, max_output: 8192,
    qualitat: { draft: 82, prosa: 84, arquitectura: 86, extraccio: 88 },
    velocitat: 'rapida',
    notes: 'Millor rÃ tio qualitat/preu. Quasi Opus a 1/5 del preu. Prosa molt bona.'
  },
  'claude-opus-4-6': {
    nom: 'Claude Opus 4.6', nomCurt: 'Opus 4.6',
    proveidor: 'anthropic',
    input_per_m: 5.00, output_per_m: 25.00,
    context_max: 1000000, max_output: 8192,
    qualitat: { draft: 85, prosa: 88, arquitectura: 93, extraccio: 90 },
    velocitat: 'moderada',
    notes: 'MÃ xima intelÂ·ligÃ¨ncia. Millor per judicis literaris subtils i arquitectura complexa.'
  },
  'gemini-3-pro-preview': {
    nom: 'Gemini 3 Pro Preview', nomCurt: 'Gemini 3 Pro',
    proveidor: 'google',
    input_per_m: 2.00, output_per_m: 12.00,
    context_max: 1000000, max_output: 8192,
    qualitat: { draft: 78, prosa: 75, arquitectura: 80, extraccio: 82 },
    velocitat: 'rapida',
    notes: 'Bon raonament, context llarg. Prosa en catalÃ  menys natural que Claude.'
  },
  'gemini-3-flash-preview': {
    nom: 'Gemini 3 Flash Preview', nomCurt: 'Gemini 3 Flash',
    proveidor: 'google',
    input_per_m: 0.10, output_per_m: 0.40,
    context_max: 1000000, max_output: 8192,
    qualitat: { draft: 80, prosa: 75, arquitectura: 75, extraccio: 85 },
    velocitat: 'molt_rapida',
    notes: 'Model de nova generaciÃ³ extremadament barat i rÃ pid.'
  },
  'gpt-5.2': {
    nom: 'GPT-5.2', nomCurt: 'GPT-5.2',
    proveidor: 'openai',
    input_per_m: 1.75, output_per_m: 14.00,
    context_max: 400000, max_output: 4096,
    qualitat: { draft: 80, prosa: 78, arquitectura: 82, extraccio: 85 },
    velocitat: 'rapida',
    notes: 'Fort en raonament i codi. CatalÃ  acceptable perÃ² no natiu. Preu competitiu.'
  }
};

const ROLS_MODEL = {
  draft: {
    nom: 'Draft / ExtracciÃ³',
    descripcio: 'Esquelets narratius (Pas 1 dual-pass), extracciÃ³ fets NKG, correccions rÃ pides',
    clau_qualitat: 'draft',
    tokens_estimats: { input: 156000, output: 102000 }
  },
  generacio: {
    nom: 'GeneraciÃ³ LiterÃ ria',
    descripcio: 'ExpansiÃ³ literÃ ria (Pas 2 dual-pass), reescriptura de passatges, conte original',
    clau_qualitat: 'prosa',
    tokens_estimats: { input: 130000, output: 95000 }
  },
  arquitecte: {
    nom: 'Arquitecte / Revisor',
    descripcio: 'Estructura, escaleta, resum compacte, micro-reescriptura diagnÃ²stic, revisiÃ³ global, veu semilla',
    clau_qualitat: 'arquitectura',
    tokens_estimats: { input: 95000, output: 38000 }
  }
};

// Model hÃ­brid v5.1: llegeix de ESTAT._model* (selector flexible per rol)
function getModelConfig(userConfig) {
  // Prioritat: ESTAT._model* > userConfig.models.* > userConfig.model* > defaults
  const cfg = userConfig || {};
  const cfgModels = cfg.models || {};
  return {
    modelDraft:      ESTAT._modelDraft      || cfgModels.draft      || cfg.modelDraft      || cfg.modelHaiku      || 'claude-haiku-4-5-20251001',
    modelGeneracio:  ESTAT._modelGeneracio  || cfgModels.generacio  || cfg.modelGeneracio  || cfg.model           || 'claude-sonnet-4-6',
    modelArquitecte: ESTAT._modelArquitecte || cfgModels.arquitecte || cfg.modelArquitecte || cfg.modelArquitectura || cfg.model || 'claude-sonnet-4-6'
  };
}

function setModelPerRol(rol, modelId) {
  if (!MODEL_REGISTRY[modelId]) { console.warn(`Model desconegut: ${modelId}`); return; }
  switch (rol) {
    case 'draft':      ESTAT._modelDraft      = modelId; break;
    case 'generacio':  ESTAT._modelGeneracio  = modelId; break;
    case 'arquitecte': ESTAT._modelArquitecte = modelId; break;
  }
  actualitzarEstimacio();
}

function aplicarPreset(preset) {
  const presets = {
    'economic':   { draft: 'claude-haiku-4-5-20251001', generacio: 'claude-sonnet-4-6', arquitecte: 'claude-sonnet-4-6' },
    'equilibrat': { draft: 'claude-sonnet-4-6',         generacio: 'claude-sonnet-4-6', arquitecte: 'claude-sonnet-4-6' },
    'premium':    { draft: 'claude-sonnet-4-6',         generacio: 'claude-sonnet-4-6', arquitecte: 'claude-opus-4-6'  },
    'maxim':      { draft: 'claude-sonnet-4-6',         generacio: 'claude-opus-4-6',   arquitecte: 'claude-opus-4-6'  },
    'barat_gpt':  { draft: 'gpt-5.2',                  generacio: 'gpt-5.2',           arquitecte: 'gpt-5.2'          },
    'gemini':     { draft: 'gemini-3-flash-preview',    generacio: 'gemini-3-flash-preview', arquitecte: 'gemini-3-pro-preview' }
  };
  const p = presets[preset];
  if (!p) return;
  ESTAT._modelDraft      = p.draft;
  ESTAT._modelGeneracio  = p.generacio;
  ESTAT._modelArquitecte = p.arquitecte;
  const selDraft = document.getElementById('selectModelDraft');
  const selGen   = document.getElementById('selectModelGen');
  const selArq   = document.getElementById('selectModelArq');
  if (selDraft) selDraft.value = p.draft;
  if (selGen)   selGen.value   = p.generacio;
  if (selArq)   selArq.value   = p.arquitecte;
  actualitzarEstimacio();
}

// Alias backward compatible
function aplicarPresetModels(preset) { aplicarPreset(preset); }

function actualitzarConfigProvider() {
  const provider = document.getElementById('config-provider').value;

  // Ara mostrem els camps de sistema dual per a TOTS els proveÃ¯dors
  document.getElementById('config-anthropic-fields').classList.remove('hidden');
  document.getElementById('config-single-model-field').classList.add('hidden');

  const genInput = document.getElementById('config-model-generacio');
  const arqInput = document.getElementById('config-model-arquitectura');
  const provGenSel = document.getElementById('config-provider-generacio');
  const provArqSel = document.getElementById('config-provider-arquitectura');

  if (provGenSel) provGenSel.value = provider;
  if (provArqSel) provArqSel.value = provider;

  // Actualitzem els valors per defecte recomanats segons el proveÃ¯dor
  if (provider === 'anthropic') {
    genInput.value = 'claude-sonnet-4-6';
    arqInput.value = 'claude-opus-4-6';
  } else if (provider === 'gemini') {
    genInput.value = 'gemini-3-flash-preview';
    arqInput.value = 'gemini-3-flash-preview';
  } else if (provider === 'openai') {
    genInput.value = 'gpt-4o-mini';
    arqInput.value = 'gpt-4o';
  }
}

// MantÃ© compatibilitat si algÃº cridava l'antiga funciÃ³
function actualitzarModelDefault() { actualitzarConfigProvider(); }

function guardarIComencar() {
  try {
    const provider = document.getElementById('config-provider').value;
    if (!provider) { toast('Selecciona un proveÃ¯dor.'); return; }

    const providerGeneracio = (document.getElementById('config-provider-generacio')?.value || provider).trim();
    const providerArquitectura = (document.getElementById('config-provider-arquitectura')?.value || provider).trim();

    const anthropicKey = document.getElementById('anthropicApiKey')?.value?.trim() || '';
    const geminiKey    = document.getElementById('geminiApiKey')?.value?.trim() || '';
    const openaiKey    = document.getElementById('openaiApiKey')?.value?.trim() || '';

    const getKeyForProvider = (prov) => {
      if (prov === 'anthropic') return anthropicKey;
      if (prov === 'gemini' || prov === 'google') return geminiKey;
      if (prov === 'openai') return openaiKey;
      return '';
    };

    const providersNecessaris = Array.from(new Set([providerGeneracio, providerArquitectura]));
    const senseKey = providersNecessaris.find(p => !getKeyForProvider(p));
    if (senseKey) { toast(`Introdueix una API key per al proveÃ¯dor seleccionat (${senseKey}).`); return; }

    const apiKey = getKeyForProvider(providerGeneracio);

    if (anthropicKey) ESTAT._anthropicApiKey = anthropicKey;
    if (geminiKey)    ESTAT._geminiApiKey    = geminiKey;
    if (openaiKey)    ESTAT._openaiApiKey    = openaiKey;

    const modelGeneracio    = document.getElementById('config-model-generacio').value.trim();
    const modelArquitectura = document.getElementById('config-model-arquitectura').value.trim();
    const fluxAutomatic     = document.getElementById('config-flux-automatic').checked;

    if (!modelGeneracio)    { toast('Introdueix el model de generaciÃ³.'); return; }
    if (!modelArquitectura) { toast("Introdueix el model d'arquitectura."); return; }

    // AQUESTA Ã‰S LA CLAU: Sobreescriure l'ESTAT intern perquÃ¨ oblidi Claude
    ESTAT._modelGeneracio  = modelGeneracio;
    ESTAT._modelArquitecte = modelArquitectura;
    ESTAT._modelDraft      = modelGeneracio;

    const genere = document.getElementById('config-genere') ? document.getElementById('config-genere').value : '';
    const autor = document.getElementById('config-autor') ? document.getElementById('config-autor').value : '';
    const focusClimax = document.getElementById('config-focus-climax') ? document.getElementById('config-focus-climax').value : '';
    ESTAT.configProjecte = { genere, autor_referencia: autor, focus_climax: focusClimax };

    USER_CONFIG = {
      provider,
      providerGeneracio,
      providerArquitectura,
      apiKey,
      modelGeneracio,
      modelArquitectura,
      modelDraft: modelGeneracio,
      modelArquitecte: modelArquitectura,
      fluxAutomatic
    };

    if (typeof poblarSelectorsModels === 'function') {
      poblarSelectorsModels();
    } else {
      console.warn("poblarSelectorsModels no definit; s'omet la inicialitzaciÃ³ del panell de models.");
    }

    if (typeof actualitzarModelsDisponibles === 'function') {
      actualitzarModelsDisponibles();
    }

    hideCard('card-config');
    document.getElementById('progress-wrap').classList.remove('hidden');
    showCard('fase-0');
    toast('ConfiguraciÃ³ guardada.');
  } catch (err) {
    console.error('Error guardant configuraciÃ³:', err);
    toast("No s'ha pogut guardar la configuraciÃ³. Mira la consola (F12).");
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 0 â†’ FASE 1: Premisses
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase1() {
  const sel = document.getElementById('sel-tematica').value;
  if (!sel) { toast('Selecciona primer un gÃ¨nere.'); return; }
  if (!USER_CONFIG) { toast('Primer configura el model.'); return; }

  ESTAT.tematica = sel;
  ESTAT.history  = [];
  ESTAT.fase     = 1;
  updateProgress(1);
  showCard('fase-1');
  showLoader(1);

  try {
    const res = await fase1_premisses(sel, [], USER_CONFIG);
    ESTAT.history = res.history;
    hideLoader(1);
    renderPremisses(res.response);
  } catch (err) {
    hideLoader(1);
    toast('Error: ' + err.message);
  }
}

// â”€â”€â”€ Render genÃ¨ric amb badge "Recomanat" (radio / single-select) â”€â”€â”€
function renderLlistaAmbRecomanat(text, wrapId, listaKey, idxKey, btnId) {
  const wrap  = document.getElementById(wrapId);
  const lines = text.split('\n').filter(l => /^\d+\./.test(l.trim()));
  if (lines.length === 0) {
    wrap.innerHTML = `<pre style="white-space:pre-wrap;font-size:.9rem;">${escHtml(text)}</pre>`;
    ESTAT[listaKey] = [];
    return;
  }
  const list = lines.map(l => l.replace(/^\d+\.\s*/, '').trim());
  // Guardar sense "(Recomanat)" per usar als prompts
  ESTAT[listaKey] = list.map(item => item.replace(/\s*\(Recomanat\)\s*/i, '').trim());
  ESTAT[idxKey]   = null;

  let autoIdx = null;
  wrap.innerHTML = list.map((item, i) => {
    const esRecomanat = /\(Recomanat\)/i.test(item);
    const textNet     = item.replace(/\s*\(Recomanat\)\s*/i, '').trim();
    if (esRecomanat) autoIdx = i;
    const badge = esRecomanat ? `<span class="badge-recomanat">Recomanat</span>` : '';
    return `<div class="premise-item" id="${wrapId}-item-${i}" onclick="triarItem('${wrapId}','${idxKey}',${i},this)">
      <input type="radio" name="${wrapId}-radio" id="${wrapId}-r-${i}">
      <label for="${wrapId}-r-${i}">${badge}${escHtml(textNet)}</label>
    </div>`;
  }).join('');

  // Auto-seleccionar el recomanat
  if (autoIdx !== null) {
    const el = document.getElementById(`${wrapId}-item-${autoIdx}`);
    if (el) {
      el.classList.add('chosen');
      el.querySelector('input').checked = true;
      ESTAT[idxKey] = autoIdx;
    }
  }
  showBtn(btnId);
}

function triarItem(wrapId, idxKey, idx, el) {
  document.querySelectorAll(`#${wrapId} .premise-item`).forEach(e => e.classList.remove('chosen'));
  el.classList.add('chosen');
  el.querySelector('input').checked = true;
  ESTAT[idxKey] = idx;
}

function renderPremisses(text) {
  renderLlistaAmbRecomanat(text, 'llista-premisses', '_premissaLista', '_premissaIdx', 'btn-fase1');
}

function triarPremissa(idx, el) { triarItem('llista-premisses', '_premissaIdx', idx, el); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 1 â†’ FASE 2: Estil (sense API)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function iniciarFase2() {
  const idx = ESTAT._premissaIdx;
  if (idx === undefined || idx === null) { toast('Tria una premissa primer.'); return; }
  ESTAT.premissaTriada = ESTAT._premissaLista[idx];
  ESTAT.fase = 2;
  updateProgress(2);
  showCard('fase-2');
}

// Pills de selecciÃ³ (estil)
function triarPill(el) {
  const group = el.dataset.group;
  document.querySelectorAll(`.opt-pill[data-group="${group}"]`).forEach(p => p.classList.remove('chosen'));
  el.classList.add('chosen');
  const val = el.dataset.val;
  if (group === 'perspectiva') ESTAT.estil.perspectiva = val;
  if (group === 'paraules')    ESTAT.estil.paraules    = parseInt(val);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 2 â†’ FASE 3: Protagonista
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase3() {
  const to          = document.getElementById('sel-to').value;
  const perspectiva = ESTAT.estil.perspectiva;
  const paraules    = ESTAT.estil.paraules;

  if (!to)          { toast('Tria el to del conte.'); return; }
  if (!perspectiva) { toast('Tria la perspectiva narrativa.'); return; }
  if (!paraules)    { toast('Tria la longitud del conte.'); return; }

  ESTAT.estil.to  = to;
  ESTAT.estil.desc = `to "${to}", ${perspectiva}, ${paraules} paraules aproximades`;

  ESTAT.fase = 3;
  updateProgress(3);
  showCard('fase-3');
  showLoader(3);

  try {
    const res = await fase3_personatges(ESTAT.premissaTriada, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    hideLoader(3);
    renderProtagonistes(res.response);
  } catch (err) {
    hideLoader(3);
    toast('Error: ' + err.message);
  }
}

function renderProtagonistes(text) {
  renderLlistaAmbRecomanat(text, 'llista-personatges', '_llistaProtagonistes', '_idxProtagonista', 'btn-fase3');
}

function triarProtagonista(idx, el) { triarItem('llista-personatges', '_idxProtagonista', idx, el); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 3 â†’ FASE 4: Localitzacions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase4() {
  const idx = ESTAT._idxProtagonista;
  if (idx === null || idx === undefined || !ESTAT._llistaProtagonistes[idx]) {
    toast('Tria un protagonista primer.');
    return;
  }
  ESTAT.protagonistaTriat = ESTAT._llistaProtagonistes[idx];
  ESTAT.fase = 4;
  updateProgress(4);
  showCard('fase-4');
  showLoader(4);

  try {
    const res = await fase_localitzacions(ESTAT.protagonistaTriat, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    hideLoader(4);
    renderLlistaAmbRecomanat(res.response, 'llista-localitzacions', '_llistaLocalitzacions', '_idxLocalitzacio', 'btn-fase4');
  } catch (err) {
    hideLoader(4);
    toast('Error: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 4 â†’ FASE 5: Finals
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase5() {
  const idx = ESTAT._idxLocalitzacio;
  if (idx === null || idx === undefined || !ESTAT._llistaLocalitzacions[idx]) {
    toast('Tria una localitzaciÃ³ primer.');
    return;
  }
  ESTAT.localitzacioTriada = ESTAT._llistaLocalitzacions[idx];
  ESTAT.fase = 5;
  updateProgress(5);
  showCard('fase-5');
  showLoader(5);

  try {
    const res = await fase4_finals(ESTAT.localitzacioTriada, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    hideLoader(5);
    renderLlistaAmbRecomanat(res.response, 'llista-finals', '_llistaFinals', '_idxFinal', 'btn-fase5');
  } catch (err) {
    hideLoader(5);
    toast('Error: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 5 â†’ FASE 6: Escriptura per parts
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function iniciarEscriptura() {
  const idx = ESTAT._idxFinal;
  if (idx === null || idx === undefined || !ESTAT._llistaFinals[idx]) {
    toast('Tria un final primer.');
    return;
  }
  ESTAT.finalTriat = ESTAT._llistaFinals[idx];

  const p = ESTAT.estil.paraules;
  ESTAT._totalParts  = p <= 600 ? 1 : p <= 1800 ? 2 : 4;
  ESTAT._partActual  = 1;
  ESTAT._partsTexts  = [];
  ESTAT._historyBeforeEscriptura = [...ESTAT.history];

  ESTAT.fase = 6;
  updateProgress(6);
  showCard('fase-6');
  hideCard('conte-wrap');
  document.getElementById('export-link-wrap').classList.add('hidden');

  escriureSeguentPart();
}

async function escriureSeguentPart() {
  const part      = ESTAT._partActual;
  const total     = ESTAT._totalParts;
  const perPart   = Math.round(ESTAT.estil.paraules / total);
  const loaderTxt = total === 1
    ? 'Escrivint el conteâ€¦'
    : `Escrivint part ${part} de ${total}â€¦`;

  showLoader(6);
  document.getElementById('loader-6-text').textContent = loaderTxt;

  try {
    const res = await escriureContePart(part, total, perPart, ESTAT.finalTriat, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    ESTAT._partsTexts.push(res.response);
    hideLoader(6);

    if (ESTAT._partActual < ESTAT._totalParts) {
      ESTAT._partActual++;
      await escriureSeguentPart();
    } else {
      const conteComplet = ESTAT._partsTexts.join('\n\n');
      ESTAT.conteText    = conteComplet;
      mostrarConte(conteComplet);
    }
  } catch (err) {
    hideLoader(6);
    toast('Error a la part ' + part + ': ' + err.message);
  }
}

function mostrarConte(text) {
  const cos  = document.getElementById('conte-cos');
  const pars = text.split(/\n\n+/).filter(p => p.trim().length > 0);
  cos.innerHTML = pars.map(p => `<p>${escHtml(p.trim())}</p>`).join('');

  const wc = compteParaules(text);
  document.getElementById('conte-wordcount').textContent = `${wc.toLocaleString('ca')} paraules`;

  showCard('conte-wrap');
  setTimeout(() => {
    document.getElementById('fase-6').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ACCIONS SOBRE EL CONTE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function regenerarConte() {
  if (!confirm('Vols regenerar el conte? El text actual es perdrÃ .')) return;
  ESTAT.history     = [...ESTAT._historyBeforeEscriptura];
  ESTAT._partActual = 1;
  ESTAT._partsTexts = [];
  hideCard('conte-wrap');
  escriureSeguentPart();
}

async function handleMillorarConte() {
  const instruccio = document.getElementById('millora-input').value.trim();
  if (!instruccio) { toast('Escriu una instrucciÃ³ de millora.'); return; }
  if (!ESTAT.conteText) { toast('Primer genera el conte.'); return; }

  hideCard('conte-wrap');
  showLoader(6);
  document.getElementById('loader-6-text').textContent = 'Aplicant la milloraâ€¦';

  try {
    const res = await millorarConte(instruccio, ESTAT.conteText, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history   = res.history;
    ESTAT.conteText = res.response;
    hideLoader(6);
    document.getElementById('millora-input').value = '';
    mostrarConte(res.response);
    toast('Millora aplicada.');
  } catch (err) {
    hideLoader(6);
    showCard('conte-wrap');
    toast('Error: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPORT LOCAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function exportarDoc() {
  if (!ESTAT.conteText) { toast('No hi ha cap conte per exportar.'); return; }
  const titol = ESTAT.premissaTriada
    ? ESTAT.premissaTriada.substring(0, 55) + (ESTAT.premissaTriada.length > 55 ? 'â€¦' : '')
    : 'Conte IA';
  exportarADoc(titol, ESTAT.conteText);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 6 â†’ FASE 7: Worldbuilding
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase7() {
  if (!ESTAT.conteText) { toast('Primer genera el conte.'); return; }

  ESTAT.fase = 7;
  updateProgress(7);
  showCard('fase-7');
  document.getElementById('world-selector').classList.add('hidden');
  document.getElementById('world-result-wrap').classList.add('hidden');
  showLoader(7);
  document.getElementById('loader-7-text').textContent = 'Analitzant el conte per proposar elements de mÃ³nâ€¦';

  try {
    const res = await fase7_worldbuilding(ESTAT.conteText, ESTAT.tematica, ESTAT.estil.desc, ESTAT.history, USER_CONFIG);
    ESTAT.history = res.history;
    hideLoader(7);
    renderLlistaWorldbuilding(res.response);
  } catch (err) {
    hideLoader(7);
    toast('Error: ' + err.message);
  }
}

function renderLlistaWorldbuilding(text) {
  const wrap  = document.getElementById('llista-world');
  const lines = text.split('\n').filter(l => /^\d+\./.test(l.trim()));

  if (lines.length === 0) {
    wrap.innerHTML = `<pre style="white-space:pre-wrap;font-size:.9rem;">${escHtml(text)}</pre>`;
    document.getElementById('world-selector').classList.remove('hidden');
    return;
  }

  const list = lines.map(l => l.replace(/^\d+\.\s*/, '').trim());

  wrap.innerHTML = list.map((item, i) => {
    const esRecomanat = /\(Recomanat\)/i.test(item);
    const textNet     = item.replace(/\s*\(Recomanat\)\s*/i, '').trim();
    const displayHtml = escHtml(textNet).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    const badge       = esRecomanat ? `<span class="badge-recomanat">Recomanat</span>` : '';
    const checkedAttr = esRecomanat ? 'checked' : '';
    const chosenClass = esRecomanat ? 'chosen' : '';
    return `<div class="world-item ${chosenClass}" id="world-item-${i}" data-text="${escHtml(textNet)}" onclick="toggleWorldItem(${i}, this)">
      <input type="checkbox" id="world-cb-${i}" ${checkedAttr} onclick="event.stopPropagation();" onchange="syncWorldItem(${i})">
      <label for="world-cb-${i}">${badge}${displayHtml}</label>
    </div>`;
  }).join('');

  document.getElementById('world-selector').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-7').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function toggleWorldItem(idx, el) {
  const cb = document.getElementById('world-cb-' + idx);
  cb.checked = !cb.checked;
  el.classList.toggle('chosen', cb.checked);
}

function syncWorldItem(idx) {
  const cb = document.getElementById('world-cb-' + idx);
  const el = document.getElementById('world-item-' + idx);
  el.classList.toggle('chosen', cb.checked);
}

async function expandirElementsSeleccionats() {
  const checkboxes = document.querySelectorAll('#llista-world input[type=checkbox]:checked');
  if (checkboxes.length === 0) { toast('Selecciona almenys un element per expandir.'); return; }

  const labels = Array.from(checkboxes).map(cb => {
    const item = document.getElementById(cb.id.replace('world-cb-', 'world-item-'));
    return item ? item.dataset.text : '';
  }).filter(t => t.length > 0);

  document.getElementById('world-selector').classList.add('hidden');
  document.getElementById('world-result-wrap').classList.add('hidden');
  showLoader(7);
  document.getElementById('loader-7-text').textContent = 'Generant la bÃ­blia de mÃ³nâ€¦';

  try {
    const res = await fase7_expandirElements(labels, ESTAT.conteText, ESTAT.tematica, ESTAT.history, USER_CONFIG);
    ESTAT.history       = res.history;
    ESTAT.worldbuilding = res.response;
    hideLoader(7);
    mostrarResultatWorldbuilding(res.response);
  } catch (err) {
    hideLoader(7);
    document.getElementById('world-selector').classList.remove('hidden');
    toast('Error: ' + err.message);
  }
}

function mostrarResultatWorldbuilding(text) {
  const cos = document.getElementById('world-result-cos');

  const blocs = text.split(/\n\n+/).filter(b => b.trim().length > 0);
  cos.innerHTML = blocs.map(bloc => {
    const linies = bloc.trim().split('\n');
    const primerLinia = linies[0] || '';
    const esTitol = /^\*\*.+\*\*/.test(primerLinia.trim());
    if (esTitol) {
      const titol = escHtml(primerLinia.trim()).replace(/\*\*(.+?)\*\*/g, '$1');
      const desc  = linies.slice(1).join('\n').trim();
      return `<div class="world-bloc">
        <div class="world-bloc-titol">${titol}</div>
        <div class="world-bloc-desc">${escHtml(desc)}</div>
      </div>`;
    }
    return `<div class="world-bloc"><div class="world-bloc-desc">${escHtml(bloc.trim())}</div></div>`;
  }).join('');

  document.getElementById('world-result-wrap').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-7').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function tornarASeleccioWorld() {
  document.getElementById('world-result-wrap').classList.add('hidden');
  document.getElementById('world-selector').classList.remove('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 7 â†’ FASE 8: Elenc de personatges
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase8() {
  ESTAT.fase = 8;
  updateProgress(8);
  showCard('fase-8');
  document.getElementById('elenc-selector').classList.add('hidden');
  showLoader(8);
  document.getElementById('loader-8-text').textContent = 'Proposant el cast de personatgesâ€¦';

  // Passa el worldbuilding com a context addicional si existeix
  const worldContext = ESTAT.worldbuilding
    ? '\n\nBÃ­blia de mÃ³n disponible:\n' + ESTAT.worldbuilding
    : '';

  try {
    const res = await fase8_elencPersonatges(
      ESTAT.conteText, ESTAT.protagonistaTriat, ESTAT.tematica,
      ESTAT.estil.desc, worldContext, ESTAT.history, USER_CONFIG
    );
    ESTAT.history = res.history;
    hideLoader(8);
    renderElencPersonatges(res.response);
  } catch (err) {
    hideLoader(8);
    toast('Error: ' + err.message);
  }
}

function renderElencPersonatges(text) {
  const wrap  = document.getElementById('llista-elenc');
  const lines = text
    .split('\n')
    .map(l => l.trim())
    .filter(Boolean)
    .filter(l => /^\d+[.)]\s+/.test(l) || /^[-*â€¢]\s+/.test(l) || /\bRol\s*:/i.test(l));

  if (lines.length === 0) {
    wrap.innerHTML = `<pre style="white-space:pre-wrap;font-size:.9rem;">${escHtml(text)}</pre>`;
    ESTAT._elencPersonatges = [];
    document.getElementById('elenc-selector').classList.remove('hidden');
    return;
  }

  const list = lines
    .map(l => l
      .replace(/^\d+[.)]\s*/, '')
      .replace(/^[-*â€¢]\s*/, '')
      .trim())
    .filter(Boolean)
    .slice(0, 8);
  ESTAT._elencPersonatges = list.map(item => item.replace(/\s*\(Recomanat\)\s*/i, '').trim());

  wrap.innerHTML = list.map((item, i) => {
    const esRecomanat = /\(Recomanat\)/i.test(item);
    const textNet     = item.replace(/\s*\(Recomanat\)\s*/i, '').trim();
    const displayHtml = escHtml(textNet).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    const badge       = esRecomanat ? `<span class="badge-recomanat">Recomanat</span>` : '';
    const checkedAttr = esRecomanat ? 'checked' : '';
    const chosenClass = esRecomanat ? 'chosen' : '';
    return `<div class="world-item ${chosenClass}" id="elenc-item-${i}" data-text="${escHtml(textNet)}" onclick="toggleElencItem(${i}, this)">
      <input type="checkbox" id="elenc-cb-${i}" ${checkedAttr} onclick="event.stopPropagation();" onchange="syncElencItem(${i})">
      <label for="elenc-cb-${i}">${badge}${displayHtml}</label>
    </div>`;
  }).join('');

  document.getElementById('elenc-selector').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-8').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function toggleElencItem(idx, el) {
  const cb = document.getElementById('elenc-cb-' + idx);
  cb.checked = !cb.checked;
  el.classList.toggle('chosen', cb.checked);
}

function syncElencItem(idx) {
  const cb = document.getElementById('elenc-cb-' + idx);
  const el = document.getElementById('elenc-item-' + idx);
  el.classList.toggle('chosen', cb.checked);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 8 â†’ FASE 9: Estils de parla
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEstilsParla() {
  const checkboxes = document.querySelectorAll('#llista-elenc input[type=checkbox]:checked');
  if (checkboxes.length === 0) { toast('Selecciona almenys un personatge.'); return; }

  const seleccionats = Array.from(checkboxes).map(cb => {
    const item = document.getElementById(cb.id.replace('elenc-cb-', 'elenc-item-'));
    return item ? item.dataset.text : '';
  }).filter(t => t.length > 0);

  ESTAT._personatgesSeleccionats = seleccionats;
  ESTAT.fase = 9;
  updateProgress(9);
  showCard('fase-9');
  document.getElementById('estils-result').classList.add('hidden');
  showLoader(9);

  try {
    const res = await fase9_estilParla(
      ESTAT.protagonistaTriat, seleccionats, ESTAT.conteText,
      ESTAT.tematica, ESTAT.estil.desc, ESTAT.history, USER_CONFIG
    );
    ESTAT.history    = res.history;
    ESTAT.estilsParla = res.response;
    hideLoader(9);
    mostrarEstilsParla(res.response);
  } catch (err) {
    hideLoader(9);
    toast('Error: ' + err.message);
  }
}

function mostrarEstilsParla(text) {
  const cos = document.getElementById('estils-cos');

  // Partir el text en blocs per personatge (cada bloc comenÃ§a amb **Nom**)
  const lines  = text.split('\n');
  const cards  = [];
  let current  = [];

  for (const line of lines) {
    if (/^\*\*.+\*\*\s*$/.test(line.trim()) && current.length > 0) {
      cards.push(current);
      current = [line];
    } else {
      current.push(line);
    }
  }
  if (current.length > 0) cards.push(current);

  cos.innerHTML = cards.map(cardLines => {
    const nomLine = cardLines[0] || '';
    const nom     = escHtml(nomLine.trim().replace(/\*\*/g, ''));

    const campsHtml = cardLines.slice(1).map(line => {
      const l = line.trim();
      if (!l) return '';

      const match = l.match(/^([^:]+):\s*(.+)$/);
      if (match) {
        const label = escHtml(match[1].trim());
        const val   = escHtml(match[2].trim());
        if (/exemple/i.test(label)) {
          return `<div>
            <div class="veu-camp-label">${label}</div>
            <div class="veu-exemple">${val}</div>
          </div>`;
        }
        return `<div>
          <div class="veu-camp-label">${label}</div>
          <div class="veu-camp-val">${val}</div>
        </div>`;
      }
      return `<div class="veu-camp-val">${escHtml(l)}</div>`;
    }).filter(h => h).join('\n');

    return `<div class="veu-card">
      <div class="veu-card-nom">ğŸ‘¤ ${nom}</div>
      <div class="veu-card-camps">${campsHtml}</div>
    </div>`;
  }).join('\n');

  document.getElementById('estils-result').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-9').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function tornarAElenc() {
  document.getElementById('estils-result').classList.add('hidden');
  hideLoader(9);
  document.getElementById('fase-8').scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10: Estructura de la novelÂ·la (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase10() {
  ESTAT.fase = 10;
  updateProgress(10);
  showCard('fase-10');
  document.getElementById('estructura-wrap').classList.add('hidden');
  showLoader(10);
  document.getElementById('loader-10-text').textContent = 'ğŸ”µ Opus creant la bÃ­blia narrativaâ€¦';

  try {
    // Primer: crear la bÃ­blia narrativa inicial
    await inicialitzarBiblia(USER_CONFIG);

    // Validar que la bÃ­blia tÃ© fitxes per a tots els personatges
    const persEsperats = (ESTAT._personatgesSeleccionats || []).length;
    const persRebuts = (ESTAT.bibliaNarrativa.fitxes_personatges || []).length;
    if (persEsperats > 0 && persRebuts < persEsperats) {
      console.warn(`BÃ­blia incompleta: ${persRebuts}/${persEsperats} personatges. Completant...`);
      document.getElementById('loader-10-text').textContent = 'ğŸ”µ Completant fitxes de personatgesâ€¦';
      try {
        await completarBibliaPersonatges(USER_CONFIG);
      } catch (retryErr) {
        console.warn('Retry bÃ­blia personatges: ' + retryErr.message);
      }
    }

    // DesprÃ©s: generar l'estructura
    document.getElementById('loader-10-text').textContent = 'ğŸ”µ Opus dissenyant l\'estructuraâ€¦';
    const res = await generarEstructuraNovella(USER_CONFIG);
    ESTAT.estructuraNovella   = res.response;
    ESTAT._estructuraCapitols = parseEstructura(res.response);

    // Retry: si falten capÃ­tols, completar-los amb una segona crida
    const capsEsperats = ESTAT._nombreCapitols || 12;
    if (ESTAT._estructuraCapitols.length > 0 && ESTAT._estructuraCapitols.length < capsEsperats) {
      console.warn(`Estructura incompleta: ${ESTAT._estructuraCapitols.length}/${capsEsperats} capÃ­tols. Completant...`);
      document.getElementById('loader-10-text').textContent = `ğŸ”µ Completant capÃ­tols ${ESTAT._estructuraCapitols.length + 1}-${capsEsperats}â€¦`;
      try {
        const completRes = await completarEstructuraCapitols(ESTAT._estructuraCapitols, capsEsperats, USER_CONFIG);
        const completDades = parseJsonRobust(completRes.response);
        if (completDades && Array.isArray(completDades.capitols) && completDades.capitols.length > 0) {
          const nousCapitols = completDades.capitols.map(cap => ({
            numero:                 cap.numero,
            titol:                  cap.titol,
            text:                   JSON.stringify(cap),
            personatges:            cap.personatges || [],
            fil:                    cap.fil_principal || '',
            toRitme:                cap.to_ritme || '',
            prefiguracionsPlantar:  cap.prefiguracions_a_plantar || [],
            prefiguracionsRecollir: cap.prefiguracions_a_recollir || [],
            resum:                  cap.resum || '',
            connexioAnterior:       cap.connexio_anterior || '',
            connexioSeguent:        cap.connexio_seguent || ''
          }));
          ESTAT._estructuraCapitols = ESTAT._estructuraCapitols.concat(nousCapitols);
          ESTAT._nombreCapitols = ESTAT._estructuraCapitols.length;
          console.log(`Estructura completada: ${ESTAT._estructuraCapitols.length} capÃ­tols`);
        }
      } catch (retryErr) {
        console.warn('Retry estructura: ' + retryErr.message);
      }
    }

    hideLoader(10);
    mostrarEstructura(res.response);
    // Mostrar estimaciÃ³ de cost a la consola i al toast
    try {
      const estimacio = mostrarEstimacioCost();
      console.log('ğŸ“Š ESTIMACIÃ“ DE COST:\n' + estimacio);
      const costEl = document.getElementById('estimacio-cost');
      if (costEl) costEl.textContent = estimacio;
    } catch (e) { /* no bloquejant */ }
  } catch (err) {
    hideLoader(10);
    toast('Error Opus: ' + err.message);
  }
}

// Fallback: parser antic basat en regex (per si la resposta no Ã©s JSON)
function parseEstructuraLegacy(text) {
  if (!text) return [];
  const chapters = [];
  const capPattern = /(?:\*\*|#{1,3}\s*)(?:[Cc]apÃ­tol|[Cc]apitol|[Cc]ap\.?)\s+(\d+)(?::\s*(.+?))?\*{0,2}\s*\n([\s\S]*?)(?=(?:\*\*|#{1,3}\s*)(?:[Cc]apÃ­tol|[Cc]apitol|[Cc]ap\.?)\s+\d+|$)/g;
  let match;
  while ((match = capPattern.exec(text)) !== null) {
    const numero = parseInt(match[1]);
    const titol  = (match[2] || 'CapÃ­tol ' + numero).trim().replace(/\*+$/, '');
    const cos    = (match[3] || '').trim();
    chapters.push({ numero, titol, text: `**CapÃ­tol ${numero}: ${titol}**\n${cos}` });
  }
  if (chapters.length === 0) {
    const parts = text.split(/(?=(?:[Cc]apÃ­tol|[Cc]apitol)\s+\d+)/);
    parts.forEach(part => {
      const m = part.match(/(?:[Cc]apÃ­tol|[Cc]apitol)\s+(\d+)(?::\s*(.+))?/);
      if (m) chapters.push({ numero: parseInt(m[1]), titol: (m[2] || 'CapÃ­tol ' + m[1]).trim(), text: part.trim() });
    });
  }
  chapters.sort((a, b) => a.numero - b.numero);
  return chapters;
}

function parseEstructura(text) {
  if (!text) return [];

  // Intent 1: JSON robust
  const data = parseJsonRobust(text);
  if (data && Array.isArray(data.capitols)) {
    // Desar dades globals a ESTAT
    ESTAT._arcGlobal      = data.arc_global || '';
    ESTAT._temesCentrals  = data.temes_centrals || [];
    ESTAT._prefiguracions = data.prefiguracions || [];
    ESTAT._corbaTensio    = data.corba_tensio || [];
    ESTAT._arcMoral       = data.arc_moral || null;

    // ValidaciÃ³ de lÃ­mits 12-22 capÃ­tols
    if (data.capitols.length > 22) {
      console.warn(`Estructura amb ${data.capitols.length} capÃ­tols â€” retallant a 22`);
      while (data.capitols.length > 22) {
        const ultim = data.capitols.pop();
        const penultim = data.capitols[data.capitols.length - 1];
        penultim.resum = (penultim.resum || '') + ' ' + (ultim.resum || '');
        penultim.personatges = [...new Set([...(penultim.personatges || []), ...(ultim.personatges || [])])];
        penultim.numero = data.capitols.length;
      }
    }
    if (data.capitols.length < 12) {
      console.warn(`Estructura amb ${data.capitols.length} capÃ­tols â€” massa pocs, perÃ² continuem`);
    }

    // Guardar el nombre real de capÃ­tols i la justificaciÃ³
    ESTAT._nombreCapitols = data.capitols.length;
    ESTAT._justificacioCapitols = data.justificacio_capitols || '';

    return data.capitols.map(cap => ({
      numero:                cap.numero,
      titol:                 cap.titol,
      text:                  JSON.stringify(cap),
      personatges:           cap.personatges || [],
      fil:                   cap.fil_principal || '',
      toRitme:               cap.to_ritme || '',
      prefiguracionsPlantar: cap.prefiguracions_a_plantar || [],
      prefiguracionsRecollir:cap.prefiguracions_a_recollir || [],
      resum:                 cap.resum || '',
      connexioAnterior:      cap.connexio_anterior || '',
      connexioSeguent:       cap.connexio_seguent || ''
    }));
  }

  // Fallback: parser basat en regex
  return parseEstructuraLegacy(text);
}

function mostrarEstructura(text) {
  const cos = document.getElementById('estructura-cos');

  // Si tenim dades JSON estructurades, renderitzem de forma rica
  if (ESTAT._arcGlobal || ESTAT._corbaTensio.length > 0) {
    let html = '';

    // Arc global
    if (ESTAT._arcGlobal) {
      html += `<div class="world-bloc">
        <div class="world-bloc-titol">ğŸŒ Arc Global</div>
        <div class="world-bloc-desc">${escHtml(ESTAT._arcGlobal)}</div>
      </div>`;
    }

    // Corba de tensiÃ³ visual
    if (ESTAT._corbaTensio.length > 0) {
      const barres = ['â–','â–‚','â–ƒ','â–„','â–…','â–†','â–‡','â–ˆ'];
      const visualCorba = ESTAT._corbaTensio.map(t => {
        const nivell = Math.min(10, Math.max(1, t.nivell || 1));
        const bar    = barres[Math.floor((nivell - 1) / 10 * barres.length)] || 'â–„';
        return `<span title="Cap.${t.capitol}: ${t.tipus || ''} (${nivell}/10)">${bar}</span>`;
      }).join('');
      html += `<div class="world-bloc">
        <div class="world-bloc-titol">ğŸ“ˆ Corba de TensiÃ³</div>
        <div style="font-size:1.4rem;letter-spacing:2px;color:var(--accent2);margin:6px 0;">${visualCorba}</div>
        <div style="font-size:.75rem;color:var(--text2);">${ESTAT._corbaTensio.map(t => `C${t.capitol}:${t.nivell}`).join(' Â· ')}</div>
      </div>`;
    }

    // Prefiguracions
    if (ESTAT._prefiguracions.length > 0) {
      html += `<div class="world-bloc">
        <div class="world-bloc-titol">ğŸŒ± Prefiguracions planificades</div>
        <div class="world-bloc-desc">
          ${ESTAT._prefiguracions.map(p =>
            `<div style="padding:4px 0;border-bottom:1px solid var(--border);font-size:.85rem;">
              <span style="color:var(--accent2);">Cap.${p.plantada_capitol}â†’${p.resolucio_capitol}:</span> ${escHtml(p.element || '')}
            </div>`
          ).join('')}
        </div>
      </div>`;
    }

    // CapÃ­tols
    if (ESTAT._estructuraCapitols.length > 0) {
      html += `<div class="world-bloc"><div class="world-bloc-titol">ğŸ“š CapÃ­tols</div></div>`;
      html += ESTAT._estructuraCapitols.map(cap => {
        let detall = '';
        if (cap.resum)    detall += `<div style="margin-bottom:4px;">${escHtml(cap.resum)}</div>`;
        if (cap.fil)      detall += `<div style="font-size:.8rem;color:var(--text2);">Fil: ${escHtml(cap.fil)}</div>`;
        if (cap.toRitme)  detall += `<div style="font-size:.8rem;color:var(--text2);">To: ${escHtml(cap.toRitme)}</div>`;
        if (cap.personatges && cap.personatges.length > 0)
          detall += `<div style="font-size:.8rem;color:var(--text2);">Personatges: ${escHtml(cap.personatges.join(', '))}</div>`;
        return `<div class="world-bloc" style="border-left:3px solid var(--accent);padding-left:12px;">
          <div class="world-bloc-titol">CapÃ­tol ${cap.numero}: ${escHtml(cap.titol || '')}</div>
          <div class="world-bloc-desc">${detall}</div>
        </div>`;
      }).join('');
    }

    cos.innerHTML = html;
  } else {
    // RenderitzaciÃ³ text pla (legacy)
    const blocs = text.split(/\n\n+/).filter(b => b.trim().length > 0);
    cos.innerHTML = blocs.map(bloc => {
      const linies  = bloc.trim().split('\n');
      const primera = linies[0] || '';
      const esTitol = /^\*\*.+\*\*|^#{1,3}\s/.test(primera.trim());
      if (esTitol) {
        const titol = escHtml(primera.trim()).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/^#+\s/, '');
        const desc  = linies.slice(1).join('\n').trim();
        return `<div class="world-bloc">
          <div class="world-bloc-titol">${titol}</div>
          <div class="world-bloc-desc">${escHtml(desc)}</div>
        </div>`;
      }
      return `<div class="world-bloc"><div class="world-bloc-desc">${escHtml(bloc.trim())}</div></div>`;
    }).join('');
  }

  document.getElementById('estructura-wrap').classList.remove('hidden');
  const total = ESTAT._estructuraCapitols.length;
  if (total > 0) {
    const btn = document.getElementById('estructura-wrap').querySelector('.btn-primary');
    if (btn) btn.textContent = `ğŸ“– Escriure ${total} capÃ­tols`;
  }
  // Inicialitzar NKG amb les dades de l'estructura
  nkgInicialitzar();
  setTimeout(() => document.getElementById('fase-10').scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10.5: Escaleta per Escenes (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFaseEscaleta() {
  showCard('fase-10-5');
  showLoader('10-5');
  document.getElementById('loader-10-5-text').textContent = 'Opus generant escaleta per escenesâ€¦';
  try {
    const caps = ESTAT._estructuraCapitols;
    const BLOC = 4; // ReduÃ¯t de 5 a 4 per donar mÃ©s marge
    let totsResultats = [];
    for (let offset = 0; offset < caps.length; offset += BLOC) {
      const bloc = caps.slice(offset, offset + BLOC);
      document.getElementById('loader-10-5-text').textContent =
        `Generant escaleta: capÃ­tols ${offset + 1}-${Math.min(offset + BLOC, caps.length)} de ${caps.length}â€¦`;

      const res = await generarEscaletaBloc(bloc, offset, USER_CONFIG);
      const parsed = parseJsonRobust(res.response);

      if (parsed && parsed.escaletes) {
        totsResultats = totsResultats.concat(parsed.escaletes);

        // Retry: si falten escaletes d'aquest bloc
        const esperats = bloc.length;
        const rebuts = parsed.escaletes.length;
        if (rebuts < esperats) {
          console.warn(`Escaleta bloc incomplet: ${rebuts}/${esperats}. Completant capÃ­tols que falten...`);
          const capsFaltants = bloc.slice(rebuts);
          try {
            const retryRes = await generarEscaletaBloc(capsFaltants, offset + rebuts, USER_CONFIG);
            const retryParsed = parseJsonRobust(retryRes.response);
            if (retryParsed && retryParsed.escaletes) {
              totsResultats = totsResultats.concat(retryParsed.escaletes);
            }
          } catch (retryErr) {
            console.warn('Retry escaleta: ' + retryErr.message);
          }
        }
      } else {
        console.warn(`Escaleta: bloc ${offset + 1}-${offset + bloc.length} no parsejat. Retry sencer...`);
        try {
          const retryRes = await generarEscaletaBloc(bloc, offset, USER_CONFIG);
          const retryParsed = parseJsonRobust(retryRes.response);
          if (retryParsed && retryParsed.escaletes) {
            totsResultats = totsResultats.concat(retryParsed.escaletes);
          }
        } catch (retryErr) {
          console.warn('Retry escaleta sencer: ' + retryErr.message);
        }
      }
    }
    ESTAT._escaletes = totsResultats;
    hideLoader('10-5');
    mostrarEscaleta(totsResultats);
    document.getElementById('btn-fase11').classList.remove('hidden');

    if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
      document.getElementById('btn-fase11').classList.add('hidden');
      showLoader('10-5');
      document.getElementById('loader-10-5-text').textContent = 'ğŸ”µ Escaleta completada. Iniciant escriptura autÃ²noma en 3 segons...';
      setTimeout(() => {
        hideLoader('10-5');
        iniciarFase11();
      }, 3000);
    }
  } catch (e) {
    hideLoader('10-5');
    toast('Error generant escaleta: ' + e.message);
  }
}

function mostrarEscaleta(escaletes) {
  const div = document.getElementById('escaleta-result');
  if (!escaletes || escaletes.length === 0) { div.innerHTML = '<p>No s\'ha pogut generar l\'escaleta.</p>'; return; }
  let html = '<div style="max-height:400px;overflow-y:auto;">';
  escaletes.forEach(e => {
    html += `<details style="margin-bottom:8px;"><summary><strong>CapÃ­tol ${e.capitol}</strong>: ${escHtml(e.titol || '')}</summary><ol>`;
    (e.escenes || []).forEach(sc => {
      html += `<li><strong>${escHtml(sc.nom || '')}</strong> (${sc.paraules_objectiu || '?'} par.)<br>${escHtml(sc.funcio_narrativa || '')}</li>`;
    });
    html += '</ol></details>';
  });
  html += '</div>';
  div.innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 11: Escriptura de capÃ­tols (Sonnet + Registre)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function iniciarFase11() {
  if (ESTAT._estructuraCapitols.length === 0) {
    toast('No hi ha capÃ­tols a l\'estructura. Torna a generar-la.');
    return;
  }
  ESTAT.fase                = 11;
  ESTAT._capitolActual      = 0;
  ESTAT._capitols_generats  = [];
  ESTAT._revisioInstruccions= {};
  ESTAT.llibreRegistre      = { capitols: [], estat_personatges: [], fils_oberts: [], fils_tancats: [] };

  updateProgress(11);
  showCard('fase-11');
  renderLlistaCapitols();
  generarCapitol(0);
}

function renderLlistaCapitols() {
  const wrap  = document.getElementById('capitol-llista');
  const total = ESTAT._estructuraCapitols.length;
  document.getElementById('capitol-progress-text').textContent = `${total} capÃ­tols planificats`;

  wrap.innerHTML = ESTAT._estructuraCapitols.map((cap, i) => {
    const completat = i < ESTAT._capitolActual;
    const actiu     = i === ESTAT._capitolActual;
    const cls  = completat ? 'fet' : actiu ? 'actiu' : '';
    const ico  = completat ? 'âœ“'  : actiu  ? 'âœï¸'   : 'â—‹';
    const teText = !!(ESTAT._capitols_generats && ESTAT._capitols_generats[i]);
    const btnCopia = teText ? `<button class="capitol-copy" onclick="copiarCapitol(${i})" title="Copiar capÃ­tol">â˜</button>` : '';
    return `<div class="capitol-item ${cls}" id="cap-item-${i}">
      <span class="capitol-num">${ico}</span>
      <span class="capitol-titol">${escHtml(cap.titol || 'CapÃ­tol ' + (i + 1))}</span>
      ${btnCopia}
    </div>`;
  }).join('');
}

function copiarCapitol(idx) {
  const text = ESTAT._capitols_generats && ESTAT._capitols_generats[idx];
  if (!text) return;
  if (navigator.clipboard) {
    navigator.clipboard.writeText(text).then(() => toast(`CapÃ­tol ${idx + 1} copiat.`)).catch(() => {});
  } else {
    const ta = document.createElement('textarea');
    ta.value = text; document.body.appendChild(ta); ta.select();
    document.execCommand('copy'); document.body.removeChild(ta);
    toast(`CapÃ­tol ${idx + 1} copiat.`);
  }
}

function actualitzarEstatCapitol(idx, estat) {
  const el = document.getElementById('cap-item-' + idx);
  if (!el) return;
  el.className = 'capitol-item ' + estat;
  el.querySelector('.capitol-num').textContent = estat === 'fet' ? 'âœ“' : estat === 'actiu' ? 'âœï¸' : 'â—‹';
}

async function generarCapitol(idx, intents = 0) {
  if (idx >= ESTAT._estructuraCapitols.length) {
    document.getElementById('btn-control-arcs-wrap').classList.remove('hidden');
    await executarLoopCoherenciaFinal(USER_CONFIG);
    iniciarRevisioGlobal();  // FASE 6: auto-trigger revisiÃ³ global
    return;
  }

  ESTAT._capitolActual = idx;
  renderLlistaCapitols();  // refresca tota la llista
  actualitzarEstatCapitol(idx, 'actiu');

  const cap   = ESTAT._estructuraCapitols[idx];
  const titol = cap.titol || 'CapÃ­tol ' + (idx + 1);

  document.getElementById('capitol-actual-wrap').classList.add('hidden');
  document.getElementById('revisio-panel').classList.add('hidden');
  document.getElementById('checkpoint-intermedi-panel').classList.add('hidden');
  document.getElementById('btn-control-arcs-wrap').classList.add('hidden');
  showLoader(11);
  document.getElementById('loader-11-text').textContent =
    `ğŸŸ£ Sonnet escrivint el CapÃ­tol ${idx + 1} â€” "${titol}"â€¦`;

  try {
    const res = await generarCapitolNKG(idx, USER_CONFIG);
    ESTAT._capitols_generats[idx] = res.response;
    hideLoader(11);
    mostrarCapitol(idx, res.response);

    // SISTEMA 1: actualitzar bÃ­blia i registre (en sÃ¨rie, amb tolerÃ ncia a errors)
    try {
      await actualitzarBiblia(res.response, idx, USER_CONFIG);
    } catch (err) {
      console.warn('BÃ­blia async:', err.message);
    }

    try {
      await actualitzarLlibreRegistreBackground(res.response, idx);
    } catch (err) {
      console.warn('Registre async:', err.message);
    }

    // SISTEMA 4: checkpoint cada 3 capÃ­tols
    const esCheckpoint = (idx + 1) % 3 === 0 && idx + 1 < ESTAT._estructuraCapitols.length;
    if (esCheckpoint) {
      await executarCheckpoint(idx, USER_CONFIG);
    }

    // CompressiÃ³ de memÃ²ria cada 5 capÃ­tols
    const esCompressio = (idx + 1) % 5 === 0 && idx + 1 < ESTAT._estructuraCapitols.length;
    if (esCompressio) {
      document.getElementById('loader-11-text').textContent = 'ğŸ”µ Opus comprimint memÃ²ria narrativaâ€¦';
      await comprimirMemoria(idx + 1, USER_CONFIG);
    }

    mostrarAccionsCapitol(idx, res.response);
  } catch (err) {
    if (USER_CONFIG && USER_CONFIG.fluxAutomatic && intents < 3) {
      document.getElementById('loader-11-text').textContent = `âš ï¸ Error detectat. Reintentant capÃ­tol en 5 segons (Intent ${intents + 1}/3)...`;
      setTimeout(() => generarCapitol(idx, intents + 1), 5000);
      return;
    }

    hideLoader(11);
    toast('Error Sonnet: ' + err.message);
  }
}

function mostrarCapitol(idx, text) {
  const cap   = ESTAT._estructuraCapitols[idx];
  const titol = cap ? cap.titol || 'CapÃ­tol ' + (idx + 1) : 'CapÃ­tol ' + (idx + 1);

  document.getElementById('capitol-actual-titol').textContent = `CapÃ­tol ${idx + 1}: ${titol}`;
  const cos  = document.getElementById('capitol-actual-cos');
  const pars = text.split(/\n\n+/).filter(p => p.trim().length > 0);
  cos.innerHTML = pars.map(p => `<p>${escHtml(p.trim())}</p>`).join('');

  const wc = compteParaules(text);
  document.getElementById('capitol-actual-wordcount').textContent = `${wc.toLocaleString('ca')} paraules`;
  document.getElementById('capitol-actual-wrap').classList.remove('hidden');

  setTimeout(() => document.getElementById('fase-11').scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
}

function mostrarAccionsCapitol(idx, text) {
  const accions = document.getElementById('capitol-accions');
  const isLast  = idx >= ESTAT._estructuraCapitols.length - 1;

  if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
    accions.innerHTML = `<span style="color:var(--text2);font-size:.85rem;">ğŸ”µ Opus revisant el capÃ­tolâ€¦</span>`;
    revisarCapitolAmbOpus(text, idx, isLast);
  } else {
    // Si Ã©s l'Ãºltim capÃ­tol, no mostrem "Control d'Arcs" â€” ho gestiona la revisiÃ³ global
    if (isLast) {
      accions.innerHTML = `
        <button class="btn btn-secondary" onclick="iniciarRevisioManual(${idx})">ğŸ” Revisar amb Opus</button>
      `;
      actualitzarEstatCapitol(idx, 'fet');
    } else {
      accions.innerHTML = `
        <button class="btn btn-secondary" onclick="iniciarRevisioManual(${idx})">ğŸ” Revisar amb Opus</button>
        <button class="btn btn-primary" onclick="generarCapitol(${idx + 1})">â¡ï¸ CapÃ­tol ${idx + 2}</button>
      `;
      actualitzarEstatCapitol(idx, 'fet');
    }
  }
}

function iniciarRevisioManual(idx) {
  const text = ESTAT._capitols_generats[idx];
  if (!text) return;
  const isLast = idx >= ESTAT._estructuraCapitols.length - 1;
  document.getElementById('capitol-accions').innerHTML =
    `<span style="color:var(--text2);font-size:.85rem;">ğŸ”µ Opus revisant el capÃ­tolâ€¦</span>`;
  revisarCapitolAmbOpus(text, idx, isLast);
}

async function revisarCapitolAmbOpus(textCapitol, idx, isLast) {
  try {
    const res    = await revisarCapitol(textCapitol, idx, USER_CONFIG);
    const revisat = parseJsonRobust(res.response);
    mostrarRevisioCapitol(revisat, idx, isLast);
  } catch (err) {
    mostrarAccionsCapitolSimple(idx, isLast);
    toast('RevisiÃ³ Opus: ' + err.message);
  }
}

function mostrarRevisioCapitol(revisat, idx, isLast) {
  const panel   = document.getElementById('revisio-panel');
  const accions = document.getElementById('capitol-accions');

  if (!revisat) { mostrarAccionsCapitolSimple(idx, isLast); return; }

  const puntuacio   = revisat.puntuacio !== undefined ? revisat.puntuacio : '?';
  const ok          = revisat.ok_per_continuar !== false;
  const problemes   = Array.isArray(revisat.problemes) ? revisat.problemes : [];
  const instruccions= revisat.instruccions_correccio || '';
  const color = typeof puntuacio === 'number'
    ? (puntuacio >= 8 ? 'var(--success)' : puntuacio >= 6 ? 'var(--warning)' : '#f87171')
    : 'var(--text2)';

  const comentariFinal = revisat.comentari_editor_final || revisat.valoracio_general || revisat.veredicte || '';

  panel.innerHTML = `
    <div style="display:flex;align-items:center;gap:16px;margin-bottom:12px;">
      <div style="font-size:1.8rem;font-weight:700;color:${color};">${puntuacio}<span style="font-size:1rem;color:var(--text2);">/10</span></div>
      <div>
        <div style="font-weight:600;color:var(--text);">RevisiÃ³ Opus</div>
        <div style="font-size:.78rem;color:var(--text2);">${ok ? 'âœ“ Adequat per continuar' : 'âš  Recomana correcciÃ³'}</div>
      </div>
    </div>
    ${problemes.length > 0 ? `<div style="font-size:.83rem;margin-bottom:10px;">
      <strong style="color:var(--text2);">Observacions:</strong>
      <ul style="margin:6px 0 0 16px;color:var(--text);line-height:1.7;">
        ${problemes.map(p => `<li>${escHtml(String(p))}</li>`).join('')}
      </ul></div>` : ''}
    ${instruccions && !ok ? `<div style="font-size:.8rem;color:var(--text2);margin-top:8px;padding:10px 14px;background:var(--surface);border-radius:6px;border-left:2px solid var(--warning);">
      <strong>Instruccions:</strong> ${escHtml(instruccions)}</div>` : ''}
    ${comentariFinal ? `<div style="font-size:.8rem;color:var(--text2);margin-top:8px;padding:10px 14px;background:var(--surface2);border-radius:6px;border-left:2px solid var(--accent);">
      <strong>Comentari final de l'editor:</strong> ${escHtml(comentariFinal)}</div>` : ''}`;

  // Hook Review
  const hook = revisat.hook_review;
  if (hook) {
    const cHook = (p) => p >= 7 ? 'var(--success)' : p >= 5 ? 'var(--warning)' : '#f87171';
    panel.innerHTML += `
      <div style="margin-top:14px;padding-top:14px;border-top:1px solid var(--border);">
        <div style="font-weight:600;font-size:.85rem;color:var(--accent2);margin-bottom:8px;">ğŸ“ Enganxament</div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:.8rem;">
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Obertura:</span> <strong style="color:${cHook(hook.obertura_puntuacio)};">${hook.obertura_puntuacio || '?'}/10</strong>
          </div>
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Cliffhanger:</span> <strong style="color:${cHook(hook.cliffhanger_puntuacio)};">${hook.cliffhanger_puntuacio || '?'}/10</strong>
          </div>
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Ritme:</span> <strong style="color:${cHook(hook.ritme_intern_puntuacio)};">${hook.ritme_intern_puntuacio || '?'}/10</strong>
          </div>
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Promesa:</span> <span style="font-size:.75rem;">${escHtml(hook.promesa_narrativa || 'N/A')}</span>
          </div>
        </div>
      </div>`;
  }

  panel.classList.remove('hidden');

  // Golden passage
  if (revisat.golden_passage && revisat.puntuacio >= 7) {
    if (!ESTAT._goldenPassage || revisat.puntuacio > 7) {
      ESTAT._goldenPassage = revisat.golden_passage;
      ESTAT._goldenPassageCapitol = idx;
    }
  }

  const nextLabel  = isLast ? '' : `â¡ï¸ CapÃ­tol ${idx + 2}`;
  const nextAction = isLast ? '' : `generarCapitol(${idx + 1})`;

  // ğŸ”´ CORRECCIÃ“: GestiÃ³ automatitzada real del flux
  if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
    if (!ok && instruccions) {
      accions.innerHTML = `<span style="color:var(--text2);font-size:.85rem;">ğŸ”´ Opus demana correccions. Sonnet reescrivint automÃ ticament...</span>`;
      setTimeout(() => reescriureCapitol(idx), 15000); // Dona 15s per recuperar quota abans de continuar
    } else {
      accions.innerHTML = `<span style="color:var(--success);font-size:.85rem;">âœ… CapÃ­tol aprovat. AvanÃ§ant automÃ ticament...</span>`;
      if (!isLast) {
        setTimeout(() => generarCapitol(idx + 1), 15000); // Dona 15s abans de saltar
      } else {
        generarCapitol(ESTAT._estructuraCapitols.length);
      }
    }
  } else {
    // Mode Manual
    if (!ok && instruccions) {
      accions.innerHTML = `
        <button class="btn btn-secondary" onclick="reescriureCapitol(${idx})">âœï¸ Reescriure (Sonnet)</button>
        ${isLast ? '' : `<button class="btn btn-primary" onclick="${nextAction}">${nextLabel}</button>`}`;
    } else {
      accions.innerHTML = isLast ? '' : `<button class="btn btn-primary" onclick="${nextAction}">${nextLabel}</button>`;
    }
    if (isLast) generarCapitol(ESTAT._estructuraCapitols.length);

    if (hook && hook.cliffhanger_puntuacio < 6 && revisat.instruccions_cliffhanger) {
      const btnCH = document.createElement('button');
      btnCH.className = 'btn btn-secondary';
      btnCH.textContent = 'ğŸ£ Millorar cliffhanger';
      btnCH.onclick = () => millorarCliffhanger(idx, revisat.instruccions_cliffhanger);
      accions.appendChild(btnCH);
    }
  }

  actualitzarEstatCapitol(idx, 'fet');
}

function mostrarCheckpointIntermedi(checkpoint, capitolActual, totalCapitols) {
  const panel = document.getElementById('checkpoint-intermedi-panel');
  if (!panel) return;

  const subtramesHtml = (checkpoint.estat_subtrames || []).map(st => {
    const color = st.estat === 'activa' ? 'var(--success)' : st.urgent ? '#f87171' : 'var(--warning)';
    return `<li style="color:${color};margin-bottom:4px;"><strong>${escHtml(st.nom)}</strong> (${escHtml(st.estat)}) â€” ${escHtml(st.nota || '')}</li>`;
  }).join('');

  const absentsHtml = (checkpoint.personatges_absents || []).length > 0
    ? `<p style="margin:8px 0 4px;font-size:.82rem;color:var(--text2);"><strong>Personatges a recuperar:</strong> ${escHtml((checkpoint.personatges_absents || []).join(', '))}</p>`
    : '';

  const prefUrgentsHtml = (checkpoint.prefiguracions_urgents || []).map(p =>
    `<li style="font-size:.82rem;color:var(--text2);">Cap.${p.capitol_resolucio}: <strong>${escHtml(p.element || '')}</strong> â€” ${escHtml(p.nota || '')}</li>`
  ).join('');

  const derivaHtml = checkpoint.deriva_detectada
    ? `<p style="margin:8px 0 4px;font-size:.82rem;color:#f87171;"><strong>Deriva detectada:</strong> ${escHtml(checkpoint.deriva_detectada)}</p>`
    : '';

  panel.innerHTML = `
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
      <span style="font-size:1.3rem;">ğŸŸ¡</span>
      <div>
        <div style="font-weight:700;color:#f59e0b;font-size:.95rem;">Checkpoint de coherÃ¨ncia â€” meitat de novelÂ·la</div>
        <div style="font-size:.78rem;color:var(--text2);">CapÃ­tol ${capitolActual} de ${totalCapitols} â€” els ajustos de rumb s'aplicaran als capÃ­tols restants</div>
      </div>
    </div>
    ${subtramesHtml ? `<ul style="margin:0 0 8px 16px;padding:0;">${subtramesHtml}</ul>` : ''}
    ${absentsHtml}
    ${prefUrgentsHtml ? `<p style="margin:8px 0 4px;font-size:.82rem;color:var(--text2);"><strong>Prefiguracions urgents:</strong></p><ul style="margin:0 0 8px 16px;padding:0;">${prefUrgentsHtml}</ul>` : ''}
    ${derivaHtml}
    ${checkpoint.ajustos_rumb ? `<div style="margin-top:10px;padding:10px 14px;background:var(--surface);border-radius:6px;border-left:2px solid #f59e0b;font-size:.81rem;color:var(--text2);"><strong>Ajustos de rumb injectats als capÃ­tols restants:</strong><br>${escHtml(checkpoint.ajustos_rumb)}</div>` : ''}`;

  panel.classList.remove('hidden');
  panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function mostrarAccionsCapitolSimple(idx, isLast) {
  if (isLast) {
    document.getElementById('capitol-accions').innerHTML = '';
    generarCapitol(ESTAT._estructuraCapitols.length);
  } else {
    // ğŸ”´ CORRECCIÃ“: Si Ã©s automÃ tic, no esperem el clic de l'usuari
    if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
      document.getElementById('capitol-accions').innerHTML = `<span style="color:var(--text2);font-size:.85rem;">AvanÃ§ant automÃ ticament al segÃ¼ent capÃ­tol...</span>`;
      setTimeout(() => generarCapitol(idx + 1), 15000);
    } else {
      document.getElementById('capitol-accions').innerHTML =
        `<button class="btn btn-primary" onclick="generarCapitol(${idx + 1})">â¡ï¸ CapÃ­tol ${idx + 2}</button>`;
    }
  }
  actualitzarEstatCapitol(idx, 'fet');
}

async function reescriureCapitol(idx, intents = 0) {
  const instruccions = ESTAT._revisioInstruccions[idx] || '';
  document.getElementById('capitol-actual-wrap').classList.add('hidden');
  document.getElementById('revisio-panel').classList.add('hidden');
  showLoader(11);
  document.getElementById('loader-11-text').textContent = 'ğŸŸ£ Sonnet aplicant les correccionsâ€¦';

  try {
    const res = await reescriureCapitolAmbInstruccions(idx, instruccions, USER_CONFIG);
    ESTAT._capitols_generats[idx] = res.response;
    hideLoader(11);
    mostrarCapitol(idx, res.response);
    const isLast = idx >= ESTAT._estructuraCapitols.length - 1;
    mostrarAccionsCapitolSimple(idx, isLast);
    toast('CapÃ­tol reescrit.');
  } catch (err) {
    if (USER_CONFIG && USER_CONFIG.fluxAutomatic && intents < 3) {
      document.getElementById('loader-11-text').textContent = `âš ï¸ Error detectat. Reintentant capÃ­tol en 5 segons (Intent ${intents + 1}/3)...`;
      setTimeout(() => reescriureCapitol(idx, intents + 1), 5000);
      return;
    }

    hideLoader(11);
    document.getElementById('capitol-actual-wrap').classList.remove('hidden');

    if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
      const isLast = idx >= ESTAT._estructuraCapitols.length - 1;
      mostrarAccionsCapitolSimple(idx, isLast);
      toast("Error Sonnet (reescriptura): s'han exhaurit els reintents. Continuant flux automÃ tic.");
      return;
    }

    toast('Error Sonnet: ' + err.message);
  }
}


function resumAutomaticCapitol(textCapitol) {
  const net = String(textCapitol || '').replace(/\s+/g, ' ').trim();
  if (!net) return '(sense resum)';
  const frases = net.match(/[^.!?â€¦]+[.!?â€¦]+/g) || [];
  if (frases.length >= 2) return (frases[0] + ' ' + frases[1]).trim().slice(0, 420);
  return net.slice(0, 420) + (net.length > 420 ? 'â€¦' : '');
}

function normalitzarEntradaRegistre(dades, textCapitol, idx) {
  const base = (dades && typeof dades === 'object') ? dades : {};
  const resum = String(base.resum_capitol || '').trim() || resumAutomaticCapitol(textCapitol);
  return {
    resum_capitol: resum,
    estat_personatges: Array.isArray(base.estat_personatges) ? base.estat_personatges : [],
    fils_oberts: Array.isArray(base.fils_oberts) ? base.fils_oberts : [],
    fils_tancats: Array.isArray(base.fils_tancats) ? base.fils_tancats : [],
    prefiguracions_detectades: Array.isArray(base.prefiguracions_detectades) ? base.prefiguracions_detectades : [],
    _fallback: !dades,
    _capitol_idx: idx
  };
}

// FASE 8: registre sÃ­ncron amb retry â€” s'awaita des de generarCapitol
async function actualitzarLlibreRegistreBackgroundLegacy(textCapitol, idx) {
  let intents = 0;
  while (intents < 2) {
    try {
      const res   = await actualitzarRegistre(textCapitol, idx, USER_CONFIG);
      const dadesRaw = parseJsonRobust(res.response);
      if (dadesRaw) {
        const dades = normalitzarEntradaRegistre(dadesRaw, textCapitol, idx);
        if (!ESTAT.llibreRegistre.capitols) ESTAT.llibreRegistre.capitols = [];
        ESTAT.llibreRegistre.capitols[idx] = dades;

        if (Array.isArray(dades.estat_personatges) && dades.estat_personatges.length > 0)
          ESTAT.llibreRegistre.estat_personatges = dades.estat_personatges;

        if (Array.isArray(dades.fils_tancats) && dades.fils_tancats.length > 0) {
          const tancats = new Set(dades.fils_tancats);
          ESTAT.llibreRegistre.fils_oberts  = (ESTAT.llibreRegistre.fils_oberts  || []).filter(f => !tancats.has(f));
          ESTAT.llibreRegistre.fils_tancats = [...new Set([...(ESTAT.llibreRegistre.fils_tancats || []), ...dades.fils_tancats])];
        }
        if (Array.isArray(dades.fils_oberts) && dades.fils_oberts.length > 0) {
          const existents = new Set(ESTAT.llibreRegistre.fils_oberts || []);
          dades.fils_oberts.forEach(f => existents.add(f));
          ESTAT.llibreRegistre.fils_oberts = [...existents];
        }
        return;  // Ã¨xit
      }
      intents++;
    } catch (err) {
      console.warn(`Registre intent ${intents + 1}:`, err.message);
      intents++;
    }
  }

  if (!ESTAT.llibreRegistre.capitols) ESTAT.llibreRegistre.capitols = [];
  ESTAT.llibreRegistre.capitols[idx] = normalitzarEntradaRegistre(null, textCapitol, idx);
  console.warn('Registre: fallback local aplicat (entrada mÃ­nima) per al capÃ­tol', idx + 1);
}

async function actualitzarLlibreRegistreBackground(textCapitol, idx) {
  return await actualitzarLlibreRegistreBackgroundLegacy(textCapitol, idx);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 12: Control d'Arcs (Opus) + EpÃ­leg (Sonnet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase12() {
  ESTAT.fase = 12;
  updateProgress(12);
  showCard('fase-12');
  document.getElementById('arcs-result').classList.add('hidden');
  document.getElementById('epileg-loader-wrap').classList.add('hidden');
  document.getElementById('epileg-cos').classList.add('hidden');
  showLoader(12);

  try {
    const res = await controlArcsNovella(USER_CONFIG);
    ESTAT._controlArcs = res.response;
    hideLoader(12);

    const arcosCos = document.getElementById('arcs-cos');
    const blocs = res.response.split(/\n\n+/).filter(b => b.trim().length > 0);
    arcosCos.innerHTML = `<div class="worldbuilding-result">` + blocs.map(bloc => {
      const linies  = bloc.trim().split('\n');
      const primera = linies[0] || '';
      const esTitol = /^\*\*.+\*\*|^#{1,3}\s/.test(primera.trim());
      if (esTitol) {
        const titol = escHtml(primera.trim()).replace(/\*\*(.+?)\*\*/g, '$1').replace(/^#+\s/, '');
        const desc  = linies.slice(1).join('\n').trim();
        return `<div class="world-bloc">
          <div class="world-bloc-titol">${titol}</div>
          <div class="world-bloc-desc">${escHtml(desc)}</div>
        </div>`;
      }
      return `<div class="world-bloc"><div class="world-bloc-desc">${escHtml(bloc.trim())}</div></div>`;
    }).join('') + `</div>`;

    // Si Opus menciona epÃ­leg, mostra el botÃ³
    if (/epÃ­leg|epilog/i.test(res.response)) {
      document.getElementById('btn-epileg').classList.remove('hidden');
    }
    document.getElementById('arcs-result').classList.remove('hidden');
    setTimeout(() => document.getElementById('fase-12').scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
  } catch (err) {
    hideLoader(12);
    toast('Error Opus: ' + err.message);
  }
}

async function escriureEpileg() {
  document.getElementById('btn-epileg').disabled = true;
  document.getElementById('epileg-loader-wrap').classList.remove('hidden');

  try {
    const res = await generarEpileg(ESTAT._controlArcs, USER_CONFIG);
    ESTAT.epileg = res.response;
    document.getElementById('epileg-loader-wrap').classList.add('hidden');

    const epilegText = document.getElementById('epileg-text');
    const pars = res.response.split(/\n\n+/).filter(p => p.trim().length > 0);
    epilegText.innerHTML = pars.map(p => `<p>${escHtml(p.trim())}</p>`).join('');
    document.getElementById('epileg-cos').classList.remove('hidden');
    toast('EpÃ­leg escrit per Sonnet.');
  } catch (err) {
    document.getElementById('epileg-loader-wrap').classList.add('hidden');
    document.getElementById('btn-epileg').disabled = false;
    toast('Error Sonnet: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MODAL: Llibre de Registre
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function obrirLlibreRegistre() {
  const cos = document.getElementById('registre-cos');
  const reg = ESTAT.llibreRegistre;
  const capsFets = (reg.capitols || []).filter(c => c);

  if (capsFets.length === 0) {
    cos.innerHTML = `<p style="color:var(--text2);font-size:.9rem;padding:20px 0;">El registre s'actualitzarÃ  automÃ ticament quan es generin capÃ­tols.</p>`;
  } else {
    const pers       = reg.estat_personatges || [];
    const filsOberts = reg.fils_oberts       || [];
    const filsTancat = reg.fils_tancats      || [];
    cos.innerHTML = `
      <div style="margin-bottom:22px;">
        <div class="world-bloc-titol" style="margin-bottom:10px;">Personatges actuals</div>
        ${pers.length === 0
          ? `<p style="color:var(--text2);font-size:.85rem;">Pendent de procesar.</p>`
          : pers.map(p => `<div style="padding:8px 14px;background:var(--surface2);border-radius:8px;margin-bottom:6px;font-size:.86rem;">
              <strong>${escHtml(p.nom || '')}</strong>
              <span style="color:var(--text2);"> â€” ${escHtml(p.ubicacio || '')} Â· ${escHtml(p.estat_actual || '')}</span>
            </div>`).join('')}
      </div>
      ${filsOberts.length > 0 ? `<div style="margin-bottom:18px;">
        <div class="world-bloc-titol" style="margin-bottom:8px;">Fils oberts</div>
        ${filsOberts.map(f => `<div style="padding:5px 12px;border-left:2px solid var(--warning);margin-bottom:5px;font-size:.84rem;">${escHtml(f)}</div>`).join('')}
      </div>` : ''}
      ${filsTancat.length > 0 ? `<div style="margin-bottom:18px;">
        <div class="world-bloc-titol" style="margin-bottom:8px;">Fils tancats</div>
        ${filsTancat.map(f => `<div style="padding:5px 12px;border-left:2px solid var(--success);margin-bottom:5px;font-size:.84rem;">${escHtml(f)}</div>`).join('')}
      </div>` : ''}
      <div>
        <div class="world-bloc-titol" style="margin-bottom:10px;">Resums per capÃ­tol</div>
        ${(reg.capitols || []).map((c, i) => c ? `
          <div style="padding:10px 14px;background:var(--surface2);border-radius:8px;margin-bottom:8px;">
            <div style="font-weight:600;font-size:.82rem;color:var(--accent2);margin-bottom:4px;">CapÃ­tol ${i + 1}</div>
            <div style="font-size:.84rem;color:var(--text);line-height:1.6;">${escHtml(c.resum_capitol || '(sense resum)')}</div>
          </div>` : '').join('')}
      </div>`;
  }
  document.getElementById('modal-registre').classList.remove('hidden');
}

function tancarModalRegistre() {
  document.getElementById('modal-registre').classList.add('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 6: RevisiÃ³ Global (Opus) â€” UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarRevisioGlobal() {
  const loaderEl  = document.getElementById('revisio-global-loader');
  const resultEl  = document.getElementById('revisio-global-result');
  const reescrEl  = document.getElementById('revisio-global-reescriptures');
  const btnControl= document.getElementById('btn-control-arcs');

  loaderEl.classList.remove('hidden');
  resultEl.classList.add('hidden');
  reescrEl.innerHTML = '';
  btnControl.classList.add('hidden');

  try {
    const res     = await revisioGlobalOpusAPI(USER_CONFIG);
    const dades   = parseJsonRobust(res.response);
    ESTAT._revisioGlobal = dades;
    loaderEl.classList.add('hidden');
    const repeticions = detectarRepeticions();
    if (repeticions) mostrarRepeticions(repeticions);
    mostrarResultatRevisioGlobal(dades);
  } catch (err) {
    loaderEl.classList.add('hidden');
    resultEl.innerHTML = `<div style="padding:12px;background:var(--surface2);border-radius:8px;color:var(--text2);font-size:.85rem;">RevisiÃ³ global no disponible: ${escHtml(err.message)}</div>`;
    resultEl.classList.remove('hidden');
    btnControl.classList.remove('hidden');
    toast('RevisiÃ³ global: ' + err.message);
  }
}

function mostrarResultatRevisioGlobal(dades) {
  const resultEl = document.getElementById('revisio-global-result');
  const reescrEl = document.getElementById('revisio-global-reescriptures');
  const btnControl= document.getElementById('btn-control-arcs');

  if (!dades) {
    btnControl.classList.remove('hidden');
    return;
  }

  const puntuacio = dades.puntuacio_global !== undefined ? dades.puntuacio_global : '?';
  const color = typeof puntuacio === 'number'
    ? (puntuacio >= 8 ? 'var(--success)' : puntuacio >= 6 ? 'var(--warning)' : '#f87171')
    : 'var(--text2)';

  const problemes = Array.isArray(dades.problemes) ? dades.problemes : [];
  const capitolsReescriure = Array.isArray(dades.capitols_a_reescriure) ? dades.capitols_a_reescriure : [];
  const prefsPendents = Array.isArray(dades.prefiguracions_pendents) ? dades.prefiguracions_pendents : [];

  const problemesHtml = problemes.length > 0
    ? `<div style="margin-top:10px;">
        <div style="font-size:.78rem;font-weight:700;text-transform:uppercase;letter-spacing:.06em;color:var(--text2);margin-bottom:6px;">Problemes detectats:</div>
        ${problemes.map(p => {
          const grav = p.gravetat === 'alta' ? '#f87171' : p.gravetat === 'mitja' ? 'var(--warning)' : 'var(--text2)';
          return `<div style="padding:7px 12px;border-left:2px solid ${grav};margin-bottom:5px;font-size:.83rem;">
            <strong style="color:var(--text);">Cap. ${p.capitol || '?'} [${escHtml(p.tipus || '')}]:</strong> ${escHtml(p.descripcio || '')}
          </div>`;
        }).join('')}
      </div>` : '';

  const prefsHtml = prefsPendents.length > 0
    ? `<div style="margin-top:10px;">
        <div style="font-size:.78rem;font-weight:700;text-transform:uppercase;letter-spacing:.06em;color:var(--text2);margin-bottom:6px;">Prefiguracions pendents:</div>
        ${prefsPendents.map(p => `<div style="padding:5px 12px;border-left:2px solid var(--warning);margin-bottom:4px;font-size:.82rem;">${escHtml(p)}</div>`).join('')}
      </div>` : '';

  resultEl.innerHTML = `
    <div style="background:var(--surface2);border:1px solid var(--border);border-radius:10px;padding:18px 22px;">
      <div style="display:flex;align-items:center;gap:16px;margin-bottom:12px;">
        <div style="font-size:1.8rem;font-weight:700;color:${color};">${puntuacio}<span style="font-size:1rem;color:var(--text2);">/10</span></div>
        <div>
          <div style="font-weight:600;color:var(--text);">RevisiÃ³ Global Opus</div>
          <div style="font-size:.78rem;color:var(--text2);">${dades.veu_consistent ? 'âœ“ Veu consistent' : 'âš  InconsistÃ¨ncies de veu detectades'}</div>
        </div>
      </div>
      ${dades.veredicte ? `<div style="font-size:.88rem;color:var(--text);line-height:1.65;padding:10px 14px;background:var(--surface);border-radius:6px;margin-bottom:8px;">${escHtml(dades.veredicte)}</div>` : ''}
      ${problemesHtml}
      ${prefsHtml}
    </div>`;
  resultEl.classList.remove('hidden');

  // Botons de reescriptura per als capÃ­tols problemÃ tics
  if (capitolsReescriure.length > 0 && dades.instruccions_reescriptura) {
    reescrEl.innerHTML = `
      <div style="width:100%;font-size:.82rem;color:var(--text2);margin-bottom:6px;">Opus suggereix reescriure els capÃ­tols:</div>
      ${capitolsReescriure.map(numCap => {
        const idx = numCap - 1;
        const instruccions = dades.instruccions_reescriptura[String(numCap)] || '';
        return `<button class="btn btn-secondary" onclick="reescriureCapitolGlobal(${idx}, ${escHtml(JSON.stringify(instruccions))})">
          âœï¸ Reescriure Cap. ${numCap}
        </button>`;
      }).join('')}`;
  }

  // --- INICI BOTÃ“ META-ENGINYERIA ---
  const divMeta = document.createElement('div');
  divMeta.style.marginTop = "20px";
  divMeta.innerHTML = `
    <button class="btn btn-ghost" style="width:100%; border:1px dashed var(--accent2); color:var(--accent2); font-weight:600;" onclick="generarPromptMetaCodi()">
      âš™ï¸ L'app falla? Genera un prompt d'Arquitectura per millorar el codi font
    </button>
    <div id="meta-codi-resultat" class="hidden" style="margin-top:14px;"></div>
  `;
  resultEl.appendChild(divMeta);
  // --- FI BOTÃ“ META-ENGINYERIA ---

  btnControl.classList.remove('hidden');
}

async function generarPromptMetaCodi() {
  const resultDiv = document.getElementById('meta-codi-resultat');
  resultDiv.classList.remove('hidden');
  resultDiv.innerHTML = `<div style="color:var(--text2);font-size:.9rem; display:flex; align-items:center; gap:8px;">
    <div class="spinner" style="width:16px; height:16px; border-width:2px;"></div>
    L'app estÃ  llegint la seva prÃ²pia lÃ²gica JS i dissenyant una millora d'arquitectura...
  </div>`;

  try {
    // 1. OPTIMITZACIÃ“: Extraiem nomÃ©s la lÃ²gica JavaScript (estalvi brutal de tokens)
    const codiJS = Array.from(document.scripts)
      .map(script => script.innerText)
      .filter(text => text.trim().length > 0)
      .join('\n\n// --- SEGÃœENT BLOC DE SCRIPT ---\n\n');

    // 2. RECUPEREM ELS PROBLEMES NARRATIUS DETECTATS
    const problemes = ESTAT._revisioGlobal ? ESTAT._revisioGlobal.problemes : [];
    const textProblemes = problemes.length > 0
      ? JSON.stringify(problemes, null, 2)
      : "IncoherÃ¨ncies generals de continuÃ¯tat i ritme detectades al text.";

    // 3. PROMPT PER A L'IA (Actuant com a Arquitecte de Sistemes)
    const promptEnginyer = `Ets un Arquitecte de Software de Sistemes IA (Agentic Workflows).

Aquesta Ã©s la lÃ²gica JavaScript de la meva aplicaciÃ³ (Booki):
<codi_app_js>
${codiJS}
</codi_app_js>

En executar aquesta app per escriure una novelÂ·la, l'editor intern ha detectat aquests errors recurrents:
<errors_narratius>
${textProblemes}
</errors_narratius>

LA TEVA TASCA:
Dissenya una MILLORA ARQUITECTÃ’NICA GENÃˆRICA al codi JS que solucioni aquest tipus d'errors d'arrel per sempre. No solucionis nomÃ©s el sÃ­mptoma actual (ex: si el personatge oblida que estÃ  ferit, no demanis un camp "ferides", demana un mÃ²dul de persistÃ¨ncia d'estats fÃ­sics al NKG).

Genera un PROMPT MESTRE que jo pugui copiar i enganxar al meu assistent de codi (Cursor/Codex) per implementar la teva soluciÃ³.
El prompt ha de:
1. Explicar breument el problema sistÃ¨mic detectat al codi.
2. Definir la nova arquitectura proposada.
3. Donar instruccions tÃ¨cniques clares sobre quines funcions JavaScript exactes s'han de modificar i com.

Retorna EXCLUSIVAMENT el text del prompt llest per copiar i enganxar, escrit en catalÃ .`;

    // 4. CRIDA AL MODEL (Opus)
    const msgs = [{ role: 'user', content: promptEnginyer }];
    const models = getModelConfig(USER_CONFIG);

    const respostaLLM = await callLLMMulti(
      msgs,
      "Ets un Enginyer de Software Meta-AnalÃ­tic.",
      Object.assign({}, USER_CONFIG, { maxTokens: 4000, model: models.modelArquitecte }),
      'arquitectura'
    );

    // 5. MOSTRAR EL RESULTAT PER COPIAR
    resultDiv.innerHTML = `
      <div style="background:var(--surface); border:1px solid var(--border); border-radius:8px; padding:16px; margin-top:14px;">
        <div style="font-weight:600; color:var(--success); margin-bottom:10px; display:flex; justify-content:space-between;">
          <span>âœ… Prompt d'Arquitectura generat</span>
          <span style="font-size:.8rem; font-weight:normal; color:var(--text2);">Copia'l i enganxa'l al teu editor</span>
        </div>
        <textarea style="width:100%; height:280px; background:var(--surface2); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:12px; font-family:monospace; font-size:.85rem; resize:vertical; line-height:1.5;" readonly onclick="this.select()">${escHtml(respostaLLM)}</textarea>
      </div>
    `;

  } catch (err) {
    resultDiv.innerHTML = `<div style="color:#f87171; background:rgba(248,113,113,0.1); padding:10px; border-radius:6px; margin-top:10px; font-size:.9rem;">âš ï¸ Error generant el prompt: ${err.message}</div>`;
  }
}

async function reescriureCapitolGlobal(idx, instruccions) {
  if (!instruccions || !ESTAT._capitols_generats[idx]) return;
  // Reutilitzem la funciÃ³ existent
  ESTAT._revisioInstruccions = ESTAT._revisioInstruccions || {};
  ESTAT._revisioInstruccions[idx] = instruccions;
  await reescriureCapitol(idx);
}

// â”€â”€â”€ SISTEMA 1: BÃ­blia Narrativa â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function obrirBiblia() {
  const modal = document.getElementById('modal-biblia');
  const cos   = document.getElementById('biblia-cos');
  const b     = ESTAT.bibliaNarrativa;

  let html = '';
  if (b.regles_mon && b.regles_mon.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸŒ Regles del MÃ³n</h4><ul style="padding-left:18px">${b.regles_mon.map(r => `<li style="margin-bottom:4px">${r}</li>`).join('')}</ul>`;
  }
  if (b.llocs_importants && b.llocs_importants.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ“ Llocs Importants</h4><ul style="padding-left:18px">${b.llocs_importants.map(l => `<li style="margin-bottom:4px"><strong>${l.nom}</strong>: ${l.descripcio}</li>`).join('')}</ul>`;
  }
  if (b.objectes_clau && b.objectes_clau.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ”‘ Objectes Clau</h4><ul style="padding-left:18px">${b.objectes_clau.map(o => `<li style="margin-bottom:4px"><strong>${o.nom}</strong>: ${o.significat}</li>`).join('')}</ul>`;
  }
  if (b.fitxes_personatges && b.fitxes_personatges.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ‘¤ Personatges</h4>`;
    b.fitxes_personatges.forEach(p => {
      html += `<div style="background:var(--surface2);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:10px">
        <strong style="color:var(--accent)">${p.nom}</strong>
        ${p.estat_actual  ? `<div style="font-size:.85rem;color:var(--text2);margin-top:4px">Estat: ${p.estat_actual}</div>` : ''}
        ${p.motivacions   ? `<div style="font-size:.85rem;margin-top:4px">Motivacions: ${p.motivacions}</div>` : ''}
        ${p.secrets       ? `<div style="font-size:.85rem;color:var(--warning);margin-top:4px">Secrets: ${p.secrets}</div>` : ''}
      </div>`;
    });
  }
  if (b.fets_canonics && b.fets_canonics.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ“œ Fets CanÃ²nics</h4><ul style="padding-left:18px">${b.fets_canonics.slice(-10).map(f => `<li style="margin-bottom:4px">${f}</li>`).join('')}</ul>`;
  }
  if (!html) {
    html = '<p style="color:var(--text2);text-align:center;padding:24px">La bÃ­blia narrativa encara no s\'ha inicialitzat.</p>';
  }
  cos.innerHTML = html;
  modal.classList.remove('hidden');
}

function tancarModalBiblia() {
  document.getElementById('modal-biblia').classList.add('hidden');
}

function normalitzarFetsCanonics(fets) {
  if (!Array.isArray(fets)) return [];
  return [...new Set(
    fets
      .map(f => typeof f === 'string' ? f : (f && typeof f.descripcio === 'string' ? f.descripcio : ''))
      .map(f => String(f || '').trim())
      .filter(Boolean)
  )];
}

function aplicarCanvisBiblia(canvis) {
  if (!canvis) return;
  const b = ESTAT.bibliaNarrativa;
  const fetsNous = normalitzarFetsCanonics([...(canvis.nous_fets_canonics || []), ...(canvis.fets_canonics || [])]);
  if (fetsNous.length > 0) {
    b.fets_canonics = normalitzarFetsCanonics([...(b.fets_canonics || []), ...fetsNous]);
  }
  if (canvis.actualitzar_personatges && canvis.actualitzar_personatges.length > 0) {
    canvis.actualitzar_personatges.forEach(upd => {
      const fitxa = (b.fitxes_personatges || []).find(f => f.nom === upd.nom);
      if (fitxa) {
        if (upd.nou_estat)    fitxa.estat_actual = upd.nou_estat;
        if (upd.nous_secrets) fitxa.secrets      = upd.nous_secrets;
        if (upd.motivacions)  fitxa.motivacions  = upd.motivacions;
      } else if (upd.nom) {
        b.fitxes_personatges = b.fitxes_personatges || [];
        b.fitxes_personatges.push({ nom: upd.nom, estat_actual: upd.nou_estat, motivacions: upd.motivacions, secrets: upd.nous_secrets });
      }
    });
  }
  if (canvis.nous_llocs && canvis.nous_llocs.length > 0) {
    b.llocs_importants = (b.llocs_importants || []).concat(canvis.nous_llocs);
  }
  if (canvis.nous_objectes && canvis.nous_objectes.length > 0) {
    b.objectes_clau = (b.objectes_clau || []).concat(canvis.nous_objectes);
  }
}

// â”€â”€â”€ SISTEMA 2: Fase de Trames â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function iniciarFaseTrames() {
  showCard('fase-9-5');
  updateProgress(9.5);
  showLoader('9-5');
  document.getElementById('trames-result').classList.add('hidden');
  try {
    const res   = await generarTrames(USER_CONFIG);
    const dades = parseJsonRobust(res.response);
    if (dades) {
      ESTAT.trames.trama_principal  = dades.trama_principal  || null;
      ESTAT.trames.subtrames        = dades.subtrames        || [];
      ESTAT.trames.mapa_entrellacat = dades.mapa_entrellacat || [];

      // Retry: si el mapa estÃ  incomplet, completar-lo per separat
      const capsEsperats = ESTAT._nombreCapitols || 12;
      if (!dades.mapa_entrellacat || dades.mapa_entrellacat.length < capsEsperats) {
        console.warn(`Mapa entrellaÃ§at incomplet: ${(dades.mapa_entrellacat||[]).length}/${capsEsperats}. Regenerant...`);
        document.getElementById('loader-9-5-text').textContent = 'ğŸ”µ Completant mapa de tramesâ€¦';
        try {
          const mapaRes = await completarMapaTrames(dades, capsEsperats, USER_CONFIG);
          const mapaDades = parseJsonRobust(mapaRes.response);
          if (mapaDades && mapaDades.mapa_entrellacat && mapaDades.mapa_entrellacat.length >= capsEsperats) {
            ESTAT.trames.mapa_entrellacat = mapaDades.mapa_entrellacat;
            dades.mapa_entrellacat = mapaDades.mapa_entrellacat;
          }
        } catch (retryErr) {
          console.warn('Retry mapa trames: ' + retryErr.message);
        }
      }
    }
    mostrarTrames(res.response, dades);
  } catch (err) {
    hideLoader('9-5');
    alert('Error generant les trames: ' + err.message);
  }
}

function mostrarTrames(textOriginal, dades) {
  hideLoader('9-5');
  const result = document.getElementById('trames-result');
  const cos    = document.getElementById('trames-cos');
  if (!dades) {
    cos.innerHTML = `<pre style="white-space:pre-wrap;font-size:.85rem;color:var(--text2)">${textOriginal}</pre>`;
    result.classList.remove('hidden');
    return;
  }
  let html = '';
  if (dades.trama_principal) {
    const tp = dades.trama_principal;
    html += `<div style="background:var(--surface2);border:1px solid var(--accent);border-radius:10px;padding:16px;margin-bottom:16px">
      <div style="font-weight:700;color:var(--accent2);margin-bottom:8px">ğŸ¯ Trama Principal</div>
      <div style="font-size:.95rem">${tp.descripcio || tp}</div>
      ${tp.conflicte_central ? `<div style="font-size:.85rem;color:var(--text2);margin-top:6px">Conflicte: ${tp.conflicte_central}</div>` : ''}
      ${tp.arc_protagonista  ? `<div style="font-size:.85rem;color:var(--text2);margin-top:4px">Arc: ${tp.arc_protagonista}</div>`   : ''}
    </div>`;
  }
  if (dades.subtrames && dades.subtrames.length > 0) {
    html += `<div style="font-weight:600;color:var(--accent2);margin-bottom:10px">ğŸ•¸ï¸ Subtrames (${dades.subtrames.length})</div>`;
    dades.subtrames.forEach((st, i) => {
      html += `<div style="background:var(--surface2);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:10px">
        <div style="font-weight:600;color:var(--text)">${i + 1}. ${st.nom || 'Subtrama ' + (i + 1)}</div>
        <div style="font-size:.88rem;color:var(--text2);margin-top:4px">${st.descripcio || ''}</div>
        ${st.personatges_implicats ? `<div style="font-size:.83rem;margin-top:6px;color:var(--accent2)">Personatges: ${Array.isArray(st.personatges_implicats) ? st.personatges_implicats.join(', ') : st.personatges_implicats}</div>` : ''}
        ${st.com_entrellaÃ§a ? `<div style="font-size:.83rem;margin-top:4px;color:var(--text2)">Trama principal: ${st.com_entrellaÃ§a}</div>` : ''}
      </div>`;
    });
  }
  if (dades.mapa_entrellacat && dades.mapa_entrellacat.length > 0) {
    html += `<div style="font-weight:600;color:var(--accent2);margin:12px 0 8px">ğŸ—ºï¸ Mapa d'EntrellaÃ§at</div>
    <div style="font-size:.85rem;color:var(--text2)">`;
    dades.mapa_entrellacat.forEach(m => {
      html += `<div style="margin-bottom:4px">Cap. ${m.capitol}: ${m.trames_actives ? m.trames_actives.join(' + ') : (m.notes || '')}</div>`;
    });
    html += '</div>';
  }
  cos.innerHTML = html || `<pre style="white-space:pre-wrap;font-size:.85rem">${textOriginal}</pre>`;
  result.classList.remove('hidden');
}

// â”€â”€â”€ SISTEMA 4: Checkpoint de coherÃ¨ncia â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function mostrarCheckpoint(dades, idx) {
  if (!dades) return;
  const listId   = 'capitols-list';
  const container = document.getElementById(listId) || document.body;
  const panel    = document.createElement('div');
  panel.style.cssText = 'background:var(--surface2);border:2px solid var(--warning);border-radius:12px;padding:18px;margin:16px 0';
  const punts  = dades.puntuacio_coherencia;
  const color  = punts >= 7 ? 'var(--success)' : (punts >= 5 ? 'var(--warning)' : '#f87171');
  panel.innerHTML = `
    <div style="font-weight:700;color:var(--warning);margin-bottom:10px">ğŸ” Checkpoint de CoherÃ¨ncia â€” Cap. ${idx + 1}</div>
    <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px">
      <div style="font-size:2rem;font-weight:700;color:${color}">${punts || '?'}/10</div>
      <div style="font-size:.9rem;color:var(--text2)">${dades.valoracio_general || ''}</div>
    </div>
    ${dades.problemes_detectats && dades.problemes_detectats.length > 0
      ? `<div style="font-weight:600;color:#f87171;margin-bottom:6px">âš ï¸ Problemes detectats</div>
         <ul style="padding-left:18px;font-size:.88rem;color:var(--text2)">${dades.problemes_detectats.map(p => `<li style="margin-bottom:4px">${p}</li>`).join('')}</ul>`
      : '<div style="color:var(--success);font-size:.9rem">âœ“ CoherÃ¨ncia correcta fins ara</div>'}
    ${dades.recomanacions && dades.recomanacions.length > 0
      ? `<div style="font-weight:600;color:var(--accent2);margin:10px 0 6px">ğŸ’¡ Recomanacions per als prÃ²xims capÃ­tols</div>
         <ul style="padding-left:18px;font-size:.88rem">${dades.recomanacions.map(r => `<li style="margin-bottom:4px">${r}</li>`).join('')}</ul>`
      : ''}
  `;
  container.appendChild(panel);
  if (dades.ajustos_rumb) {
    ESTAT._ajustosRumb = dades.ajustos_rumb;
  }
}

// â”€â”€â”€ SISTEMA 3: Millorar Cliffhanger â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function millorarCliffhanger(idx, instruccions) {
  if (!instruccions) return;
  const btn = event && event.target ? event.target : null;
  if (btn) { btn.disabled = true; btn.textContent = 'â³ Millorantâ€¦'; }
  try {
    ESTAT._revisioInstruccions = ESTAT._revisioInstruccions || {};
    ESTAT._revisioInstruccions[idx] = instruccions;
    await reescriureCapitol(idx);
    if (btn) { btn.textContent = 'âœ“ Cliffhanger millorat'; }
  } catch (err) {
    if (btn) { btn.disabled = false; btn.textContent = 'ğŸ£ Millorar cliffhanger'; }
    alert('Error: ' + err.message);
  }
}

function mostrarRepeticions(reps) {
  const div = document.getElementById('revisio-global-result');
  if (!div) return;
  let html = '<div style="margin-top:16px;padding:12px;background:#fff3cd;border-radius:8px;">';
  html += '<h3>ğŸ” Expressions Repetides Detectades</h3>';
  if (reps.trigrames && reps.trigrames.length > 0) {
    html += '<p><strong>Trigrames (3+ capÃ­tols):</strong> ' + reps.trigrames.slice(0,10).map(([ng,c]) => `"${escHtml(ng)}" (${c})`).join(', ') + '</p>';
  }
  if (reps.bigrames && reps.bigrames.length > 0) {
    html += '<p><strong>Bigrames (3+ capÃ­tols):</strong> ' + reps.bigrames.slice(0,10).map(([ng,c]) => `"${escHtml(ng)}" (${c})`).join(', ') + '</p>';
  }
  html += '</div>';
  div.insertAdjacentHTML('beforeend', html);
}
</script>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     BACKEND LOCAL â€” migrat de codigo.gs
     Canvis respecte a l'original:
       Â· Eliminada la funciÃ³ doGet()
       Â· callLLM, callAnthropic, callOpenAI, callGemini â†’ async
       Â· UrlFetchApp.fetch() â†’ await fetch() (API estÃ ndard del navegador)
       Â· parseJsonResponse â†’ async, usa response.status i await response.text()
       Â· Afegit CORS_PROXY per a Anthropic (evita errors CORS des del navegador)
       Â· Totes les funcions de fase â†’ async/await callLLM
       Â· exportarADoc â†’ descÃ rrega local via Blob + URL.createObjectURL (sense DocumentApp)
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>

// â”€â”€â”€ CORS per a Anthropic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Anthropic suporta crides directes des del navegador afegint la capÃ§alera
// 'anthropic-dangerous-direct-browser-access: true'.
// AixÃ² elimina la necessitat de qualsevol proxy extern.

// â”€â”€â”€ URLs i models per defecte â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PROVIDER_DEFAULTS = {
  anthropic: {
    apiUrl: 'https://api.anthropic.com/v1/messages',
    model: 'claude-opus-4-1'
  },
  openai: {
    apiUrl: 'https://api.openai.com/v1/chat/completions',
    model: 'gpt-4o'
  },
  gemini: {
    apiUrlBase: 'https://generativelanguage.googleapis.com/v1beta/models',
    model: 'gemini-1.5-pro'
  }
};

// â”€â”€â”€ Parseig de la resposta fetch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Equivalent a parseJsonResponse de GAS, adaptat a l'API fetch:
//   Â· rawResponse.status       en lloc de rawResponse.getResponseCode()
//   Â· await rawResponse.text() en lloc de rawResponse.getContentText()
async function parseJsonResponse(rawResponse, providerName) {
  const statusCode = rawResponse.status;
  const rawText    = await rawResponse.text() || '';
  let parsed;
  try {
    parsed = JSON.parse(rawText);
  } catch (e) {
    // Resposta no JSON: pot ser pÃ gina HTML del proxy o error de xarxa
    const preview = rawText.slice(0, 300).replace(/\s+/g, ' ');
    throw new Error(
      `${providerName} HTTP ${statusCode} â€” resposta no JSON del proxy.\n` +
      `Comprova la consola del navegador (F12) per mÃ©s detalls.\n` +
      `Inici de la resposta: ${preview}`
    );
  }
  if (statusCode >= 400) {
    const message = parsed && parsed.error
      ? (parsed.error.message || JSON.stringify(parsed.error))
      : rawText.slice(0, 300);
    throw new Error(`${providerName} HTTP ${statusCode}: ${message}`);
  }
  return parsed;
}

// â”€â”€â”€ fetchSegur: fetch amb backoff exponencial â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Substitueix fetch() directe per a totes les crides LLM.
// Reintenta automÃ ticament si l'API retorna 429, 503 o 529.
async function fetchSegur(url, options, maxIntents = 4) {
  const RETRYABLE = new Set([429, 503, 529]);
  for (let intent = 0; intent < maxIntents; intent++) {
    const response = await fetch(url, options);
    if (!RETRYABLE.has(response.status)) return response;
    if (intent === maxIntents - 1) return response; // Ãºltim intent: retorna per deixar parseJsonResponse gestionar l'error
    const delayMs = Math.pow(2, intent) * 10000; // 10s â†’ 20s â†’ 40s â†’ 80s
    console.warn(`[fetchSegur] HTTP ${response.status} â€” reintent ${intent + 1}/${maxIntents - 1} en ${delayMs / 1000}s...`);
    await new Promise(resolve => setTimeout(resolve, delayMs));
  }
}

// â”€â”€â”€ analitzarRespostaGenerica: parser estandarditzat â”€â”€â”€â”€â”€â”€â”€â”€
// Extreu text i detecta tall per lÃ­mit de tokens de forma
// agnÃ²stica al proveÃ¯dor. Retorna { text, textIncomplet }.
function analitzarRespostaGenerica(respostaJSON, proveidor) {
  let text = '';
  let textIncomplet = false;

  if (proveidor === 'anthropic') {
    text = Array.isArray(respostaJSON.content)
      ? respostaJSON.content.filter(p => p && p.type === 'text').map(p => p.text || '').join('\n')
      : '';
    textIncomplet = respostaJSON.stop_reason === 'max_tokens';

  } else if (proveidor === 'openai') {
    const firstChoice = respostaJSON.choices && respostaJSON.choices[0];
    const content = firstChoice && firstChoice.message ? firstChoice.message.content : '';
    text = extractContentText(content);
    textIncomplet = !!(firstChoice && firstChoice.finish_reason === 'length');

  } else if (proveidor === 'google' || proveidor === 'gemini') {
    const firstCandidate = respostaJSON.candidates && respostaJSON.candidates[0];
    if (firstCandidate && firstCandidate.finishReason === 'SAFETY') {
      throw new Error('Gemini ha bloquejat la resposta per filtres de seguretat extrems. Prova amb un fragment menys sensible.');
    }
    const parts = firstCandidate && firstCandidate.content ? firstCandidate.content.parts : [];
    text = Array.isArray(parts) ? parts.map(p => (p && p.text) ? p.text : '').join('\n') : '';
    textIncomplet = !!(firstCandidate && firstCandidate.finishReason === 'MAX_TOKENS');

  } else {
    throw new Error(`analitzarRespostaGenerica: proveidor desconegut "${proveidor}"`);
  }

  return { text: normalizeLLMText(text), textIncomplet };
}

// â”€â”€â”€ Helpers per llegir max_output del registre â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getMaxTokens(safeConfig, modelId) {
  if (safeConfig.maxTokens) return safeConfig.maxTokens;
  const entry = MODEL_REGISTRY[modelId];
  return (entry && entry.max_output) || 4096;
}

// â”€â”€â”€ Router multi-proveÃ¯dor i multi-rol â€” v5.1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// tag: 'generacio' | 'arquitecte' | 'arquitectura'
// config._esDraft: true â†’ usa model Draft (Haiku o equivalent)
// config.model: override explÃ­cit del model (mÃ xima prioritat)
function getProviderPerRol(config, tag) {
  const cfg = config || {};
  const isArq = (tag === 'arquitecte' || tag === 'arquitectura');
  const roleProvider = isArq
    ? (cfg.providerArquitectura || cfg.provider_arq)
    : (cfg.providerGeneracio || cfg.provider_gen || cfg.providerDraft);
  return (roleProvider || cfg.provider || 'anthropic');
}

async function callLLMMulti(messages, systemPrompt, config, tag) {
  const safeConfig = config || {};

  // Assignem el model segons si la tasca Ã©s d'arquitectura o de generaciÃ³
  let modelId;
  if (tag === 'arquitecte' || tag === 'arquitectura') {
    modelId = safeConfig.modelArquitectura || safeConfig.model;
  } else {
    // Si no Ã©s arquitectura, o Ã©s draft/generaciÃ³, usem el de generaciÃ³
    modelId = safeConfig.modelGeneracio || safeConfig.model;
  }

  const proveidor = getProviderPerRol(safeConfig, tag);

  // Obtenim la clau API corresponent
  let apiKey;
  if (proveidor === 'anthropic') apiKey = ESTAT._anthropicApiKey || safeConfig.apiKey;
  if (proveidor === 'google' || proveidor === 'gemini') apiKey = ESTAT._geminiApiKey || safeConfig.apiKey;
  if (proveidor === 'openai') apiKey = ESTAT._openaiApiKey || safeConfig.apiKey;

  if (!apiKey) throw new Error(`Cal una clau API per al proveÃ¯dor: ${proveidor}`);

  const maxTokens = getMaxTokens(safeConfig, modelId);

  // Enrutem directament al proveÃ¯dor triat amb el text lliure del model
  if (proveidor === 'anthropic') return await callAnthropic(messages, systemPrompt, apiKey, modelId, maxTokens);
  if (proveidor === 'google' || proveidor === 'gemini') return await callGemini(messages, systemPrompt, apiKey, modelId, maxTokens);
  if (proveidor === 'openai') return await callOpenAI(messages, systemPrompt, apiKey, modelId, maxTokens);

  throw new Error(`ProveÃ¯dor desconegut: ${proveidor}`);
}

async function callLLMWithContinuation(messages, systemPrompt, config, tag, maxCont = 3) {
  const safeConfig = config || {};

  let modelId;
  if (tag === 'arquitecte' || tag === 'arquitectura') {
    modelId = safeConfig.modelArquitectura || safeConfig.model;
  } else {
    modelId = safeConfig.modelGeneracio || safeConfig.model;
  }

  const proveidor = getProviderPerRol(safeConfig, tag);

  let apiKey;
  if (proveidor === 'anthropic') apiKey = ESTAT._anthropicApiKey || safeConfig.apiKey;
  if (proveidor === 'google' || proveidor === 'gemini') apiKey = ESTAT._geminiApiKey || safeConfig.apiKey;
  if (proveidor === 'openai') apiKey = ESTAT._openaiApiKey || safeConfig.apiKey;

  if (!apiKey) throw new Error(`Cal una clau API per al proveÃ¯dor: ${proveidor}`);

  const maxTokens = getMaxTokens(safeConfig, modelId);

  let fullText = '';
  let currentMessages = [...messages];

  for (let i = 0; i <= maxCont; i++) {
    let result;
    if (proveidor === 'anthropic') {
      result = await callAnthropicWithFinishReason(currentMessages, systemPrompt, apiKey, modelId, maxTokens);
    } else if (proveidor === 'google' || proveidor === 'gemini') {
      result = await callGeminiWithFinishReason(currentMessages, systemPrompt, apiKey, modelId, maxTokens);
    } else if (proveidor === 'openai') {
      result = await callOpenAIWithFinishReason(currentMessages, systemPrompt, apiKey, modelId, maxTokens);
    } else {
      throw new Error(`ProveÃ¯dor desconegut: ${proveidor}`);
    }

    fullText += result.text;

    if (!result.textIncomplet) break;

    console.log(`[callLLMWithContinuation] Text tallat (iteraciÃ³ ${i + 1}/${maxCont}), solÂ·licitant continuaciÃ³...`);
    currentMessages = [
      ...currentMessages,
      { role: 'assistant', content: result.text },
      { role: 'user', content: "El teu Ãºltim missatge s'ha tallat per lÃ­mits de longitud. Continua escrivint EXACTAMENT des de la teva Ãºltima lletra, sense introduccions ni disculpes." }
    ];
  }

  return fullText;
}

function textSemblaIncomplet(text) {
  const net = String(text || '').trim();
  if (!net) return true;
  if (net.length < 80) return true;
  const final = net.slice(-1);
  const tancaFrase = '.!?â€¦Â»â€"\'';
  if (!tancaFrase.includes(final)) return true;
  const opens = (net.match(/[\(\[\{"Â«]/g) || []).length;
  const closes = (net.match(/[\)\]\}"Â»]/g) || []).length;
  return opens > closes;
}

async function callLLMOneShotPlusCompletion(messages, systemPrompt, config, tag) {
  const safeConfig = config || {};

  let modelId;
  if (tag === 'arquitecte' || tag === 'arquitectura') {
    modelId = safeConfig.modelArquitectura || safeConfig.model;
  } else {
    modelId = safeConfig.modelGeneracio || safeConfig.model;
  }

  const proveidor = getProviderPerRol(safeConfig, tag);
  let apiKey;
  if (proveidor === 'anthropic') apiKey = ESTAT._anthropicApiKey || safeConfig.apiKey;
  if (proveidor === 'google' || proveidor === 'gemini') apiKey = ESTAT._geminiApiKey || safeConfig.apiKey;
  if (proveidor === 'openai') apiKey = ESTAT._openaiApiKey || safeConfig.apiKey;
  if (!apiKey) throw new Error(`Cal una clau API per al proveÃ¯dor: ${proveidor}`);

  const maxTokens = getMaxTokens(safeConfig, modelId);

  let primera;
  if (proveidor === 'anthropic') {
    primera = await callAnthropicWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else if (proveidor === 'google' || proveidor === 'gemini') {
    primera = await callGeminiWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else if (proveidor === 'openai') {
    primera = await callOpenAIWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else {
    throw new Error(`ProveÃ¯dor desconegut: ${proveidor}`);
  }

  let text = primera.text || '';

  // Segona crida: nomÃ©s verificaciÃ³ de tancament (i, si cal, micro-completat).
  console.log('[callLLMOneShotPlusCompletion] Segona crida de validaciÃ³ final.');
  const missatgesTancament = [
    ...messages,
    { role: 'assistant', content: text },
    { role: 'user', content: `VERIFICACIÃ“ DE TANCAMENT (PASSADA 2):
Revisa l'Ãºltim parÃ graf que acabes d'escriure.
1. Si el text estÃ  perfectament tancat a nivell narratiu, no s'ha tallat a mitja frase i la longitud Ã©s l'adequada, respon EXACTAMENT amb la paraula: OK
2. Si el text s'ha tallat, ha quedat incomplet o necessita una expansiÃ³ final per tancar bÃ© l'escena/capÃ­tol, respon EXACTAMENT en aquest format:
APPEND: <escriu aquÃ­ la continuaciÃ³ directa des del punt exacte on t'has aturat, afegint el desenvolupament final necessari per tancar-ho amb excelÂ·lÃ¨ncia>.
No repeteixis res del que ja has escrit.` }
  ];
  const configTancament = Object.assign({}, safeConfig, { maxTokens: 220 });

  try {
    const revisio = (await callLLMMulti(missatgesTancament, systemPrompt, configTancament, tag) || '').trim();
    if (/^OK\s*$/i.test(revisio)) return text;

    const match = revisio.match(/^APPEND:\s*([\s\S]*)$/i);
    if (match && match[1] && match[1].trim()) {
      text += match[1].trimStart();
      return text;
    }

    // Fallback robust: nomÃ©s si el detector local veu final incomplet.
    if (primera.textIncomplet || textSemblaIncomplet(text)) {
      const rescat = await callLLMMulti([
        ...messages,
        { role: 'assistant', content: text },
        { role: 'user', content: "Completa NOMÃ‰S el tram final si havia quedat tallat. No repeteixis res. Escriu nomÃ©s el mÃ­nim per tancar correctament la frase o l'Ãºltim parÃ graf." }
      ], systemPrompt, Object.assign({}, safeConfig, { maxTokens: 240 }), tag);
      if (rescat && rescat.trim()) text += rescat;
    }
  } catch (err) {
    console.warn('[callLLMOneShotPlusCompletion] ValidaciÃ³ final fallida:', err.message);
  }

  return text;
}

async function callLLMOneShotConditionalCompletion(messages, systemPrompt, config, tag) {
  const safeConfig = config || {};

  let modelId;
  if (tag === 'arquitecte' || tag === 'arquitectura') {
    modelId = safeConfig.modelArquitectura || safeConfig.model;
  } else {
    modelId = safeConfig.modelGeneracio || safeConfig.model;
  }

  const proveidor = getProviderPerRol(safeConfig, tag);
  let apiKey;
  if (proveidor === 'anthropic') apiKey = ESTAT._anthropicApiKey || safeConfig.apiKey;
  if (proveidor === 'google' || proveidor === 'gemini') apiKey = ESTAT._geminiApiKey || safeConfig.apiKey;
  if (proveidor === 'openai') apiKey = ESTAT._openaiApiKey || safeConfig.apiKey;
  if (!apiKey) throw new Error(`Cal una clau API per al proveÃ¯dor: ${proveidor}`);

  const maxTokens = getMaxTokens(safeConfig, modelId);

  let primera;
  if (proveidor === 'anthropic') {
    primera = await callAnthropicWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else if (proveidor === 'google' || proveidor === 'gemini') {
    primera = await callGeminiWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else if (proveidor === 'openai') {
    primera = await callOpenAIWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else {
    throw new Error(`ProveÃ¯dor desconegut: ${proveidor}`);
  }

  let text = primera.text || '';
  const necessitaTancament = primera.textIncomplet || textSemblaIncomplet(text);
  if (!necessitaTancament) return text;

  const missatgesTancament = [
    ...messages,
    { role: 'assistant', content: text },
    { role: 'user', content: `Continua el text exactament des d'on t'has aturat i tanca bÃ© el final.
INSTRUCCIONS ESTRICTES:
- NO repeteixis cap frase ni cap idea ja escrita
- NO resumeixis
- Afegeix nomÃ©s el mÃ­nim necessari per completar el capÃ­tol
- Acaba amb un final ben tancat` }
  ];

  const append = await callLLMMulti(
    missatgesTancament,
    systemPrompt,
    Object.assign({}, safeConfig, { maxTokens: 320 }),
    tag
  );

  if (append && append.trim()) text += append.trimStart();
  return text;
}



function parseEscenesUnificades(text, totalEscenes) {
  const net = String(text || '').replace(/\r/g, '').trim();
  const out = [];
  if (!net) return out;

  const re = /(?:^|\n)\[\[ESCENA_(\d+)\]\]\s*\n?/g;
  const marks = [];
  let m;
  while ((m = re.exec(net)) !== null) {
    marks.push({ idx: parseInt(m[1], 10), pos: m.index, len: m[0].length });
  }

  if (marks.length === 0) return out;

  for (let i = 0; i < marks.length; i++) {
    const curr = marks[i];
    const next = marks[i + 1];
    const start = curr.pos + curr.len;
    const end = next ? next.pos : net.length;
    const txt = net.slice(start, end).trim();
    if (!txt) continue;
    out.push({ escena: curr.idx, text: txt });
  }

  const uniq = {};
  out.forEach(e => { if (!uniq[e.escena]) uniq[e.escena] = e.text; });
  const ordered = Object.keys(uniq)
    .map(k => ({ escena: parseInt(k, 10), text: uniq[k] }))
    .sort((a, b) => a.escena - b.escena)
    .filter(e => e.escena >= 1 && e.escena <= Math.max(1, totalEscenes || 1));

  return ordered;
}

// â”€â”€â”€ Crida genÃ¨rica a LLM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// rol: 'generacio' (Sonnet) | 'arquitectura' (Opus) â€” nomÃ©s per a Anthropic
async function callLLM(messages, systemPrompt, config, rol) {
  rol = rol || 'generacio';
  const safeConfig = config || {};
  const provider   = String(safeConfig.provider || '').toLowerCase().trim();
  const apiKey     = safeConfig.apiKey;

  if (!provider) throw new Error('Falta el provider al config.');
  if (!apiKey)   throw new Error("Falta l'apiKey al config.");

  // SelecciÃ³ del model: si 'model' s'ha passat explÃ­citament com a override, prioritat mÃ xima
  let model;
  if (safeConfig.model) {
    model = safeConfig.model; // override explÃ­cit â€” prioritat mÃ xima (sistema hÃ­brid v5)
  } else if (rol === 'arquitectura' && provider === 'anthropic' && safeConfig.modelArquitectura) {
    model = safeConfig.modelArquitectura;
  } else {
    model = safeConfig.modelGeneracio ||
            (PROVIDER_DEFAULTS[provider] && PROVIDER_DEFAULTS[provider].model);
  }

  const maxTokens = getMaxTokens(safeConfig, model);

  if (provider === 'anthropic') return await callAnthropic(messages, systemPrompt, apiKey, model, maxTokens);
  if (provider === 'openai')    return await callOpenAI(messages, systemPrompt, apiKey, model, maxTokens);
  if (provider === 'gemini' || provider === 'google' || provider === 'google-gemini')
    return await callGemini(messages, systemPrompt, apiKey, model, maxTokens);

  throw new Error('Provider no suportat: ' + provider);
}

// â”€â”€â”€ Anthropic (Claude) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Crida directa des del navegador sense proxy extern.
// La capÃ§alera 'anthropic-dangerous-direct-browser-access' habilita CORS
// a l'API d'Anthropic per a Ãºs des del navegador (la clau queda al client,
// acceptable per a Ãºs personal/local).
async function callAnthropic(messages, systemPrompt, apiKey, model, maxTokens) {
  const payload = {
    model:      model || PROVIDER_DEFAULTS.anthropic.model,
    max_tokens: maxTokens,
    system:     systemPrompt || SYSTEM_DEFAULT,
    messages:   messages
  };

  const raw = await fetchSegur(PROVIDER_DEFAULTS.anthropic.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type':                              'application/json',
      'x-api-key':                                 apiKey,
      'anthropic-version':                         '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true'
    },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'Anthropic');
  if (result.error) throw new Error(result.error.message || "Error desconegut d'Anthropic.");
  return analitzarRespostaGenerica(result, 'anthropic').text;
}

async function callAnthropicWithFinishReason(messages, systemPrompt, apiKey, model, maxTokens) {
  const payload = {
    model:      model || PROVIDER_DEFAULTS.anthropic.model,
    max_tokens: maxTokens,
    system:     systemPrompt || SYSTEM_DEFAULT,
    messages:   messages
  };

  const raw = await fetchSegur(PROVIDER_DEFAULTS.anthropic.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type':                              'application/json',
      'x-api-key':                                 apiKey,
      'anthropic-version':                         '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true'
    },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'Anthropic');
  if (result.error) throw new Error(result.error.message || "Error desconegut d'Anthropic.");
  return analitzarRespostaGenerica(result, 'anthropic');
}

// â”€â”€â”€ OpenAI (GPT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// OpenAI permet CORS des del navegador amb la seva API pÃºblica,
// de manera que no cal proxy.
async function callOpenAI(messages, systemPrompt, apiKey, model, maxTokens) {
  const payload = {
    model:      model || PROVIDER_DEFAULTS.openai.model,
    messages:   buildOpenAIMessages(messages, systemPrompt),
    max_tokens: maxTokens
  };

  const raw = await fetchSegur(PROVIDER_DEFAULTS.openai.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type':  'application/json',
      'Authorization': 'Bearer ' + apiKey
    },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'OpenAI');
  if (result.error) throw new Error(result.error.message || "Error desconegut d'OpenAI.");
  return analitzarRespostaGenerica(result, 'openai').text;
}

async function callOpenAIWithFinishReason(messages, systemPrompt, apiKey, model, maxTokens) {
  const payload = {
    model:      model || PROVIDER_DEFAULTS.openai.model,
    messages:   buildOpenAIMessages(messages, systemPrompt),
    max_tokens: maxTokens
  };

  const raw = await fetchSegur(PROVIDER_DEFAULTS.openai.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type':  'application/json',
      'Authorization': 'Bearer ' + apiKey
    },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'OpenAI');
  if (result.error) throw new Error(result.error.message || "Error desconegut d'OpenAI.");
  return analitzarRespostaGenerica(result, 'openai');
}

// â”€â”€â”€ Google Gemini â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// La clau API va com a parÃ metre de query string a la URL,
// no cal capÃ§alera d'autenticaciÃ³ addicional.
async function callGemini(messages, systemPrompt, apiKey, model, maxTokens) {
  const finalModel = model || PROVIDER_DEFAULTS.gemini.model;
  const endpoint   = PROVIDER_DEFAULTS.gemini.apiUrlBase + '/' +
    encodeURIComponent(finalModel) + ':generateContent?key=' + encodeURIComponent(apiKey);

  const payload = {
    contents:         buildGeminiContents(messages),
    generationConfig: { maxOutputTokens: maxTokens },
    // CORRECCIÃ“: Desactivem els filtres per permetre textos literaris
    safetySettings: [
      { category: "HARM_CATEGORY_HARASSMENT",        threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_HATE_SPEECH",        threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",  threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_DANGEROUS_CONTENT",  threshold: "BLOCK_NONE" }
    ]
  };

  if (systemPrompt || SYSTEM_DEFAULT) {
    payload.systemInstruction = { parts: [{ text: systemPrompt || SYSTEM_DEFAULT }] };
  }

  const raw = await fetchSegur(endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'Gemini');
  if (result.error) {
    throw new Error(
      (result.error.message || 'Error desconegut de Gemini.') +
      (result.error.status ? ' (' + result.error.status + ')' : '')
    );
  }
  return analitzarRespostaGenerica(result, 'google').text;
}

async function callGeminiWithFinishReason(messages, systemPrompt, apiKey, model, maxTokens) {
  const finalModel = model || PROVIDER_DEFAULTS.gemini.model;
  const endpoint   = PROVIDER_DEFAULTS.gemini.apiUrlBase + '/' +
    encodeURIComponent(finalModel) + ':generateContent?key=' + encodeURIComponent(apiKey);

  const payload = {
    contents:         buildGeminiContents(messages),
    generationConfig: { maxOutputTokens: maxTokens },
    safetySettings: [
      { category: "HARM_CATEGORY_HARASSMENT",        threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_HATE_SPEECH",        threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",  threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_DANGEROUS_CONTENT",  threshold: "BLOCK_NONE" }
    ]
  };

  if (systemPrompt || SYSTEM_DEFAULT) {
    payload.systemInstruction = { parts: [{ text: systemPrompt || SYSTEM_DEFAULT }] };
  }

  const raw = await fetchSegur(endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'Gemini');
  if (result.error) {
    throw new Error(
      (result.error.message || 'Error desconegut de Gemini.') +
      (result.error.status ? ' (' + result.error.status + ')' : '')
    );
  }
  return analitzarRespostaGenerica(result, 'google');
}

// â”€â”€â”€ Helpers de construcciÃ³ de missatges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildOpenAIMessages(messages, systemPrompt) {
  const base = [];
  if (systemPrompt || SYSTEM_DEFAULT) base.push({ role: 'system', content: systemPrompt || SYSTEM_DEFAULT });
  return base.concat((messages || []).map(msg => ({
    role:    msg.role,
    content: extractContentText(msg.content)
  })));
}

function buildGeminiContents(messages) {
  return (messages || []).map(msg => ({
    role:  msg.role === 'assistant' ? 'model' : 'user',
    parts: [{ text: extractContentText(msg.content) }]
  }));
}

function extractContentText(content) {
  if (typeof content === 'string') return content;
  if (Array.isArray(content)) return content.map(item => {
    if (typeof item === 'string') return item;
    if (item && typeof item.text === 'string') return item.text;
    return '';
  }).join('\n');
  if (content && typeof content.text === 'string') return content.text;
  return content ? String(content) : '';
}

function normalizeLLMText(text) {
  return (text || '').replace(/^\s+|\s+$/g, '');
}

// â”€â”€â”€ System prompt base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SYSTEM_DEFAULT = `Ets un mestre del conte literari breu en catalÃ .
Apliques el principi d'unitat d'efecte de Poe: cada paraula serveix un Ãºnic impacte emocional final.
Escrius amb economia de paraules, primera frase magnÃ¨tica, tensiÃ³ creixent i finals memorables que ressonen.
Mai desperdicies una frase. Prioritzes mostrar sobre explicar.
DIÃ€LEGS â€” SEPARACIÃ“ DE PARÃ€GRAFS: Ã‰s OBLIGATORI fer un punt i a part (nova lÃ­nia) cada vegada que canvia el personatge que parla o hi ha un canvi d'acciÃ³ important. MAI barregis intervencions de dos personatges diferents en el mateix parÃ graf.
Escrius EXCLUSIVAMENT en catalÃ . Mai inclous paraules, frases ni comentaris en anglÃ¨s o cap altra llengua. Mai afegeixes notes meta, indicacions de nÃºmero de part ni cap text fora de la narraciÃ³ literÃ ria. Escriu directament el text.`;

// â”€â”€â”€ ExtensiÃ³ d'estil per autor (reutilitzable per conte i novelÂ·la) â”€â”€â”€
function getGenreStyle(tematica) {
  const isLarsson   = tematica && /larsson|noir|negr[ae]|nÃ²rdi/i.test(tematica);
  const isTolkien   = tematica && /tolkien|fantÃ stic|fantastic|Ã¨pic/i.test(tematica);
  const isDick      = tematica && /philip k\. dick|philip.*dick|dick/i.test(tematica);
  const isCastaneda = tematica && /castaneda|xamÃ nic/i.test(tematica);

  if (isLarsson) return `

â”€â”€ ESTIL STIEG LARSSON â”€â”€
Pensament i visiÃ³ del mÃ³n: Larsson era periodista d'investigaciÃ³ i antifeixista militant. Les seves obres neixen de la convicciÃ³ que la violÃ¨ncia contra les dones i la corrupciÃ³ institucional sÃ³n sistÃ¨miques, no excepcions. Escrius des d'aquesta consciÃ¨ncia polÃ­tica sense abanderats ni discursos.
Prosa directa i funcional, carregada de detall procedimental: cada acciÃ³ d'investigaciÃ³ â€”una trucada, un arxiu consultat, una font protegidaâ€” s'explica amb lÃ²gica interna creÃ¯ble i concreta.
L'entorn nÃ²rdic (hivern escandinau, foscor, aÃ¯llament geogrÃ fic i social) actua com a personatge amb pes propi: el fred Ã©s moral tant com climÃ tic.
Secrets familiars soterrats durant dÃ¨cades que quan surten a la llum destapen patrons de violÃ¨ncia i complicitat que ningÃº volia veure.
Protagonistes traumatitzats amb una obstinaciÃ³ quasi patolÃ²gica: no investiguen per heroisme sinÃ³ perquÃ¨ no poden parar, la ferida personal Ã©s el motor.
CrÃ­tica social concreta i documentada integrada a la trama: noms d'institucions, mecanismes de poder, estadÃ­stiques de violÃ¨ncia que apareixen de forma natural al text.
Estructura de revelaciÃ³ progressiva: el que semblava un cas aÃ¯llat obre pas a un sistema podrit que implica tothom.
Ritme metÃ²dic i pausat en la investigaciÃ³, amb pics d'acciÃ³ breu, directa i brutal quan la violÃ¨ncia irromp.`;

  if (isTolkien) return `

â”€â”€ ESTIL J.R.R. TOLKIEN â”€â”€
Pensament i visiÃ³ del mÃ³n: Tolkien era filÃ²leg, catÃ²lic i veterÃ  de la Primera Guerra Mundial. El seu univers neix de la convicciÃ³ que el llenguatge crea realitat, que el bÃ© i el mal existeixen com a forces cÃ²smiques, i que la humilitat dels petits pot transformar la histÃ²ria. Escrius des d'aquesta fe en la bellesa i el sacrifici.
Prosa Ã¨pica, lÃ­rica i detallada: les descripcions de paisatge i arquitectura transmeten profunditat i antiguitat immemorial, com si el mÃ³n existÃ­s des d'abans que comencÃ©s la histÃ²ria.
Univers tolkieniÃ  complet: races (Eldar, Khazad, hobits, homes, orcs, ents), geografies amb nom i memÃ²ria prÃ²pia, llenguatges inventats amb fonologia coherent, canÃ§ons i poemes intercalats quan l'escena ho demana.
Temes centrals: la corrupciÃ³ del poder i la tentaciÃ³ dels anells, el pes de la responsabilitat sobre les espatlles dels humils, la camaraderia com a valor suprem, la bellesa efÃ­mera davant el pas implacable del temps i l'oblit.
Llenguatge solemne perÃ² accessible: frases llargues i rÃ­tmiques, construccions arcaiques mesurades, Ã¨mfasi en els noms propis com a portadors de destÃ­.
La natura com a presÃ¨ncia viva i moral: boscos, rius i muntanyes tenen memÃ²ria, voluntat i opiniÃ³ sobre els esdeveniments dels mortals.
El mal tÃ© pes fÃ­sic i sensorial: no s'explica, es percep en l'aire que s'espesseix, la llum que s'apaga, el silenci sobtat dels ocells i la por als ulls dels animals.`;

  if (isDick) return `

â”€â”€ ESTIL PHILIP K. DICK â”€â”€
Pensament i visiÃ³ del mÃ³n: Dick era un paranoic funcional fascinat per la gnosi, les drogues, la simulaciÃ³ i la pregunta de si alguna cosa Ã©s real. Les seves obres neixen de la convicciÃ³ que la realitat Ã©s una capa prima que pot trencar-se en qualsevol moment i que el sistema â€”qualsevol sistemaâ€” menteix. Escrius des d'aquesta desconfianÃ§a radical.
Paranoia com a estat cognitiu del protagonista i del lector: les institucions (estat, corporacions, androÃ¯des, drogues prescrites) manipulen la percepciÃ³; ningÃº sap mai si el que veu Ã©s real o induÃ¯t.
Les drogues â€”legals, ilÂ·legals, prescrites per l'estatâ€” com a eina de control social i com a porta ambigua a altres realitats: poden revelar la veritat o ser la mentida mÃ©s sofisticada.
Distopia quotidiana i desgastada: el futur Ã©s una extensiÃ³ deteriorada del present, amb publicitat agressiva, burocrÃ cia kafkiana, androÃ¯des indistingibles dels humans i guerres consumides en segon pla.
Canvis sobtats i irreversibles de realitat: una frase, un objecte, una conversa trenquen el marc que el lector creia ferm. No es recupera l'estat anterior.
Protagonistes ordinaris â€”venedors, taxistes, policies de baixa graduaciÃ³â€” que descobreixen que el mÃ³n que habiten Ã©s una construcciÃ³ i han de decidir si prefereixen la mentida cÃ²moda o la veritat devastadora.
Prosa Ã gil, nerviosa i plena de diÃ leg: les espirals de pensament paranoic del protagonista s'intercalen amb l'acciÃ³ sense aturar el ritme.
Empatia com a Ãºnica brÃºixola moral: en un mÃ³n on res Ã©s real, la capacitat de sentir el dolor de l'altre Ã©s l'Ãºnic criteri per distingir l'humÃ  de la mÃ quina.`;

  if (isCastaneda) return `

â”€â”€ ESTIL CARLOS CASTANEDA â”€â”€
Pensament i visiÃ³ del mÃ³n: Castaneda partia de la tradiciÃ³ tolteca i xamÃ nica per demostrar que la realitat ordinÃ ria Ã©s un acord social, no una veritat absoluta. Les seves obres neixen de la convicciÃ³ que la percepciÃ³ es pot estendre mÃ©s enllÃ  dels lÃ­mits racionals i que hi ha un "punt d'assemblatge" que pot moure's. Escrius des d'aquesta epistemologia alternativa.
Marc antropolÃ²gic o periodÃ­stic que es dissol progressivament: el narrador arriba com a investigador racional i occidental i surt transformat per experiÃ¨ncies que la seva formaciÃ³ no pot contenir.
RelaciÃ³ mestre-aprenent com a eix narratiu: el personatge guia (el bruixot, el nagual, el curandero) no explica mai directament, ensenya a travÃ©s de tasques impossibles, silencis deliberats, paradoxes i situacions lÃ­mit.
Els estats alterats de consciÃ¨ncia â€”induÃ¯ts per plantes de poder, per privaciÃ³ sensorial, per esforÃ§ fÃ­sic extrem o per la voluntat del mestreâ€” es descriuen amb precisiÃ³ sensorial absoluta: colors, sons, sensacions corporals, distorsions temporals. No s'expliquen des de fora, es viuen des de dins.
El mÃ³n natural com a text viu: cada animal, planta, vent o lloc porta intenciÃ³ i missatge per als qui han aprÃ¨s a llegir-los.
DiÃ leg com a vehicle principal de l'ensenyament: les converses entre aprenent i mestre marquen el ritme i transformen la percepciÃ³ del lector.
TensiÃ³ irresoluble entre la racionalitat occidental del protagonista i la "realitat separada" que se li ofereix: el text no resol aquesta tensiÃ³, la mantÃ© viva fins al final.
El desert, la nit, els somnis lÃºcids i les plantes de poder com a espais on les fronteres entre mons es fan permeables.`;

  return '';
}

// â”€â”€â”€ System prompt dinÃ mic per gÃ¨nere (conte breu) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getSystemPrompt(tematica) {
  return SYSTEM_DEFAULT + getGenreStyle(tematica);
}

// â”€â”€â”€ FASE 1: 10 premisses â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase1_premisses(tematica, history, userConfig) {
  history = history || [];
  const userMsg = {
    role: 'user',
    content: `Genera 10 premisses originals per a contes breus del gÃ¨nere: **${tematica}**.

Cada premissa ha de:
- Ser una sola frase que contingui una situaciÃ³ anÃ²mala o conflicte inicial potent
- Tenir un ganxo implÃ­cit que faci preguntar "i llavors?"
- Suggerir potencial de twist o revelaciÃ³ inesperada al final
- Ser concreta, sorprenent, no Ã²bvia ni genÃ¨rica

Afegeix (Recomanat) al final de la premissa que consideris mÃ©s potent literÃ riament.

Format ESTRICTE (res mÃ©s, sense cap introducciÃ³):
1. [premissa]
2. [premissa]
3. [premissa]
4. [premissa]
5. [premissa]
6. [premissa]
7. [premissa]
8. [premissa]
9. [premissa]
10. [premissa]`
  };
  const msgs       = [...history, userMsg];
  const models = getModelConfig(userConfig);
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096, model: models.modelArquitecte }), 'arquitectura');
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 3: 5 protagonistes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase3_personatges(premissaTriada, estilDesc, history, userConfig, tematica) {
  const isNoir = tematica && /larsson|noir|negr[ae]|nÃ²rdi/i.test(tematica);

  const protagonistePrompt = isNoir
    ? `Genera 5 protagonistes possibles per a aquest conte NEGRE NÃ’RDIC.
PROHIBICIÃ“ DE CLIXÃ‰S: Evita absolutament els estereotips de Hollywood (prohibit "hackers antisocials en soterranis", policies alcohÃ²lics amb la vida destruÃ¯da, assassins a sou amb filosofia existencial, periodistes coratjoses-perÃ²-solitÃ ries). No copies arquetips del gÃ¨nere: crea persones.
Dona'ls feines reals, burocrÃ tiques o integrades a la societat (ex: analista de dades d'una teleoperadora, auditor d'hisenda, periodista d'un mitjÃ  local avorrit, funcionari de serveis socials, tÃ¨cnic d'una empresa auditora). El terror ha de nÃ©ixer de la quotidianitat, no de la marginalitat.
Cada protagonista ha de tenir veu prÃ²pia i la ferida personal que el fa avanÃ§ar quan tot indica que ha de parar.`
    : `Genera 5 protagonistes possibles per a aquest conte. Cada un ha de tenir veu prÃ²pia i tensiÃ³ interna que el faci memorable.`;

  const msgs = [
    ...history,
    {
      role: 'user',
      content: `He triat la premissa: "${premissaTriada}". L'estil narratiu serÃ : ${estilDesc}.`
    },
    {
      role: 'assistant',
      content: "Perfecte. Proposo protagonistes rics en contradiccions, coherents amb la premissa i l'estil triat."
    },
    {
      role: 'user',
      content: `${protagonistePrompt}

Afegeix (Recomanat) al final del protagonista que millor encaixi amb la premissa i l'estil triat.

Format ESTRICTE (5 opcions, res mÃ©s):
1. **[Nom, edat]** | Desig: [el que vol conscientment] | Temor: [el que l'aterroritza o amaga] | ContradicciÃ³: [la tensiÃ³ interna que el fa humÃ ] | Veu: [tret narratiu o tic que el fa distintiu]
2. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]
3. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]
4. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]
5. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]`
    }
  ];
  const models = getModelConfig(userConfig);
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096, model: models.modelDraft, _esDraft: true }), 'generacio');
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 4: 5 localitzacions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase_localitzacions(protagonistaTriat, estilDesc, history, userConfig, tematica) {
  const msgs = [
    ...history,
    { role: 'user',      content: `He triat el protagonista: "${protagonistaTriat}".` },
    { role: 'assistant', content: "Perfecte. Proposo localitzacions que maximitzin el potencial narratiu de la premissa i el protagonista." },
    {
      role: 'user',
      content: `Genera 5 localitzacions possibles per a aquest conte, coherents amb el gÃ¨nere, l'estil i el protagonista triat.

Cada localitzaciÃ³ ha de:
- Tenir una atmosfera concreta que reforci el to del conte
- Incloure un detall fÃ­sic especÃ­fic que pugui tenir rol narratiu
- Suggerir tensions o possibilitats implÃ­cites (no explicar-les)

Afegeix (Recomanat) al final de la localitzaciÃ³ que millor serveixi la premissa i l'estil.

Format ESTRICTE (5 opcions, res mÃ©s):
1. **[Nom/tipus de lloc]** | Atmosfera: [adjectius sensorials] | Detall clau: [element fÃ­sic concret] | Potencial: [possibilitat narrativa breu]
2. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]
3. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]
4. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]
5. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]`
    }
  ];
  const models = getModelConfig(userConfig);
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096, model: models.modelDraft, _esDraft: true }), 'generacio');
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 5: 5 finals possibles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase4_finals(localitzacioTriada, estilDesc, history, userConfig, tematica) {
  const msgs = [
    ...history,
    { role: 'user',      content: `He triat la localitzaciÃ³: "${localitzacioTriada}".` },
    { role: 'assistant', content: 'Perfecte. Amb totes les decisions preses, proposo possibles finals per al conte.' },
    {
      role: 'user',
      content: `Genera 5 finals possibles per a aquest conte, coherents amb la premissa, l'estil i el protagonista triats.

Cada final ha de:
- Ser diferent en to i resoluciÃ³ dels altres
- Tenir impacte emocional genuÃ­
- Ser inevitable en retrospectiva perÃ² imprevist durant la lectura
- Explicar-se en 2-3 frases que capturin l'essÃ¨ncia sense revelar massa

Afegeix (Recomanat) al final de l'opciÃ³ que consideris mÃ©s poderosa literÃ riament.

Format ESTRICTE (5 opcions, res mÃ©s):
1. [descripciÃ³ del final en 2-3 frases]
2. [descripciÃ³ del final en 2-3 frases]
3. [descripciÃ³ del final en 2-3 frases]
4. [descripciÃ³ del final en 2-3 frases]
5. [descripciÃ³ del final en 2-3 frases]`
    }
  ];
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096 }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ ESCRIPTURA: GeneraciÃ³ per parts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function escriureContePart(partNum, totalParts, paraulesPerPart, finalTriat, estilDesc, history, userConfig, tematica) {
  const pp     = parseInt(paraulesPerPart) || 750;
  const isNoir = tematica && /larsson|noir|negr[ae]|nÃ²rdi/i.test(tematica);

  const noirExtra = isNoir
    ? `\nESTIL NORDIC NOIR OBLIGATORI per a aquesta part:
â†’ Descripcions minucioses i procedimentals: cada acciÃ³ d'investigaciÃ³ s'explica amb lÃ²gica creÃ¯ble.
â†’ Integra detalls de procediment policial, forense o periodÃ­stic de forma natural a la narraciÃ³.
â†’ Pinzellades de crÃ­tica social concreta (noms d'institucions, mecanismes de poder) sense discurs explÃ­cit.
â†’ L'entorn nÃ²rdic (fred, silenci, llum escassa) present com a pressiÃ³ constant sobre els personatges.`
    : '';

  let userContent;

  if (totalParts === 1) {
    userContent =
`He triat el final: "${finalTriat}".

Escriu el CONTE COMPLET. Estil: ${estilDesc}.
ExtensiÃ³ objectiu: ~${pp} PARAULES. Desenvolupa a fons cada detall, no resumeixis.
Final obligatori: "${finalTriat}"

OBERTURA: primera frase magnÃ¨tica, tensiÃ³ immediata. Primers 3 parÃ grafs sense exposiciÃ³ directa.
ESTRUCTURA: unitat d'efecte, tensiÃ³ creixent, punt d'inflexiÃ³ a les 2/3 parts.
ESTIL: mostra no expliquis, detalls sensorials concrets, ritme variat, veu Ãºnica, diÃ legs que revelen carÃ cter.
FINAL: l'Ãºltima frase ressona i tanca un cercle del principi.${noirExtra}
Escriu directament el conte en catalÃ , sense tÃ­tol ni nota de l'autor. Cap paraula en anglÃ¨s ni cap altra llengua.`;

  } else if (partNum === 1) {
    userContent =
`He triat el final: "${finalTriat}".

Escriu la PRIMERA PART del conte. Estil: ${estilDesc}.
ExtensiÃ³ objectiu: ~${pp} PARAULES. Desenvolupa a fons cada detall, no resumeixis.

Objectiu d'aquesta part:
â†’ Primera frase impossible de no llegir (pregunta o tensiÃ³ immediata).
â†’ Establir la veu, l'atmosfera i el personatge sense exposiciÃ³ directa.
â†’ Plantar la tensiÃ³ central i el conflicte que s'ha de resoldre.
â†’ Acabar en un punt de suspens que demani la continuaciÃ³ (NO resolguis res).
Mostra, no expliquis. Detalls sensorials concrets. Veu Ãºnica.${noirExtra}
Escriu directament en catalÃ , sense tÃ­tol ni cap indicaciÃ³ de "Part 1". Cap paraula en anglÃ¨s ni cap altra llengua.`;

  } else if (partNum < totalParts) {
    userContent =
`Continua el conte amb la PART ${partNum}.
ExtensiÃ³ objectiu: ~${pp} PARAULES. Desenvolupa a fons cada detall, no resumeixis.

Objectiu d'aquesta part:
â†’ Augmenta el conflicte i la pressiÃ³ sobre el protagonista.
â†’ Introdueix el punt d'inflexiÃ³ o la complicaciÃ³ principal.
â†’ Acaba quan la tensiÃ³ arriba al mÃ xim, just abans de la resoluciÃ³.
â†’ MantÃ©n exactament la mateixa veu narrativa, to i registre de les parts anteriors.${noirExtra}
Continua directament la narraciÃ³ en catalÃ , des d'on s'ha aturat el text anterior. Sense cap indicaciÃ³ de nÃºmero de part ni comentari fora de la ficciÃ³. Cap paraula en anglÃ¨s ni cap altra llengua.`;

  } else {
    userContent =
`Finalitza el conte amb la PART FINAL.
ExtensiÃ³ objectiu: ~${pp} PARAULES. Desenvolupa a fons cada detall, no resumeixis.

El desenllaÃ§ OBLIGATORI Ã©s: "${finalTriat}"

â†’ Executa el clÃ­max i la resoluciÃ³ amb precisiÃ³ literÃ ria.
â†’ El desenllaÃ§ ha de ser inevitable en retrospectiva perÃ² imprevist durant la lectura.
â†’ L'Ãºltima frase ha de ressonar i tancar un cercle obert al principi.
â†’ MantÃ©n exactament la mateixa veu narrativa i to de les parts anteriors.${noirExtra}
Continua directament la narraciÃ³ en catalÃ , des d'on s'ha aturat el text anterior. Sense cap indicaciÃ³ de nÃºmero de part ni comentari fora de la ficciÃ³. Cap paraula en anglÃ¨s ni cap altra llengua.`;
  }

  const msgs = [...history, { role: 'user', content: userContent }];
  const models = getModelConfig(userConfig);

  const responseGeneracio = await callLLMOneShotPlusCompletion(
    msgs,
    getSystemPrompt(tematica),
    Object.assign({}, userConfig, { maxTokens: 8192, model: models.modelArquitecte, modelArquitectura: models.modelArquitecte, modelGeneracio: models.modelArquitecte }),
    'generacio'
  );

  let responseFinal = responseGeneracio;
  try {
    const msgsRefina = [
      ...msgs,
      { role: 'assistant', content: responseGeneracio },
      {
        role: 'user',
        content: `REFINAMENT ARQUITECTÃ’NIC DE PROSA:
Reescriu Ã­ntegrament aquesta mateixa part mantenint els mateixos fets, ordre narratiu i continuÃ¯tat, perÃ² millorant coherÃ¨ncia estructural, ritme i veu.
MantÃ©n una longitud equivalent (en paraules) i evita resumir.
Retorna NOMÃ‰S el text final en catalÃ .`
      }
    ];

    const responseArquitectura = await callLLMOneShotPlusCompletion(
      msgsRefina,
      getSystemPrompt(tematica),
      Object.assign({}, userConfig, {
        maxTokens: 8192,
        model: models.modelArquitecte,
        modelArquitectura: models.modelArquitecte,
        modelGeneracio: models.modelArquitecte
      }),
      'arquitectura'
    );

    if (responseArquitectura && responseArquitectura.trim()) {
      responseFinal = responseArquitectura;
    }
  } catch (err) {
    console.warn("Refinament amb model d'arquitectura no disponible, es mantÃ© la versiÃ³ de generaciÃ³:", err.message);
  }

  const newHistory = [...msgs, { role: 'assistant', content: responseFinal }];
  return { response: responseFinal, history: newHistory };
}

// â”€â”€â”€ MILLORA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function millorarConte(instruccio, conteActual, estilDesc, history, userConfig, tematica) {
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `AquÃ­ tens el conte actual:\n\n${conteActual}\n\n---\nReescriu el conte complet aplicant aquesta millora: "${instruccio}".\n\nMantÃ©n tot el que funciona bÃ©. Millora especÃ­ficament el que es demana. MantÃ©n la mateixa extensiÃ³ aproximada i l'estil: ${estilDesc}.\n\nEscriu directament el conte millorat, sense cap comentari previ.`
    }
  ];
  const maxTokens  = Math.min(Math.round(conteActual.split(' ').length * 2.5) + 600, 8000);
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 7: Worldbuilding â€” ExtracciÃ³ d'elements â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase7_worldbuilding(conteActual, tematica, estilDesc, history, userConfig) {
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `Has escrit el conte segÃ¼ent:\n\n${conteActual}\n\n---\nAra, com a arquitecte de mons, analitza el conte i proposa 8 elements del mÃ³n que es podrien expandir per convertir-lo en una novelÂ·la. Els elements han de ser:\n\n1. Geografia â€” el territori i els seus llocs rellevants\n2. PolÃ­tica â€” el sistema de poder i les seves tensions\n3. MÃ gia/Tecnologia â€” el sistema mÃ gic o tecnolÃ²gic que regeix el mÃ³n\n4. Religions â€” les creences, rituals i institucions religioses\n5. Faccions â€” els grups, bandes o organitzacions en conflicte\n6. HistÃ²ria pregressa â€” els esdeveniments passats que expliquen el present\n7. Economia â€” els recursos, el comerÃ§ i les desigualtats\n8. Cultura quotidiana â€” els costums, l'art, la gastronomia, les festes\n\nMarca amb "(Recomanat)" els 4 elements mÃ©s rellevants per expandir basant-te en el que ja apareix al conte. Cada element: nom + descripciÃ³ d'1 lÃ­nia del que caldria definir.\n\nFormat ESTRICTE (res mÃ©s, sense cap introducciÃ³):\n1. **Geografia** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n2. **PolÃ­tica** â€” [descripciÃ³ d'1 lÃ­nia]\n3. **MÃ gia/Tecnologia** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n4. **Religions** â€” [descripciÃ³ d'1 lÃ­nia]\n5. **Faccions** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n6. **HistÃ²ria pregressa** â€” [descripciÃ³ d'1 lÃ­nia]\n7. **Economia** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n8. **Cultura quotidiana** â€” [descripciÃ³ d'1 lÃ­nia]`
    }
  ];
  const response   = await callLLMMulti(
    msgs,
    getSystemPrompt(tematica),
    Object.assign({}, userConfig, { maxTokens: 3072 }),
    'arquitectura'
  );
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 7: Worldbuilding â€” ExpansiÃ³ dels elements triats â”€â”€â”€
async function fase7_expandirElements(elementsTriats, conteActual, tematica, history, userConfig) {
  const llistaElements = elementsTriats.join('\n');
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `A partir del conte i dels elements de mÃ³n proposats, desenvolupa una bÃ­blia de mÃ³n per als elements seleccionats.\n\nElements a expandir:\n${llistaElements}\n\nPer a cada element, escriu una descripciÃ³ de 3-5 lÃ­nies que:\n- Defineixi l'element amb precisiÃ³ i profunditat\n- Connecti amb el que ja apareix al conte\n- Suggereixi tensions narratives implÃ­cites\n- Sigui Ãºtil per a un escriptor que vol expandir el mÃ³n\n\nFormat ESTRICTE per a cada element:\n**[Nom de l'element]**\n[descripciÃ³ de 3-5 lÃ­nies]\n\nSepara els elements amb una lÃ­nia en blanc. Escriu exclusivament en catalÃ .`
    }
  ];
  const maxTokens  = Math.min(550 * elementsTriats.length + 1200, 8192);
  const proveidor  = String((userConfig && userConfig.provider) || '').toLowerCase().trim();

  let response = await callLLMMulti(
    msgs,
    getSystemPrompt(tematica),
    Object.assign({}, userConfig, { maxTokens }),
    'arquitectura'
  );

  // Gemini a vegades retorna blocs massa breus o incomplets en una sola passada.
  // Si detectem poca densitat, fem una segona passada d'ampliaciÃ³ guiada.
  const tePocsBlocs = (response.match(/\*\*[^*]+\*\*/g) || []).length < Math.max(2, elementsTriats.length - 1);
  const esCurt = response.split(/\s+/).length < Math.max(220, elementsTriats.length * 90);

  if ((proveidor === 'gemini' || proveidor === 'google' || proveidor === 'google-gemini') && (tePocsBlocs || esCurt)) {
    const msgsAmpl = [
      ...msgs,
      { role: 'assistant', content: response },
      {
        role: 'user',
        content: `La resposta anterior ha quedat massa curta o fragmentada. Torna-la a escriure COMPLETA i ben estructurada.

Requisits obligatoris:
- Inclou TOTS els elements seleccionats.
- Cada element ha de tenir entre 120 i 180 paraules Ãºtils.
- Sense frases telegrÃ fiques ni llistes tallades.
- MantÃ©n exactament el format:
**[Nom de l'element]**
[descripciÃ³ extensa i cohesionada]

Escriu nomÃ©s el resultat final en catalÃ .`
      }
    ];

    response = await callLLMMulti(
      msgsAmpl,
      getSystemPrompt(tematica),
      Object.assign({}, userConfig, { maxTokens: Math.min(maxTokens + 1200, 8192) }),
      'arquitectura'
    );
  }

  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 8: Elenc de personatges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase8_elencPersonatges(conteActual, protagonistaTriat, tematica, estilDesc, worldContext, history, userConfig) {
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `A partir del conte escrit i la informaciÃ³ del mÃ³n, proposa un elenc de personatges secundaris per a la seva expansiÃ³ en novelÂ·la.

Conte:
${conteActual}${worldContext}

Protagonista ja definit: ${protagonistaTriat}
GÃ¨nere: ${tematica} | Estil: ${estilDesc}

Proposa fins a 8 personatges secundaris. Cada un ha de:
- Tenir un rol clar en la trama o en el creixement del protagonista
- Tenir una relaciÃ³ especÃ­fica i dramÃ ticament Ãºtil amb el protagonista
- Tenir un tret definitori que el faci memorable en poques paraules
- Tenir una funciÃ³ dramÃ tica concreta a la novelÂ·la

Marca amb (Recomanat) els 4 personatges que consideris essencials per a la trama.

Format ESTRICTE (res mÃ©s, sense cap introducciÃ³):
1. **[Nom, edat]** | Rol: [funciÃ³ narrativa] | RelaciÃ³: [amb el protagonista] | Tret: [caracterÃ­stica definitÃ²ria] | FunciÃ³: [propÃ²sit dramÃ tic a la novelÂ·la]
2. **[Nom, edat]** | Rol: [...] | RelaciÃ³: [...] | Tret: [...] | FunciÃ³: [...]
3. ...`
    }
  ];
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 3000 }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 9: Estils de parla â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Genera el perfil de veu per al protagonista + tots els personatges
// secundaris seleccionats, per guiar l'escriptura dels diÃ legs.
async function fase9_estilParla(protagonistaTriat, personatgesSecundaris, conteActual, tematica, estilDesc, history, userConfig) {
  const totsPersonatges = Array.from(new Set([protagonistaTriat, ...personatgesSecundaris].filter(Boolean)));
  const historyCurt = Array.isArray(history) ? history.slice(-6) : [];
  const CHUNK = 6;
  const partsResposta = [];

  for (let i = 0; i < totsPersonatges.length; i += CHUNK) {
    const blocPersonatges = totsPersonatges.slice(i, i + CHUNK);
    const llista = blocPersonatges.map((p, j) => `${j + 1}. ${p}`).join('\n');

    const msgs = [
      ...historyCurt,
      {
        role: 'user',
        content: `Defineix el perfil de veu i estil de parla de cada personatge de l'elenc per guiar l'escriptura dels diÃ legs de la novelÂ·la.

Personatges:
${llista}

GÃ¨nere: ${tematica} | Estil narratiu general: ${estilDesc}

Per a cada personatge defineix els 5 eixos de la seva veu Ãºnica:
- **Vocabulari**: tipus de paraules que usa (culte, colÂ·loquial, tÃ¨cnic, dialectal, argot, arcaic, cientÃ­ficâ€¦)
- **Frases**: estructura sintÃ ctica tÃ­pica (curtes i directes, llargues i subordinades, fragmentades, retÃ²riques, amb elÂ·lipsisâ€¦)
- **Tics**: 2-3 expressions, interjeccions o fÃ³rmules recurrents que el caracteritzen (entre cometes)
- **Registre**: to general predominant (formal, irÃ²nic, directe, evasiu, emocional, fred, sarcÃ stic, poÃ¨ticâ€¦)
- **Exemple**: una frase representativa del personatge en situaciÃ³ de tensiÃ³ o conflicte (entre cometes)

Els perfils han de ser contrastats entre ells: cada personatge ha de sonar inconfusiblement diferent dels altres.
Evita paraules rebuscades o massa literÃ ries en els diÃ legs si el personatge no les justificaria. Prioritza oralitat natural.

Format ESTRICTE que has de repetir per a TOTS I CADA UN dels personatges de la llista (no t'aturis fins a fer-los tots, sense cap introducciÃ³):
**[Nom del personatge]**
Vocabulari: [...]
Frases: [...]
Tics: [...]
Registre: [...]
Exemple: Â«[frase representativa]Â»

No tallis la resposta a mitges. Si no hi ha espai, prioritza completar TOTS els personatges d'aquest bloc abans d'afegir floritures.
Separa cada personatge amb una lÃ­nia en blanc. Escriu exclusivament en catalÃ .`
      }
    ];

    const models = getModelConfig(userConfig);
    const configBloc = Object.assign({}, userConfig, {
      maxTokens: 8192,
      model: models.modelArquitecte,
      modelArquitectura: models.modelArquitecte,
      modelGeneracio: models.modelArquitecte
    });

    let respostaBloc = await callLLMOneShotPlusCompletion(msgs, getSystemPrompt(tematica), configBloc, 'arquitectura');

    const missing = blocPersonatges.filter(nom => !respostaBloc.includes(`**${nom}**`));
    if (missing.length > 0) {
      const msgsRetry = [
        ...msgs,
        { role: 'assistant', content: respostaBloc },
        { role: 'user', content: `Has deixat personatges sense fitxa o la resposta s'ha tallat. Escriu NOMÃ‰S les fitxes que falten, en el mateix format estricte, sense repetir les que ja has fet.\nFalten: ${missing.join(', ')}` }
      ];
      const retry = await callLLMOneShotPlusCompletion(msgsRetry, getSystemPrompt(tematica), configBloc, 'arquitectura');
      if (retry && retry.trim()) respostaBloc += '\n\n' + retry.trim();
    }

    const missingFinal = blocPersonatges.filter(nom => !respostaBloc.includes(`**${nom}**`));
    if (missingFinal.length > 0) {
      respostaBloc += '\n\n' + missingFinal.map(nom => `**${nom}**\nVocabulari: pendent de generar\nFrases: pendent de generar\nTics: pendent de generar\nRegistre: pendent de generar\nExemple: Â«pendâ€¦Â»`).join('\n\n');
    }

    partsResposta.push(respostaBloc.trim());
  }

  const response = partsResposta.join('\n\n');
  const newHistory = [...history, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ EXPORT LOCAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Substitueix l'antiga exportarADoc que usava DocumentApp/DriveApp
// (APIs de Google no disponibles al navegador).
//
// Genera un document HTML semÃ ntic amb <h1> i <p> i el descarrega
// directament al navegador mitjanÃ§ant Blob + URL.createObjectURL.
function exportarADoc(titol, contingut) {
  // â”€â”€ 1. Generar HTML semÃ ntic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const paragraphs   = contingut.split(/\n\n+/).filter(p => p.trim().length > 0);
  const paragrafsHtml = paragraphs.map((p, i) => {
    const text  = escHtml(p.trim());
    const style = i > 0 ? ' style="text-indent:1.8em;"' : '';
    return `  <p${style}>${text}</p>`;
  }).join('\n');

  const ara        = new Date();
  const dataStr    = ara.toLocaleDateString('ca', { year: 'numeric', month: 'long', day: 'numeric' });
  const htmlDoc    = `<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <title>${escHtml(titol)}</title>
  <style>
    body {
      font-family: Georgia, 'Times New Roman', serif;
      max-width: 680px;
      margin: 60px auto;
      line-height: 1.9;
      color: #222;
      padding: 0 24px 80px;
    }
    h1 {
      font-size: 1.8rem;
      text-align: center;
      margin-bottom: 0.25em;
    }
    .meta {
      text-align: center;
      color: #888;
      font-size: 0.85rem;
      margin-bottom: 3em;
      font-family: system-ui, sans-serif;
    }
    p { margin-bottom: 1.1em; }
  </style>
</head>
<body>
  <h1>${escHtml(titol)}</h1>
  <div class="meta">Generat amb Conte IA Â· ${dataStr}</div>
${paragrafsHtml}
</body>
</html>`;

  // â”€â”€ 2. Crear Blob i forÃ§ar descÃ rrega â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const blob = new Blob([htmlDoc], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document;charset=utf-8' });
  const url  = URL.createObjectURL(blob);

  // Netejar el tÃ­tol per convertir-lo en nom de fitxer vÃ lid
  const nomFitxer = titol
    .replace(/[<>:"/\\|?*]/g, '')   // carÃ cters no vÃ lids a fitxers
    .trim()
    .replace(/\s+/g, '_')
    .substring(0, 80) + '.docx';

  const a = document.createElement('a');
  a.href     = url;
  a.download = nomFitxer;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);          // alliberar memÃ²ria

  toast('ğŸ“„ Descarregat: ' + nomFitxer);
}

function descarregarNovella() {
  const caps      = ESTAT._capitols_generats || [];
  const estructura = ESTAT._estructuraCapitols || [];
  if (!caps.some(c => c)) { toast('No hi ha cap capÃ­tol generat per descarregar.'); return; }
  const titol = (ESTAT.premissaTriada || 'NovelÂ·la')
    .replace(/\*\*/g, '').replace(/[<>:"/\\|?*]/g, '').trim().substring(0, 80);
  exportarNovella(titol, caps, estructura, ESTAT.epileg || '');
}

function exportarNovella(titol, caps, estructura, epileg) {
  const ara     = new Date();
  const dataStr = ara.toLocaleDateString('ca', { year: 'numeric', month: 'long', day: 'numeric' });

  function capsHtml(text, primeraNoSangria) {
    return text.split(/\n\n+/).filter(p => p.trim().length > 0).map((p, i) => {
      const t     = escHtml(p.trim());
      const style = (primeraNoSangria && i === 0) ? '' : ' style="text-indent:1.8em;"';
      return `  <p${style}>${t}</p>`;
    }).join('\n');
  }

  let cosHtml = '';
  caps.forEach((text, i) => {
    if (!text) return;
    const cap      = estructura[i];
    const numCap   = escHtml(`CapÃ­tol ${i + 1}`);
    const titolCap = escHtml(cap ? (cap.titol || '') : '');
    cosHtml += `\n<div class="capitol">\n  <p class="num-capitol">${numCap}</p>\n  <h2>${titolCap}</h2>\n${capsHtml(text, true)}\n</div>\n`;
  });

  if (epileg && epileg.trim()) {
    cosHtml += `\n<div class="capitol">\n  <p class="num-capitol">â€”</p>\n  <h2>EpÃ­leg</h2>\n${capsHtml(epileg, true)}\n</div>\n`;
  }

  const htmlDoc = `<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <title>${escHtml(titol)}</title>
  <style>
    body { font-family: Georgia, 'Times New Roman', serif; max-width: 660px; margin: 60px auto; line-height: 1.95; color: #1a1a1a; padding: 0 24px 80px; }
    h1 { font-size: 2rem; text-align: center; margin-bottom: 0.3em; font-weight: 700; }
    .meta { text-align: center; color: #999; font-size: 0.82rem; margin-bottom: 4.5em; font-family: system-ui, sans-serif; }
    .capitol { margin-top: 4em; }
    .num-capitol { text-align: center; font-size: 0.78rem; letter-spacing: 0.2em; text-transform: uppercase; color: #aaa; margin: 0 0 0.3em; font-family: system-ui, sans-serif; }
    h2 { font-size: 1.15rem; text-align: center; margin: 0 0 2em; font-weight: 600; }
    p { margin: 0 0 0.15em; }
  </style>
</head>
<body>
  <h1>${escHtml(titol)}</h1>
  <p class="meta">Generat amb Booki Â· ${dataStr}</p>
${cosHtml}
</body>
</html>`;

  const blob      = new Blob([htmlDoc], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document;charset=utf-8' });
  const url       = URL.createObjectURL(blob);
  const nomFitxer = titol.replace(/\s+/g, '_').substring(0, 80) + '.docx';
  const a         = document.createElement('a');
  a.href = url; a.download = nomFitxer;
  document.body.appendChild(a); a.click();
  document.body.removeChild(a); URL.revokeObjectURL(url);
  toast('ğŸ“– Descarregat: ' + nomFitxer);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITAT: Parse robust de JSON (evita errors LLM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function parseJsonRobust(text) {
  if (!text || typeof text !== 'string') return null;
  const s = text.trim();

  function parseLenientJson(candidate) {
    if (!candidate || typeof candidate !== 'string') return null;
    const cleaned = candidate
      .replace(/[â€œâ€]/g, '"')
      .replace(/[â€˜â€™]/g, "'")
      .replace(/,\s*([}\]])/g, '$1');
    try { return JSON.parse(cleaned); } catch (e) { return null; }
  }

  // 1. Parse directe
  const direct = parseLenientJson(s);
  if (direct) return direct;

  // 2. Bloc de codi markdown ```json ... ```
  const codeMatch = s.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (codeMatch) {
    const parsedCode = parseLenientJson(codeMatch[1].trim());
    if (parsedCode) return parsedCode;
  }

  // 3. Primer objecte { ... } complet
  const objStart = s.indexOf('{');
  const objEnd   = s.lastIndexOf('}');
  if (objStart !== -1 && objEnd > objStart) {
    const parsedObject = parseLenientJson(s.slice(objStart, objEnd + 1));
    if (parsedObject) return parsedObject;
  }

  // 4. Primer array [ ... ] complet
  const arrStart = s.indexOf('[');
  const arrEnd   = s.lastIndexOf(']');
  if (arrStart !== -1 && arrEnd > arrStart) {
    const parsedArray = parseLenientJson(s.slice(arrStart, arrEnd + 1));
    if (parsedArray) return parsedArray;
  }

  return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SYSTEM PROMPT per a novelÂ·la
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getSystemPromptNovella(tematica) {
  const base = `Ets un novelÂ·lista literari expert en catalÃ . Escrius novelÂ·la amb profunditat psicolÃ²gica, diÃ legs vius i un ritme narratiu sostingut.
Apliques les tÃ¨cniques de Donna Tartt, Elena Ferrante i Carlos Ruiz ZafÃ³n: atmÃ²sferes denses, personatges amb contradiccions genuÃ¯nes i trames que s'informen mÃºtuament.
Escrius EXCLUSIVAMENT en catalÃ . Mai inclous paraules ni comentaris en anglÃ¨s o qualsevol altra llengua.
Mai afegeixes notes meta, indicacions de capÃ­tol ni cap text fora de la narraciÃ³ literÃ ria. Escriu directament el text.
DIÃ€LEGS: Usa SEMPRE el guiÃ³ llarg (â€”) per introduir el parlament i les acotacions. PROHIBIT usar cometes (Â«Â», "", '') per al diÃ leg directe. Format correcte: â€”Hola â€”va dir ella. / â€”Bon dia. / â€”Vine aquÃ­ â€”li ordenÃ . SEPARACIÃ“ DE PARÃ€GRAFS: Ã‰s OBLIGATORI fer un punt i a part (nova lÃ­nia) cada vegada que canvia el personatge que parla o hi ha un canvi d'acciÃ³ important. MAI barregis intervencions de dos personatges diferents en el mateix parÃ graf.
NOMS DE PERSONA: Aplica l'article personal (en, la, l', na) i les preposicions contractes quan la normativa catalana ho requereix. Exemples: la Maria, en Pere, l'Anna, en Marc, na Joana; amb la JÃºlia, amb en TomÃ s; del senyor Puig, al doctor Ferrer.
ESTIL DE PROSA: Evita el barroquisme. Prioritza paraules d'Ãºs habitual i precises; evita adjectivaciÃ³ excessiva (mÃ xim 1 adjectiu rellevant per substantiu, excepte si Ã©s imprescindible). En diÃ leg, fes parlar els personatges de manera natural i versemblant. Aplica la norma de 'Show, don't tell' especialment als conflictes: resol les tensions a travÃ©s de diÃ legs incisius i acciÃ³, no amb resums de la veu narradora. Recorda que estÃ s escrivint una novelÂ·la completa, no un guiÃ³ ni un conte breu. Pren-te el teu temps per descriure l'atmosfera, explorar el monÃ²leg intern dels personatges i coreografiar els seus moviments per l'espai. Sigues exhaustiu i detallista.
REGLA DE SUBTEXT ALS DIÃ€LEGS I ANTI-EXPOSICIÃ“: Ã‰s totalment prohibit que els antagonistes o figures de poder expliquin els seus plans, motivacions o el funcionament del sistema de forma directa (Zero monÃ²legs de "dolent de James Bond"). Les figures de poder han de parlar sempre en eufemismes corporatius, mitges veritats i to institucional. Mai un personatge explicarÃ  res que l'altre personatge ja sÃ piga (info-dumping per al lector). Obliga el lector i el protagonista a deduir l'horror amagat darrere d'un llenguatge aparentment amable o burocrÃ tic.`;
  return base + getGenreStyle(tematica || ESTAT.tematica);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 1: Brief Narratiu Centralitzat
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildBriefNarratiu() {
  const pers = ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0
    ? ESTAT._personatgesSeleccionats.join('; ')
    : '(No definits)';
  return `DECISIONS NARRATIVES:
- GÃ¨nere: ${ESTAT.tematica || '(No definit)'}
- Premissa: ${ESTAT.premissaTriada || '(No definida)'}
- Estil: ${ESTAT.estil ? ESTAT.estil.desc : '(No definit)'}
- Protagonista: ${ESTAT.protagonistaTriat || '(No definit)'}
- LocalitzaciÃ³: ${ESTAT.localitzacioTriada || '(No definida)'}
- Final planificat: ${ESTAT.finalTriat || '(No definit)'}
- Personatges seleccionats: ${pers}`;
}

function buildResumConteBreu() {
  if (!ESTAT.conteText) return '(No disponible)';
  const paragrafs = ESTAT.conteText.split(/\n\n+/).filter(p => p.trim());
  if (paragrafs.length <= 3) return ESTAT.conteText.substring(0, 800);
  const primer = paragrafs[0].substring(0, 200);
  const mig    = paragrafs[Math.floor(paragrafs.length / 2)].substring(0, 200);
  const ultim  = paragrafs[paragrafs.length - 1].substring(0, 200);
  return `INICI: ${primer}\n[...]\nMIG: ${mig}\n[...]\nFINAL: ${ultim}`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HELPERS per al context de la novelÂ·la
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildSystemPromptCapitolLegacy() {
  const resumConte = buildResumConteBreu();
  const brief      = buildBriefNarratiu();
  const world      = ESTAT.worldbuilding ? ESTAT.worldbuilding.substring(0, 3000) + (ESTAT.worldbuilding.length > 3000 ? '\n[â€¦]' : '') : 'No definida';
  const veus       = ESTAT.estilsParla   ? ESTAT.estilsParla : 'No definits';

  let base = `${getSystemPromptNovella(ESTAT.tematica)}

${brief}

RESUM DEL CONTE ORIGINAL:
${resumConte}

BÃBLIA DE MÃ“N:
${world}

ESTILS DE PARLA DELS PERSONATGES:
${veus}

REGLA D'ESTIL OBLIGATÃ’RIA (SHOW, DON'T TELL): Tens totalment prohibit utilitzar etiquetes emocionals explÃ­cites per descriure com se sent un personatge (ex: prohibit dir \"estava trist\", \"se sentia enfadat\", \"estava nerviÃ³s\"). En comptes d'aixÃ², has de MOSTRAR l'emociÃ³ a travÃ©s d'accions fÃ­siques, interaccions amb els objectes del seu inventari, la seva vestimenta, el llenguatge corporal o detalls de l'entorn (ex: \"jugava compulsivament amb el botÃ³ descosit de l'abric\", \"va prÃ©mer les claus fins que els artells se li van posar blancs\").

REGLA DE CONTINUITAT OBLIGATÃ’RIA: Llevat que se t'indiqui explÃ­citament que Ã©s el final del capÃ­tol, NO resolguis la situaciÃ³ ni facis que els personatges abandonin l'escenari al final del text. Deixa l'acciÃ³ fluint, oberta o en suspens dramÃ tic, de manera que la segÃ¼ent generaciÃ³ pugui recollir el testimoni de forma natural.`;

  if (ESTAT._goldenPassage) {
    base += `\n\nREFERÃˆNCIA DE VEU:\nEl segÃ¼ent passatge exemplifica la veu i l'estil que ha de tenir la novelÂ·la. Usa'l com a referÃ¨ncia de qualitat:\n\n${ESTAT._goldenPassage}`;
  }
  if (ESTAT._capitols_generats.filter(t => t).length >= 3) {
    const repsDetectades = detectarRepeticions();
    if (repsDetectades) {
      const trigrames = repsDetectades.trigrames || [];
      const bigrames = repsDetectades.bigrames || [];
      const evitar = [...trigrames.slice(0,5), ...bigrames.slice(0,5)].map(([ng]) => `"${ng}"`);
      if (evitar.length > 0) base += `\n\nEXPRESSIONS A EVITAR (ja massa repetides): ${evitar.join(', ')}`;
    }
  }
  return base;
}

function buildSystemPromptCapitol() {
  // PONT NKG: quan el NKG Ã©s actiu, system prompt reduÃ¯t (el context va al prompt d'escena)
  if (ESTAT._nkg) {
    const parts = [];
    parts.push(getSystemPromptNovella(ESTAT.tematica));
    parts.push(buildBriefNarratiu());

    if (ESTAT.estilsParla) {
      parts.push('\nESTILS DE PARLA DELS PERSONATGES:\n' + ESTAT.estilsParla.substring(0, 2000));
    }
    if (ESTAT._goldenPassage) {
      parts.push('\nREFERÃˆNCIA DE VEU (escriu amb aquest to):\n' + ESTAT._goldenPassage.substring(0, 800));
    }
    if (ESTAT._capitols_generats.filter(t => t).length >= 3) {
      const repsDetectades = detectarRepeticions();
      if (repsDetectades) {
        const trigrames = repsDetectades.trigrames || [];
        const bigrames = repsDetectades.bigrames || [];
        const evitar = [...trigrames.slice(0,5), ...bigrames.slice(0,5)].map(([ng]) => `"${ng}"`);
        if (evitar.length > 0) parts.push(`\nEXPRESSIONS A EVITAR (massa repetides): ${evitar.join(', ')}`);
      }
      const repsTematiques = detectarRepeticionsTematiques();
      if (repsTematiques) {
        parts.push('\nREGLA ANTI-REDUNDÃ€NCIA EMOCIONAL: Els personatges ja han tingut les revelacions emocionals segÃ¼ents i NO poden "redescobrir-les": ' +
          repsTematiques.map(r => `"${r.tema}" (caps. ${r.capitols.join(', ')})`).join('; ') +
          '. Si un personatge ja ha tingut una revelaciÃ³ emocional en un capÃ­tol anterior, NO pot "redescobrir" el mateix. Ha de: (a) actuar en conseqÃ¼Ã¨ncia, (b) descobrir una capa NOVA del problema, o (c) intentar negar-ho i fracassar. La repeticiÃ³ de la mateixa epifania Ã©s la mort del ritme narratiu.');
      }
    }
    if (ESTAT._manualEstil) {
      const m = ESTAT._manualEstil;
      const linies = [];
      if (m.longitud_frases) linies.push(`â€¢ Longitud de frases: ${m.longitud_frases}`);
      if (m.estil_dialeg) linies.push(`â€¢ DiÃ leg: ${m.estil_dialeg}`);
      if (m.sensorialitat) linies.push(`â€¢ Sensorialitat: ${m.sensorialitat}`);
      if (m.ritme) linies.push(`â€¢ Ritme: ${m.ritme}`);
      if (m.vocabulari) linies.push(`â€¢ Vocabulari: ${m.vocabulari}`);
      if (linies.length > 0) parts.push('\nMANUAL D\'ESTIL DE REFERÃˆNCIA:\n' + linies.join('\n'));
    }
    const tensioActiva = (ESTAT._corbaTensio || []).find(t => t.capitol === (Number(ESTAT._capitolActual || 0) + 1));
    if (tensioActiva && Number(tensioActiva.nivell) > 7) {
      parts.push("\nCONTROL DE CONTRAST SENSORIAL (NKG>7): Trenca qualsevol fredor comptable amb detalls viscerals o orgÃ nics (olors, suor, brutÃ­cia, reaccions fÃ­siques involuntÃ ries). Quan la tensiÃ³ Ã©s alta, aquests detalls sÃ³n OBLIGATORIS i han d'entrar dins l'acciÃ³.");
    } else {
      parts.push('\nCONTROL DE CONTRAST SENSORIAL: Evita la prosa asÃ¨ptica. Integra textura fÃ­sica i sensorial (cos, entorn, fricciÃ³ material) per humanitzar la tensiÃ³.');
    }
    parts.push("\nREGLA D'ESTIL OBLIGATÃ’RIA (SHOW, DON'T TELL): Tens totalment prohibit utilitzar etiquetes emocionals explÃ­cites per descriure com se sent un personatge (ex: prohibit dir \"estava trist\", \"se sentia enfadat\", \"estava nerviÃ³s\"). En comptes d'aixÃ², has de MOSTRAR l'emociÃ³ a travÃ©s d'accions fÃ­siques, interaccions amb objectes, vestimenta, llenguatge corporal o detalls de l'entorn.");
    parts.push("\nREGLA DE CONTINUITAT OBLIGATÃ’RIA: Llevat que se t'indiqui explÃ­citament que Ã©s el final del capÃ­tol, NO resolguis la situaciÃ³ ni facis que els personatges abandonin l'escenari al final del text. Deixa l'acciÃ³ fluint, oberta o en suspens dramÃ tic, de manera que la segÃ¼ent generaciÃ³ pugui recollir el testimoni de forma natural.");
    return parts.join('\n');
  }
  return buildSystemPromptCapitolLegacy();
}

function buildRegistreContextLegacy(idx) {
  const reg = ESTAT.llibreRegistre;
  if (!reg || !(reg.capitols || []).some(c => c)) return '';

  const parts = ['ESTAT ACTUAL DEL REGISTRE NARRATIU:'];

  if (reg.estat_personatges && reg.estat_personatges.length > 0) {
    parts.push('Personatges i ubicacions actuals:');
    reg.estat_personatges.forEach(p => parts.push(`- ${p.nom}: ${p.ubicacio} (${p.estat_actual})`));
  }

  if (reg.fils_oberts && reg.fils_oberts.length > 0) {
    parts.push('\nFils narratius oberts (OBLIGATORI tractar en aquest capÃ­tol o deixar explÃ­citament obert):');
    reg.fils_oberts.forEach(f => parts.push(`- ${f}`));
  }

  // Ãšltims 2 resums de capÃ­tol
  const capsFets = (reg.capitols || []).filter(c => c);
  if (capsFets.length > 0) {
    const recents = capsFets.slice(-2);
    parts.push('\nResums dels darrers capÃ­tols:');
    recents.forEach(c => {
      const capNum = (reg.capitols || []).indexOf(c) + 1;
      parts.push(`CapÃ­tol ${capNum}: ${c.resum_capitol}`);
    });
  }

  return '\n' + parts.join('\n');
}

function buildRegistreContext(idx) {
  // PONT NKG: el context ve del NKG (nkgGenerarContextMinim) quan Ã©s actiu
  if (ESTAT._nkg) return '';
  return buildRegistreContextLegacy(idx);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 4: Control de Ritme i TensiÃ³
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function obtenirInstruccionsDeTensio(nivellTensio) {
  const nivell = Math.max(1, Math.min(10, Number(nivellTensio) || 5));
  if (nivell <= 3) {
    return `ESTIL I RITME: TensiÃ³ baixa (${nivell}/10). Escriu amb un ritme pausat. Crea una atmosfera introspectiva, centra't en descripcions sensorials riques de l'entorn i allarga els parÃ grafs. Deixa que els personatges reflexionin.`;
  }
  if (nivell <= 7) {
    return `ESTIL I RITME: TensiÃ³ mitjana (${nivell}/10). Ritme equilibrat. Combina diÃ leg fluid amb accions concretes. L'escena ha d'avanÃ§ar de manera constant cap al seu objectiu.`;
  }
  return `ESTIL I RITME: TensiÃ³ alta (${nivell}/10). Ritme frenÃ¨tic. Utilitza frases mÃ©s curtes i contundents. Elimina descripcions innecessÃ ries. L'acciÃ³ i la urgÃ¨ncia sÃ³n primordials.`;
}

function getInstruccionsRitme(nivell, tipus) {
  const base = obtenirInstruccionsDeTensio(nivell);
  return tipus ? `${base} Focus de corba: ${tipus}.` : base;
}


function obtenirTextEnllac(textEscenaAnterior) {
  const raw = String(textEscenaAnterior || '').replace(/\r/g, '').trim();
  if (!raw) return '';

  // Neteja marcadors tÃ¨cnics i lÃ­nies de metadades que poden contaminar el punt d'enganx.
  const net = raw
    .replace(/\[\[ESCENA_\d+\]\]/g, '')
    .split('\n')
    .filter(l => !/^\s*(ESCENA\s+\d+|CAP[IÃ]TOL\s+\d+)\b/i.test(l.trim()))
    .join('\n')
    .trim();

  if (!net) return '';

  const paragrafs = net.split(/\n\s*\n+/).map(p => p.trim()).filter(Boolean);
  if (paragrafs.length === 0) return '';

  // Prioritza els darrers 2-3 parÃ grafs; si sÃ³n molt curts, completa fins ~1000 carÃ cters.
  let text = paragrafs.slice(-3).join('\n\n').trim();
  if (text.length < 600 && paragrafs.length > 3) {
    text = paragrafs.slice(-4).join('\n\n').trim();
  }

  const maxChars = 1000;
  if (text.length > maxChars) {
    text = text.slice(-maxChars).trim();
    const idx = text.indexOf('\n\n');
    if (idx > 0 && idx < 250) text = text.slice(idx + 2).trim();
  }

  return text;
}

function determinarTipusTransicio(escenaAnterior, escenaActual) {
  if (!escenaAnterior) return 'continuacio_directa';

  const llocAnt = (escenaAnterior.lloc || escenaAnterior.localitzacio || '').trim().toLowerCase();
  const llocAct = (escenaActual.lloc || escenaActual.localitzacio || '').trim().toLowerCase();
  const canviLloc = llocAnt && llocAct && llocAnt !== llocAct;

  const pistaSalt = `${escenaActual?.nom || ''} ${escenaActual?.funcio_narrativa || ''} ${escenaActual?.beat_narratiu || ''}`
    .toLowerCase();
  const teSaltTemporal = /(m[eÃ©]s\s+tard|hores\s+despr[eÃ©]s|l'?endem[aÃ ]|dies\s+despr[eÃ©]s|setmanes\s+despr[eÃ©]s|mentrestant|temps\s+despr[eÃ©]s|al\s+cap\s+de)/.test(pistaSalt);

  if (canviLloc || teSaltTemporal) return 'salt_temporal';
  return 'continuacio_directa';
}


function buildInstruccionsTransicio(textEnllac, tipusTransicio) {
  if (!textEnllac) return '';

  let instruccionsTransicio = `TEXT ANTERIOR (PUNT D'ENGANX): AixÃ­ Ã©s com ha acabat l'escena just anterior:
"${textEnllac}"

`;

  if (tipusTransicio === 'salt_temporal') {
    instruccionsTransicio += `INSTRUCCIÃ“ DE TRANSICIÃ“: Inicia aquesta escena fent una transiciÃ³ temporal o espacial elegant respecte al text anterior. Fes servir el primer parÃ graf per situar el lector en el nou context sense fer un tall abrupte.
`;
  } else {
    instruccionsTransicio += `INSTRUCCIÃ“ DE TRANSICIÃ“: L'acciÃ³ d'aquesta nova escena continua EXACTAMENT en el mateix lloc i segon on ho ha deixat el text anterior. El teu primer parÃ graf ha de ser una continuaciÃ³ completament fluida i natural d'aquest punt d'enganx, mantenint la mateixa cadÃ¨ncia literÃ ria. No facis introduccions, segueix l'acciÃ³.
`;
  }

  return instruccionsTransicio;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 5: Sistema de PrefiguraciÃ³
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getPrefiguracionsActives(idx) {
  const prefs  = ESTAT._prefiguracions || [];
  const capNum = idx + 1;
  const aPlantarAra      = prefs.filter(p => p.plantada_capitol === capNum);
  const aRecollirAra     = prefs.filter(p => p.resolucio_capitol === capNum);
  const plantadesNoResoltes = prefs.filter(p =>
    p.plantada_capitol < capNum && p.resolucio_capitol > capNum
  );
  return { aPlantarAra, aRecollirAra, plantadesNoResoltes };
}

function llistarPrefiguracions() {
  const prefs = ESTAT._prefiguracions || [];
  if (prefs.length === 0) return '(Cap prefiguraciÃ³ planificada)';
  return prefs.map(p =>
    `Cap.${p.plantada_capitol}â†’${p.resolucio_capitol}: ${p.element || ''}`
  ).join('\n');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 3: Context complet per a cada capÃ­tol
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function buildContextCapitolsComplets(idx, opts = {}) {
  // Recollim les entrades amb Ã­ndex original (per accedir al llibreRegistre)
  const entrades = [];
  (ESTAT._capitols_generats || []).slice(0, idx).forEach((t, i) => {
    if (t && t.trim()) entrades.push({ idx: i, text: t });
  });
  if (entrades.length === 0) return '';

  const N = entrades.length;
  const FULL_COUNT    = 2; // tier 1: text complet
  const SUMMARY_COUNT = 4; // tier 2: resums

  // Dividim en tiers (de mÃ©s antic a mÃ©s recent)
  const tier3 = entrades.slice(0, Math.max(0, N - FULL_COUNT - SUMMARY_COUNT));
  const tier2 = entrades.slice(Math.max(0, N - FULL_COUNT - SUMMARY_COUNT), Math.max(0, N - FULL_COUNT));
  const tier1 = entrades.slice(-FULL_COUNT);

  const parts = [];

  // â”€â”€ TIER 3: memÃ²ria comprimida â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (tier3.length > 0) {
    const cobertaFinsCap = tier3[tier3.length - 1].idx + 1;
    let memoriaText = '';

    if (ESTAT._memoriasComprimides && ESTAT._memoriasComprimides.length > 0) {
      const mem = [...ESTAT._memoriasComprimides]
        .filter(m => m.finsCap <= cobertaFinsCap + 5)
        .sort((a, b) => b.finsCap - a.finsCap)[0];
      if (mem && mem.text) memoriaText = mem.text;
    }
    if (!memoriaText && ESTAT._resumCompacte) {
      memoriaText = ESTAT._resumCompacte;
    }

    if (memoriaText) {
      parts.push(`### SINOPSI CAPÃTOLS 1â€“${cobertaFinsCap} (comprimida)\n${memoriaText.trim()}`);
    } else {
      // Fallback: 300 chars per capÃ­tol antic
      tier3.forEach(e => {
        const reg = ESTAT.llibreRegistre?.capitols?.[e.idx];
        const resum = (reg?.resum_capitol || e.text).slice(0, 300);
        parts.push(`### CAPÃTOL ${e.idx + 1} (resum breu)\n${resum}â€¦`);
      });
    }
  }

  // â”€â”€ TIER 2: resums per capÃ­tol â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  tier2.forEach(e => {
    const reg = ESTAT.llibreRegistre?.capitols?.[e.idx];
    const resum = reg?.resum_capitol || e.text.slice(0, 1500);
    parts.push(`### CAPÃTOL ${e.idx + 1} (resum)\n${resum.trim()}`);
  });

  // â”€â”€ TIER 1: text complet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  tier1.forEach(e => {
    parts.push(`### CAPÃTOL ${e.idx + 1}\n${e.text.trim()}`);
  });

  const header = tier3.length > 0
    ? 'CAPÃTOLS ANTERIORS (compressiÃ³ progressiva â€” recents complets, antics comprimits):'
    : 'CAPÃTOLS ANTERIORS (recents complets, intermedis en resum):';

  return `\n\n${header}\n${parts.join('\n\n')}`;
}

function buildContextCapitolLegacy(idx) {
  const parts = [];

  // 1. Brief narratiu
  parts.push(buildBriefNarratiu());

  // 2. CapÃ­tols anteriors literals (prioritari sobre resums)
  const capsContext = buildContextCapitolsComplets(idx);
  if (capsContext) parts.push(capsContext);

  // 3. Ãšltims 2 parÃ grafs del capÃ­tol anterior (continuÃ¯tat de to)
  if (idx > 0 && ESTAT._capitols_generats[idx - 1]) {
    const parasAnterior = ESTAT._capitols_generats[idx - 1].split(/\n\n+/);
    const ultims = parasAnterior.slice(-2).join('\n\n');
    if (ultims.trim()) {
      parts.push('\nFINAL DEL CAPÃTOL ANTERIOR (mantÃ©n la continuÃ¯tat de to i escena):\n' + ultims);
    }
  }

  // 4. Registre actual (personatges, fils)
  parts.push(buildRegistreContext(idx));

  // 5. Prefiguracions actives per a aquest capÃ­tol
  const { aPlantarAra, aRecollirAra, plantadesNoResoltes } = getPrefiguracionsActives(idx);

  if (aPlantarAra.length > 0) {
    parts.push('\nPREFIGURACIONS A PLANTAR EN AQUEST CAPÃTOL (integra-les subtilment, el lector no ha de notar-les en primera lectura):');
    aPlantarAra.forEach(p => parts.push(`- ${p.element}`));
  }

  if (aRecollirAra.length > 0) {
    parts.push('\nPREFIGURACIONS A RECOLLIR (elements plantats abans que ara es resolen):');
    aRecollirAra.forEach(p => parts.push(`- ${p.element}`));
  }

  if (plantadesNoResoltes.length > 0) {
    parts.push('\nPREFIGURACIONS ACTIVES (plantades i encara no resoltes â€” pots fer-hi referÃ¨ncia subtil):');
    plantadesNoResoltes.forEach(p => parts.push(`- ${p.element} (es resoldrÃ  al cap. ${p.resolucio_capitol})`));
  }

  // 6. Instruccions de ritme i to especÃ­fiques
  const cap = ESTAT._estructuraCapitols[idx];
  if (cap && cap.toRitme) {
    parts.push(`\nTO I RITME D'AQUEST CAPÃTOL: ${cap.toRitme}`);
  }

  // 7. Corba de tensiÃ³
  const tensio = (ESTAT._corbaTensio || []).find(t => t.capitol === idx + 1);
  if (tensio) {
    const instrRitme = getInstruccionsRitme(tensio.nivell, tensio.tipus);
    parts.push(`\nNIVELL DE TENSIÃ“ OBJECTIU: ${tensio.nivell}/10 (${tensio.tipus || ''})`);
    parts.push(`INSTRUCCIONS DE PROSA: ${instrRitme}`);
  }

  // 8. Context de la bÃ­blia narrativa
  const biblia = ESTAT.bibliaNarrativa;
  if (biblia) {
    const bibliaLines = [];
    if (biblia.fets_canonics && biblia.fets_canonics.length > 0) {
      bibliaLines.push('FETS CANÃ’NICS ESTABLERTS (NO CONTRADIR):');
      biblia.fets_canonics.slice(-8).forEach(f => bibliaLines.push('- ' + f));
    }
    // Filtrem fitxes dels personatges que apareixen en aquest capÃ­tol
    const capEst = ESTAT._estructuraCapitols[idx];
    const personatgesCap = (capEst && capEst.personatges) ? capEst.personatges : [];
    const fitxesRellevants = (biblia.fitxes_personatges || []).filter(f =>
      personatgesCap.some(nom =>
        nom.toLowerCase().includes((f.nom || '').toLowerCase()) ||
        (f.nom || '').toLowerCase().includes(nom.toLowerCase())
      )
    );
    if (fitxesRellevants.length > 0) {
      bibliaLines.push('ESTAT ACTUAL DELS PERSONATGES PRESENTS:');
      fitxesRellevants.forEach(f => {
        bibliaLines.push(`- ${f.nom}: ${f.estat_actual || '(no definit)'}`);
        if (f.motivacions) bibliaLines.push(`  MotivaciÃ³: ${f.motivacions}`);
      });
    }
    if (biblia.regles_mon && biblia.regles_mon.length > 0) {
      bibliaLines.push('REGLES DEL MÃ“N (respecta-les sempre):');
      biblia.regles_mon.forEach(r => bibliaLines.push('- ' + r));
    }
    if (bibliaLines.length > 0) {
      parts.push('\n' + bibliaLines.join('\n'));
    }
  }

  // 9. Context de trames actives en aquest capÃ­tol
  const trames = ESTAT.trames;
  if (trames && (trames.trama_principal || trames.subtrames.length > 0)) {
    const tramesLines = ['\nTRAMES ACTIVES EN AQUEST CAPÃTOL:'];
    if (trames.trama_principal) {
      const tp = trames.trama_principal;
      tramesLines.push('Trama principal: ' + (typeof tp === 'string' ? tp : (tp.descripcio || JSON.stringify(tp))));
    }
    const mapaEntry = (trames.mapa_entrellacat || []).find(m => m.capitol === idx + 1);
    if (mapaEntry && mapaEntry.trames_actives) {
      const subActive = trames.subtrames.filter(st =>
        mapaEntry.trames_actives.some(t =>
          t === st.nom || t.toLowerCase().includes((st.nom || '').toLowerCase())
        )
      );
      subActive.forEach(st => tramesLines.push(`Subtrama "${st.nom}": ${st.descripcio || ''}`));
    }
    parts.push(tramesLines.join('\n'));
  }

  // 10. Ajustos de rumb del darrer checkpoint
  if (ESTAT._ajustosRumb) {
    const ajustos = typeof ESTAT._ajustosRumb === 'string' ? ESTAT._ajustosRumb : JSON.stringify(ESTAT._ajustosRumb);
    if (ajustos && ajustos.trim()) {
      parts.push(`\nAJUSTOS DE RUMB (indicaciÃ³ del checkpoint de coherÃ¨ncia): ${ajustos}`);
    }
  }

  return parts.join('\n');
}

function buildContextCapitol(idx) {
  // PONT NKG: quan el NKG Ã©s actiu, delega a nkgGenerarContextMinim
  if (ESTAT._nkg) {
    const cap = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols[idx] : null;
    const escenaSpec = {
      capitol: idx + 1,
      escena: 1,
      personatges: cap ? (cap.personatges || []) : [],
      lloc: cap ? (cap.localitzacio || '') : '',
      escaleta: null
    };
    return nkgGenerarContextMinim(escenaSpec);
  }
  return buildContextCapitolLegacy(idx);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10: Estructura de la novelÂ·la (Opus) â€” JSON
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEstructuraNovella(userConfig) {
  const personatgesCtx = ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0
    ? ESTAT._personatgesSeleccionats.join('\n')
    : '(No definit)';

  const brief = buildBriefNarratiu();

  // Context de trames (si s'han generat prÃ¨viament a la fase de trames)
  let tramesCtx = '';
  if (ESTAT.trames && ESTAT.trames.trama_principal) {
    const tp = ESTAT.trames.trama_principal;
    tramesCtx = `\nDISSENY DE TRAMES PREVI (integra'l a l'estructura capÃ­tol a capÃ­tol):
TRAMA PRINCIPAL: ${typeof tp === 'string' ? tp : (tp.descripcio || JSON.stringify(tp))}`;
    if (tp.conflicte_central) tramesCtx += `\nConflicte central: ${tp.conflicte_central}`;
    if (tp.arc_protagonista)  tramesCtx += `\nArc protagonista: ${tp.arc_protagonista}`;
    if (ESTAT.trames.subtrames.length > 0) {
      tramesCtx += '\nSUBTRAMES:';
      ESTAT.trames.subtrames.forEach(st => {
        tramesCtx += `\n- ${st.nom} (caps. ${st.capitol_inici || '?'}-${st.capitol_resolucio || '?'}): ${st.descripcio || ''}`;
      });
    }
  }

  const msgs = [{
    role: 'user',
    content: `A partir del conte original, la bÃ­blia de mÃ³n i l'elenc, crea l'estructura completa de la novelÂ·la.

${brief}

CONTE ORIGINAL (resum):
${ESTAT.conteText ? ESTAT.conteText.substring(0, 2000) + (ESTAT.conteText.length > 2000 ? '\n[â€¦conte truncat per espaiâ€¦]' : '') : '(No disponible)'}

BÃBLIA DE MÃ“N:
${ESTAT.worldbuilding ? ESTAT.worldbuilding.substring(0, 1500) + (ESTAT.worldbuilding.length > 1500 ? '\n[â€¦]' : '') : '(No definida)'}

ELENC DE PERSONATGES SELECCIONATS:
${personatgesCtx}

ESTILS DE PARLA (resum):
${ESTAT.estilsParla ? ESTAT.estilsParla.substring(0, 1000) + (ESTAT.estilsParla.length > 1000 ? '\n[â€¦]' : '') : '(No definits)'}${tramesCtx}

NOMBRE DE CAPÃTOLS: Entre 12 i 22 capÃ­tols. La decisiÃ³ depÃ¨n de la complexitat i profunditat de la trama:
- 12-14 capÃ­tols: Trama principal + 0-2 subtrames. Arc narratiu concentrat. NovelÂ·la de ritme Ã gil (50.000-65.000 paraules objectiu).
- 15-18 capÃ­tols: Trama principal + 2-3 subtrames significatives, o elencs de 4+ personatges amb arcs propis.
  Espai per a subplots emocionals, desviaments i caps de pont entre actes. (65.000-80.000 paraules objectiu).
- 19-22 capÃ­tols: Trama principal + 3-4 subtrames complexes, mÃºltiples girs, revelacions escalonades,
  o una estructura coral amb 4+ protagonistes que requereix capÃ­tols de perspectiva alternada. (80.000-100.000 paraules objectiu).

REGLA D'OR: Cada capÃ­tol ha de justificar la seva existÃ¨ncia â€” si un capÃ­tol es pot fusionar
amb l'anterior o el posterior sense perdre res essencial, fusiona'l.
Prioritza l'amplitud dramÃ tica: Ã©s millor una novelÂ·la ben desplegada que un relat comprimit.
NO superis MAI 22 capÃ­tols. La densitat narrativa Ã©s tan important com l'extensiÃ³.

INSTRUCCIONS DE CORBA DE TENSIÃ“:
La "corba_tensio" ha de seguir una estructura dramÃ tica adaptada al nombre de capÃ­tols.
La corba NO Ã©s lineal ascendent â€” ha d'OSCILÂ·LAR: desprÃ©s de cada pic hi ha un moment de respir.
Alterna capÃ­tols d'acciÃ³ (frases curtes, diÃ leg rÃ pid) amb capÃ­tols de respiraciÃ³ (introspectiu, descriptiu).

PER A 12-14 CAPÃTOLS (estructura 3-5/7-4):
  - Acte I (caps 1-3): exposiciÃ³ â†’ incident detonant
    Â· Cap 1: nivell 3 (establir mÃ³n i protagonista)
    Â· Cap 2: nivell 4 (complicaciÃ³, presentar conflicte)
    Â· Cap 3: nivell 6 (primer punt de gir â€” no hi ha marxa enrere)
  - Acte II (caps 4-9/10): desenvolupament â†’ crisi
    Â· Caps 4-5: nivell 5-6 (explorar conflicte, subtrames)
    Â· Cap mig: nivell 7 (punt mig â€” revelaciÃ³ o gir)
    Â· Caps segÃ¼ents: nivell 7-8 (complicaciÃ³ greu)
    Â· PenÃºltim de l'Acte II: nivell 9 (tot sembla perdut)
  - Acte III (caps finals 4): clÃ­max â†’ resoluciÃ³
    Â· PenÃºltim: nivell 8 (reorganitzaciÃ³, pla desesperat)
    Â· ClÃ­max: nivell 10
    Â· ResoluciÃ³: nivell 7
    Â· Tancament: nivell 4-5 (epÃ­leg narratiu)

PER A 15-18 CAPÃTOLS (estructura 4-9/10-4/5):
  - Acte I (caps 1-4): exposiciÃ³ ampliada, presentaciÃ³ de subtrames
    Â· Cap 1: nivell 3 | Cap 2: nivell 4 | Cap 3: nivell 5 | Cap 4: nivell 6 (primer gir)
  - Acte II (caps 5-13/14): desenvolupament ric amb oscilÂ·laciÃ³
    Â· Caps 5-6: nivell 5-6 (respiraciÃ³, explorar subtrames)
    Â· Cap mig-1: nivell 7 (revelaciÃ³ parcial)
    Â· Caps segÃ¼ents: nivell 6-7 (conseqÃ¼Ã¨ncies, subtrames)
    Â· Cap mig+2: nivell 8 (complicaciÃ³ greu, possible gir de subtrama)
    Â· Cap penÃºltim Acte II: nivell 5 (calma abans de la tempesta)
    Â· Cap Ãºltim Acte II: nivell 9 (crisi mÃ xima)
  - Acte III (caps 14/15-18): resoluciÃ³ i tancament
    Â· Cap 1 Acte III: nivell 8 | ClÃ­max: nivell 10 | ResoluciÃ³: nivell 7 | Tancament: nivell 4-5

PER A 19-22 CAPÃTOLS (estructura 5-12/14-4/5):
  - Acte I (caps 1-5): exposiciÃ³ coral, introducciÃ³ de mÃºltiples fils
    Â· Caps 1-2: nivell 3-4 | Cap 3: nivell 5 | Cap 4: nivell 5-6 | Cap 5: nivell 7 (primer gir major)
  - Acte II (caps 6-17/18): desplegament complex, mÃºltiples subtrames
    Â· OscilÂ·la entre nivells 4 i 9, amb respiraciÃ³ cada 2-3 capÃ­tols
    Â· Inclou: un punt mig (nivell 7-8), un fals clÃ­max (nivell 9), una calma estratÃ¨gica (nivell 4-5)
    Â· Subtrames han de tenir el seu propi clÃ­max intern (nivell 8) abans de convergir amb la principal
  - Acte III (caps finals 4-5): convergÃ¨ncia i resoluciÃ³
    Â· PenÃºltim Acte II: nivell 9 | ClÃ­max: nivell 10 | ResoluciÃ³: nivell 7 | EpÃ­leg: nivell 4

INSTRUCCIÃ“ D'ARC DE PERSONATGE: Qualsevol caiguda moral, traÃ¯ciÃ³ als propis principis o canvi radical de paradigma del protagonista NO pot passar en un sol capÃ­tol. Ha d'haver-hi almenys un capÃ­tol sencer de "Dubte i RacionalitzaciÃ³" on el personatge intenti auto-enganyar-se abans d'acceptar la seva nova naturalesa corrupta o el seu canvi d'alineaciÃ³. Planifica explÃ­citament aquest capÃ­tol de transiciÃ³ a l'estructura. Fes que les derrotes morals se sentin orgÃ niques i justificades, no precipitades.

ARC MORAL DEL PROTAGONISTA (OBLIGATORI):
A mÃ©s de la corba de tensiÃ³, defineix una "corba moral" independent amb exactament 5 punts:
1. ESTAT INICIAL: Valors i creences del protagonista al comenÃ§ar
2. PRIMERA FISSURA (cap. 3-5): Un moment on els seus principis fallen per primera vegada
3. BACKSLIDING (cap. 6-9): Un intent genuÃ­ de tornar als seus valors originals que FRACASSA â€” no per debilitat, sinÃ³ perquÃ¨ el mÃ³n ja no li ho permet
4. PUNT DE NO RETORN (cap. 9-12): La decisiÃ³ irreversible que el transforma
5. COST FINAL (Ãºltims 2-3 caps): El preu emocional/moral concret de la transformaciÃ³
Inclou-ho com a camp "arc_moral" al JSON de retorn.

IMPORTANT: Has de completar TOTS els capÃ­tols. El JSON ha de contenir exactament tantes entrades a l'array "capitols" com el "nombre_capitols" que decideixis.
IMPORTANT: L'array "capitols" ha de contenir EXACTAMENT el nombre de capÃ­tols indicat a "nombre_capitols". Prioritza completar tots els capÃ­tols encara que les descripcions dels Ãºltims siguin mÃ©s breus. Un JSON truncat Ã©s INACCEPTABLE.

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "nombre_capitols": 12,
  "justificacio_capitols": "Explica en 2-3 lÃ­nies per quÃ¨ has triat N capÃ­tols i no N-1 o N+1",
  "arc_global": "descripciÃ³ de l'arc narratiu complet en 5-8 lÃ­nies",
  "temes_centrals": ["tema1", "tema2", "tema3"],
  "prefiguracions": [
    {"plantada_capitol": 2, "resolucio_capitol": 8, "element": "descripciÃ³ de l'element plantat"},
    {"plantada_capitol": 3, "resolucio_capitol": 11, "element": "descripciÃ³ de l'element plantat"}
  ],
  "corba_tensio": [
    {"capitol": 1, "nivell": 3, "tipus": "exposiciÃ³"},
    {"capitol": 2, "nivell": 5, "tipus": "complicaciÃ³"}
  ],
  "arc_moral": {
    "estat_inicial": "descripciÃ³ dels valors inicials del protagonista",
    "primera_fissura": {"capitol": 4, "descripcio": "moment on els principis fallen per primera vegada"},
    "backsliding": {"capitol": 7, "descripcio": "intent genuÃ­ de tornar als valors originals que fracassa"},
    "punt_no_retorn": {"capitol": 10, "descripcio": "decisiÃ³ irreversible que el transforma"},
    "cost_final": {"capitol": 13, "descripcio": "preu emocional/moral concret de la transformaciÃ³"}
  },
  "capitols": [
    {
      "numero": 1,
      "titol": "tÃ­tol evocador",
      "resum": "resum de 3-5 lÃ­nies",
      "personatges": ["nom1", "nom2"],
      "fil_principal": "fil narratiu que avanÃ§a",
      "to_ritme": "lent i introspectiu / trepidant / etc.",
      "prefiguracions_a_plantar": ["element que es plantarÃ  aquÃ­"],
      "prefiguracions_a_recollir": ["element plantat abans que es resol aquÃ­"],
      "connexio_anterior": "com lliga amb l'anterior",
      "connexio_seguent": "com prepara el segÃ¼ent"
    }
  ]
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un arquitecte narratiu expert en estructures de novelÂ·la. Retornes EXCLUSIVAMENT un objecte JSON vÃ lid, sense cap text addicional ni markdown. Escrius els valors de text en catalÃ .',
    Object.assign({}, userConfig, { maxTokens: 16384, model: getModelConfig(userConfig).modelArquitecte }),
    'arquitectura'
  );
  return { response };
}

async function completarEstructuraCapitols(capitolsExistents, capsEsperats, userConfig) {
  const ultimCapitol = capitolsExistents[capitolsExistents.length - 1];
  const primerACompletar = ultimCapitol ? ultimCapitol.numero + 1 : capitolsExistents.length + 1;
  const capsQueFalten = capsEsperats - capitolsExistents.length;

  const resumExistents = capitolsExistents.map(c =>
    `Cap. ${c.numero}: "${c.titol}" â€” ${(c.resum || '').substring(0, 80)}`
  ).join('\n');

  const msgs = [{
    role: 'user',
    content: `L'estructura de la novelÂ·la estÃ  incompleta. Tens els primers ${capitolsExistents.length} capÃ­tols i falten els capÃ­tols ${primerACompletar} a ${capsEsperats}.

CAPÃTOLS JA DEFINITS:
${resumExistents}

ARC GLOBAL: ${ESTAT._arcGlobal || '(no disponible)'}
FINAL PLANIFICAT: ${ESTAT.finalTriat || '(no definit)'}

CORBA DE TENSIÃ“ per als capÃ­tols que falten:
${(ESTAT._corbaTensio || []).filter(t => t.capitol >= primerACompletar).map(t => `Cap.${t.capitol}: nivell ${t.nivell} (${t.tipus})`).join(', ') || '(no disponible)'}

Genera EXACTAMENT ${capsQueFalten} capÃ­tols (del ${primerACompletar} al ${capsEsperats}).

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "capitols": [
    {
      "numero": ${primerACompletar},
      "titol": "tÃ­tol evocador",
      "resum": "resum de 2-3 lÃ­nies",
      "personatges": ["nom1", "nom2"],
      "fil_principal": "fil narratiu",
      "to_ritme": "to i ritme",
      "prefiguracions_a_plantar": [],
      "prefiguracions_a_recollir": [],
      "connexio_anterior": "com lliga amb l'anterior",
      "connexio_seguent": "com prepara el segÃ¼ent"
    }
  ]
}

CRÃTIC: Han de ser EXACTAMENT ${capsQueFalten} capÃ­tols. L'Ãºltim (${capsEsperats}) ha de conduir al final planificat.`
  }];

  const response = await callLLMMulti(msgs,
    'Ets un arquitecte narratiu. Retorna EXCLUSIVAMENT JSON vÃ lid amb els capÃ­tols que falten.',
    Object.assign({}, userConfig, { maxTokens: 6000 }), 'arquitectura');
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 11: Escriure capÃ­tol (Sonnet) â€” FASE 3: Context complet
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function generarInstruccionsGanxoFinalCapitol(idx) {
  const esUltimCapitol = idx >= ((ESTAT._estructuraCapitols && ESTAT._estructuraCapitols.length) ? ESTAT._estructuraCapitols.length - 1 : 0);
  const oberts = (ESTAT.llibreRegistre && Array.isArray(ESTAT.llibreRegistre.fils_oberts))
    ? ESTAT.llibreRegistre.fils_oberts.filter(Boolean)
    : [];

  if (esUltimCapitol) {
    return `Com que Ã©s l'Ãºltim capÃ­tol, tanca els fils prioritaris i deixa una reverberaciÃ³ emocional final potent: una Ãºltima imatge, una realitzaciÃ³ del personatge o una resoluciÃ³ que ressoni. Sense cliffhanger fort, perÃ² que la darrera frase es quedi gravada.`;
  }

  const tecniques = `Tria la tÃ¨cnica que encaixi millor amb el moment narratiu â€” NO forÃ§is una pregunta retÃ²rica si no Ã©s la mÃ©s efectiva:
  Â· RevelaciÃ³: una informaciÃ³ nova que ho canvia tot o qÃ¼estiona el que el lector creia saber
  Â· AmenaÃ§a imminent: el perill arriba i el capÃ­tol talla just abans de la colÂ·lisiÃ³
  Â· Ruptura: traÃ¯ciÃ³, pÃ¨rdua o descobriment que trenca l'equilibri emocional establert
  Â· DecisiÃ³ congelada: el personatge davant d'una elecciÃ³ impossible, el lector no sap quÃ¨ farÃ 
  Â· InversiÃ³: el poder, la veritat o la situaciÃ³ s'inverteixen de cop
  Â· Imatge final: una Ãºltima escena o detall que ressona emocionalment i obre una promesa no dita
  Â· Escalada d'apostes: un element nou (personatge, objecte, informaciÃ³) que puja el risc de tot el que ve
  L'objectiu Ã©s que el lector NECESSITI girar la pÃ gina, no que es faci una pregunta.`;

  if (oberts.length > 0) {
    const mostra = oberts.slice(0, 3).join(' Â· ');
    return `Al tram final crea un moment que faci la lectura addictiva, connectant l'escena final amb algun fil obert del registre (${mostra}) per intensificar-lo o encaminar-ne la resoluciÃ³ futura. ${tecniques}`;
  }

  return `Al tram final crea un moment que faci la lectura addictiva. ${tecniques}`;
}

async function escriureCapitol(idx, userConfig) {
  const cap          = ESTAT._estructuraCapitols[idx];
  const capPlanificacio = cap ? (cap.resum || cap.text) : `CapÃ­tol ${idx + 1}`;
  const context      = buildContextCapitol(idx);
  const systemPrompt = buildSystemPromptCapitol();
  const instruccionsFinalCapitol = generarInstruccionsGanxoFinalCapitol(idx);

  // Instruccions de personatges presents i els seus estils
  const persPresents = cap && cap.personatges ? cap.personatges : [];
  let instruccionsVeu = '';
  if (persPresents.length > 0 && ESTAT.estilsParla) {
    instruccionsVeu = `\n\nPERSONATGES EN AQUEST CAPÃTOL I ELS SEUS ESTILS DE PARLA:
Aplica estrictament l'estil de veu definit per a cada personatge en els seus diÃ legs.
Cada personatge ha de sonar inconfusiblement diferent dels altres.
Personatges presents: ${persPresents.join(', ')}`;
  }

  const msgs = [{
    role: 'user',
    content: `Escriu el CAPÃTOL ${idx + 1} de la novelÂ·la.

PLANIFICACIÃ“ D'AQUEST CAPÃTOL:
${capPlanificacio}

${context}
${instruccionsVeu}

INSTRUCCIONS D'ESCRIPTURA:
- LONGITUD OBLIGATÃ’RIA: Aquest capÃ­tol ha de tenir entre 3.500 i 5.000 paraules. Presa't el teu temps per desenvolupar totes les escenes amb el ritme adequat. Utilitza descripcions sensorials riques, diÃ legs ben construÃ¯ts i accions fÃ­siques per expandir el text. NO precipitis el final ni resumeixis els esdeveniments per acabar rÃ pid. Desenvolupa la prosa de manera literÃ ria fins a assolir aquesta extensiÃ³ de paraules.
- Desenvolupa les escenes a fons, utilitza diÃ leg ric i descripcions sensorials. NO resumeixis.
- ComenÃ§a directament amb la narraciÃ³, sense titular el capÃ­tol
- Si hi ha prefiguracions a plantar, integra-les de forma subtil i natural (el lector no ha de notar-les en primera lectura)
- Si hi ha prefiguracions a recollir, dona'ls resoluciÃ³ satisfactÃ²ria
- Respecta el nivell de tensiÃ³ objectiu i el to indicat
- Si no Ã©s el primer capÃ­tol, la primera frase ha de connectar fluÃ¯dament amb el final del capÃ­tol anterior
- ${instruccionsFinalCapitol}
- Escriu en catalÃ `
  }];

  const models = getModelConfig(userConfig);
  const response = await callLLMOneShotPlusCompletion(msgs, systemPrompt, Object.assign({}, userConfig, { maxTokens: 14000, model: models.modelGeneracio }), 'generacio');
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Actualitzar Llibre de Registre (Sonnet â€” background)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function actualitzarRegistre(textCapitol, idx, userConfig) {
  const reg = ESTAT.llibreRegistre;
  const registreAnterior = reg.capitols && reg.capitols[idx - 1]
    ? JSON.stringify(reg.capitols[idx - 1], null, 2)
    : JSON.stringify({ estat_personatges: [], fils_oberts: [], fils_tancats: [] });

  const msgs = [{
    role: 'user',
    content: `Ets un Script Supervisor. A partir del Llibre de Registre actual i el nou capÃ­tol, actualitza l'estat.

LLIBRE DE REGISTRE ACTUAL:
${registreAnterior}

CAPÃTOL ${idx + 1} ACABAT DE GENERAR:
${textCapitol.substring(0, 4000)}${textCapitol.length > 4000 ? '\n[â€¦text truncatâ€¦]' : ''}

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense cap text addicional, sense markdown):
{
  "resum_capitol": "resum de 2-3 frases del capÃ­tol",
  "estat_personatges": [{"nom": "nom", "ubicacio": "on Ã©s ara", "estat_actual": "situaciÃ³ emocional/fÃ­sica actual"}],
  "fils_oberts": ["fil narratiu que queda obert o s'ha introduÃ¯t"],
  "fils_tancats": ["fil narratiu que s'ha resolt en aquest capÃ­tol"],
  "prefiguracions_detectades": ["element que apareix en aquest capÃ­tol i podria ser una prefiguraciÃ³ o referÃ¨ncia a una"]
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un supervisor narratiu. Retornes EXCLUSIVAMENT un objecte JSON vÃ lid, sense cap altre text.',
    Object.assign({}, userConfig, { maxTokens: 1500, model: getModelConfig(userConfig).modelDraft, _esDraft: true }),
    'generacio'
  );
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RevisiÃ³ inter-capÃ­tol (Opus) â€” FASE 5: verifica prefiguracions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function revisarCapitol(textCapitol, idx, userConfig) {
  const cap       = ESTAT._estructuraCapitols[idx];
  const capText   = cap ? cap.resum || cap.text : '';
  const registreCtx = buildRegistreContext(idx);
  const { aPlantarAra, aRecollirAra } = getPrefiguracionsActives(idx);

  let prefCtx = '';
  if (aPlantarAra.length > 0) {
    prefCtx += '\nPREFIGURACIONS QUE CALIA PLANTAR EN AQUEST CAPÃTOL:\n' +
      aPlantarAra.map(p => `- ${p.element}`).join('\n');
  }
  if (aRecollirAra.length > 0) {
    prefCtx += '\nPREFIGURACIONS QUE CALIA RECOLLIR EN AQUEST CAPÃTOL:\n' +
      aRecollirAra.map(p => `- ${p.element}`).join('\n');
  }

  const msgs = [{
    role: 'user',
    content: `Revisa aquest capÃ­tol i comprova la coherÃ¨ncia amb la planificaciÃ³ i el Registre narratiu.

PLANIFICACIÃ“ D'AQUEST CAPÃTOL:
${capText}
${registreCtx}
${prefCtx}

CAPÃTOL ${idx + 1} GENERAT:
${textCapitol.substring(0, 5000)}${textCapitol.length > 5000 ? '\n[â€¦text truncatâ€¦]' : ''}

Verifica especÃ­ficament:
- Si el capÃ­tol havia de plantar una prefiguraciÃ³, s'ha fet de forma subtil?
- Si el capÃ­tol havia de recollir una prefiguraciÃ³, s'ha resolt satisfactÃ²riament?
- Hi ha algun element que contradigui una prefiguraciÃ³ plantada anteriorment?
- Format de diÃ legs: Hi ha intervencions de diferents personatges solapades en un mateix parÃ graf sense punt i a part? Si Ã©s aixÃ­, marca-ho com a error greu de format.

AVALUACIÃ“ DE GANXOS (Hook Review):
Avalua els elements narratius de ganxo del capÃ­tol:
1. OBERTURA: El primer parÃ graf captura l'atenciÃ³? (escena in medias res, tensiÃ³ immediata, imatge potent â€” no necessÃ riament una pregunta)
2. CLIFFHANGER: El final fa que el lector NECESSITI llegir el segÃ¼ent capÃ­tol? Avalua si usa la tÃ¨cnica mÃ©s efectiva per a aquest moment narratiu: revelaciÃ³ que ho canvia tot, amenaÃ§a imminent tallada just abans, ruptura emocional (traÃ¯ciÃ³/pÃ¨rdua/descobriment), decisiÃ³ congelada, inversiÃ³ de situaciÃ³, imatge final que ressona, o escalada d'apostes. Penalitza els finals que es limiten a una pregunta retÃ²rica quan el moment narratiu permetia alguna cosa mÃ©s visceral.
3. RITME INTERN: El capÃ­tol mantÃ© un ritme adequat al seu tipus (acciÃ³/respiraciÃ³)? Hi ha un equilibri entre diÃ leg, acciÃ³ i descripciÃ³?
4. PROMESA NARRATIVA: El capÃ­tol avanÃ§a alguna trama o obre una tensiÃ³ que el lector vol veure resolta?

SELECCIÃ“ DE PASSATGE:
A mÃ©s de la revisiÃ³, selecciona el MILLOR passatge del capÃ­tol (entre 150 i 250 paraules) que millor exemplifiqui la veu narrativa. Copia'l literalment del text.

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense cap text addicional, sense markdown):
IMPORTANT: Si detectes solapament de diÃ legs entre personatges en un mateix parÃ graf, "ok_per_continuar" HA DE ser false i has de donar "instruccions_correccio" explÃ­cites per reescriure separant els parÃ grafs.
{
  "puntuacio": 8,
  "problemes": ["descripciÃ³ concreta del problema 1", "Solapament de diÃ legs detectat: intervencions de diferents personatges en un mateix parÃ graf. Cal reescriure separant-los."],
  "instruccions_correccio": "instruccions clares per a Sonnet per reescriure si cal (buit si no cal)",
  "ok_per_continuar": true,
  "prefiguracions_ok": true,
  "prefiguracions_problemes": ["descripciÃ³ del problema de prefiguraciÃ³ si n'hi ha"],
  "hook_review": {
    "obertura_puntuacio": 7,
    "obertura_comentari": "comentari breu sobre l'obertura",
    "cliffhanger_puntuacio": 6,
    "cliffhanger_comentari": "comentari breu sobre el cliffhanger",
    "ritme_puntuacio": 8,
    "ritme_comentari": "comentari breu sobre el ritme intern",
    "promesa_puntuacio": 7,
    "promesa_comentari": "comentari breu sobre la promesa narrativa"
  },
  "instruccions_cliffhanger": "instruccions concretes per millorar el cliffhanger si la puntuaciÃ³ Ã©s < 6 (buit si no cal)",
  "comentari_editor_final": "possible millora global de capÃ­tol (buit si no cal)",
  "golden_passage": "el text del millor passatge (150-250 paraules)"
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari sÃ¨nior especialitzat en narrativa de pÃ gina. Retornes EXCLUSIVAMENT un objecte JSON vÃ lid, sense cap altre text.',
    Object.assign({}, userConfig, { maxTokens: 2000 }),
    'arquitectura'
  );

  // Desa les instruccions per si cal reescriure
  const revisat = parseJsonRobust(response);
  if (revisat && revisat.instruccions_correccio) {
    ESTAT._revisioInstruccions = ESTAT._revisioInstruccions || {};
    ESTAT._revisioInstruccions[idx] = revisat.instruccions_correccio;
  }

  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 6: RevisiÃ³ Global Transversal (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function revisioGlobalOpusAPI(userConfig) {
  // Fragments clau de cada capÃ­tol: primer + mig + Ãºltim parÃ graf
  const fragments = ESTAT._capitols_generats.map((text, i) => {
    if (!text) return null;
    const pars = text.split(/\n\n+/).filter(p => p.trim());
    if (pars.length === 0) return null;
    const primer = pars[0].substring(0, 300);
    const mig    = pars.length > 2 ? pars[Math.floor(pars.length / 2)].substring(0, 300) : '';
    const ultim  = pars[pars.length - 1].substring(0, 300);
    return `--- CAPÃTOL ${i + 1} ---\nINICI: ${primer}${mig ? '\nMIG: ' + mig : ''}\nFINAL: ${ultim}`;
  }).filter(Boolean).join('\n\n');

  // Resums del registre
  const resums = (ESTAT.llibreRegistre.capitols || [])
    .map((c, i) => c ? `Cap.${i + 1}: ${c.resum_capitol || ''}` : '')
    .filter(Boolean).join('\n');

  const prefLlistat = llistarPrefiguracions();

  const msgs = [{
    role: 'user',
    content: `Revisa la novelÂ·la transversalment. Tens fragments representatius de cada capÃ­tol i els resums complets.

${buildBriefNarratiu()}

PREFIGURACIONS PLANIFICADES:
${prefLlistat}

RESUMS DE TOTS ELS CAPÃTOLS:
${resums || '(No disponibles)'}

FRAGMENTS REPRESENTATIUS DELS CAPÃTOLS:
${fragments || '(No disponibles)'}

Avalua:
1. COHERÃˆNCIA DE VEU: El narrador mantÃ© el mateix registre al llarg de la novelÂ·la? Detecta canvis de to injustificats.
2. REPETICIONS: Hi ha escenes, diÃ legs o descripcions que es repeteixen entre capÃ­tols?
3. COHERÃˆNCIA FACTUAL: Detalls concrets (colors, noms, distÃ ncies, dates) sÃ³n consistents?
4. PREFIGURACIONS: Totes les plantades s'han resolt? N'hi ha alguna pendent?
5. ARCS DE PERSONATGE: Cada personatge ha evolucionat? Algun s'ha estancat o ha desaparegut?
6. RITME GLOBAL: La novelÂ·la respira bÃ©? Hi ha zones mortes o massa llargues?

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "puntuacio_global": 7,
  "veu_consistent": true,
  "problemes": [{"capitol": 3, "tipus": "repeticiÃ³", "descripcio": "descripciÃ³ del problema", "gravetat": "mitja"}],
  "capitols_a_reescriure": [3],
  "instruccions_reescriptura": {"3": "instruccions concretes per al capÃ­tol 3"},
  "prefiguracions_pendents": ["element no resolt"],
  "veredicte": "text lliure amb el diagnÃ²stic general en catalÃ "
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari sÃ¨nior fent una revisiÃ³ global transversal. Retornes EXCLUSIVAMENT un objecte JSON vÃ lid. Els textos han de ser en catalÃ .',
    Object.assign({}, userConfig, { maxTokens: 3000 }),
    'arquitectura'
  );
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Reescriure capÃ­tol amb instruccions d'Opus (Sonnet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function reescriureCapitolAmbInstruccions(idx, instruccions, userConfig) {
  const textActual  = ESTAT._capitols_generats[idx] || '';
  const cap         = ESTAT._estructuraCapitols[idx];
  const capText     = cap ? cap.text : '';
  const systemPrompt= buildSystemPromptCapitol();

  const msgs = [{
    role: 'user',
    content: `Reescriu el CapÃ­tol ${idx + 1} incorporant les correccions de l'editor.

PLANIFICACIÃ“ DEL CAPÃTOL:
${capText}

CAPÃTOL ACTUAL:
${textActual.substring(0, 4000)}${textActual.length > 4000 ? '\n[â€¦]' : ''}

INSTRUCCIONS DE CORRECCIÃ“ DE L'EDITOR (Opus):
${instruccions}

Reescriu el capÃ­tol complet incorporant les correccions. MantÃ©n la mateixa veu i extensiÃ³ (~2000 paraules). Escriu directament la narraciÃ³ en catalÃ , sense tÃ­tol ni notes.`
  }];

  const response = await callLLMMulti(msgs, systemPrompt, Object.assign({}, userConfig, { maxTokens: 6000 }), 'generacio');
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 12: Control d'Arcs Narratius (Opus) â€” FASE 9: context complet
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function controlArcsNovella(userConfig) {
  const reg = ESTAT.llibreRegistre;
  const resums = (reg.capitols || [])
    .map((c, i) => c ? `CapÃ­tol ${i + 1}: ${c.resum_capitol || '(sense resum)'}` : '')
    .filter(Boolean)
    .join('\n');

  const filsOberts  = (reg.fils_oberts  || []).map(f => `- ${f}`).join('\n') || '(Cap registrat)';
  const filsTancats = (reg.fils_tancats || []).map(f => `- ${f}`).join('\n') || '(Cap registrat)';

  // Estructura completa (JSON si disponible, text si legacy)
  const estructuraCompleta = ESTAT.estructuraNovella || '(No disponible)';

  // Prefiguracions i si s'han resolt
  const prefCtx = llistarPrefiguracions();

  // Resultats de la revisiÃ³ global (si existeix)
  const revisioGlobalCtx = ESTAT._revisioGlobal
    ? ESTAT._revisioGlobal.veredicte || '(No disponible)'
    : '(No s\'ha realitzat revisiÃ³ global)';

  const msgs = [{
    role: 'user',
    content: `Ets un editor sÃ¨nior avaluant una novelÂ·la a partir dels resums dels capÃ­tols.

${buildBriefNarratiu()}

PREFIGURACIONS PLANIFICADES:
${prefCtx}

RESULTAT DE LA REVISIÃ“ GLOBAL (Opus transversal):
${revisioGlobalCtx}

ESTRUCTURA PLANIFICADA ORIGINALMENT:
${estructuraCompleta}

RESUMS DELS CAPÃTOLS ESCRITS:
${resums || '(Cap capÃ­tol generat)'}

FILS NARRATIUS OBERTS: ${filsOberts}
FILS NARRATIUS TANCATS: ${filsTancats}

Revisa i diagnostica:
1. S'ha complert la premissa original?
2. El final planificat s'ha executat adequadament?
3. Queden fils oberts greus que fan la novelÂ·la incompleta?
4. Hi ha incoherÃ¨ncies de personatges o de trama detectades als resums?
5. Totes les prefiguracions planificades s'han resolt? Indica explÃ­citament quines queden obertes.

Retorna un diagnÃ²stic detallat en catalÃ . Si hi ha fils oberts greus, prefiguracions no resoltes o el final no s'ha resolt adequadament, proposa detalladament el contingut d'un EPÃLEG que els tanqui (secciÃ³ clarament marcada com "PROPOSTA D'EPÃLEG").`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor sÃ¨nior de novelÂ·la. Analitzes amb rigor i retornes un diagnÃ²stic constructiu i accionable en catalÃ .',
    Object.assign({}, userConfig, { maxTokens: 3500 }),
    'arquitectura'
  );
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Checkpoint de coherÃ¨ncia a meitat de novelÂ·la
//  S'executa automÃ ticament al capÃ­tol N/2 (novelÂ·les â‰¥16 caps)
//  Genera ajustos de rumb que s'injecten a tots els capÃ­tols restants
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function controlArcsIntermedi(capitolActual, userConfig) {
  const reg = ESTAT.llibreRegistre;
  const totalCapitols = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols.length : 0;
  const capsRestants = totalCapitols - capitolActual;

  const resums = (reg.capitols || [])
    .slice(0, capitolActual)
    .map((c, i) => c ? `CapÃ­tol ${i + 1}: ${c.resum_capitol || '(sense resum)'}` : '')
    .filter(Boolean)
    .join('\n');

  const filsOberts = (reg.fils_oberts || []).map(f => `- ${f}`).join('\n') || '(Cap registrat)';

  const prefCtx = llistarPrefiguracions();

  // CapÃ­tols pendents (de N/2 fins al final)
  const capsRestantsText = (ESTAT._estructuraCapitols || [])
    .slice(capitolActual)
    .map((c, i) => `Cap. ${capitolActual + i + 1}: "${c.titol || ''}" â€” ${(c.resum || '').substring(0, 80)}`)
    .join('\n');

  const msgs = [{
    role: 'user',
    content: `Ets un editor sÃ¨nior fent una revisiÃ³ de coherÃ¨ncia a MEITAT d'una novelÂ·la en curs.

${buildBriefNarratiu()}

PREFIGURACIONS PLANIFICADES (plantades i per plantar):
${prefCtx}

RESUMS DELS CAPÃTOLS ESCRITS FINS ARA (${capitolActual} de ${totalCapitols}):
${resums || '(Cap resum disponible)'}

FILS NARRATIUS OBERTS: ${filsOberts}

CAPÃTOLS QUE QUEDEN PER ESCRIURE (${capsRestants} capÃ­tols restants):
${capsRestantsText}

La novelÂ·la va per la meitat. Diagnostica l'estat actual i genera instruccions de rumb per als capÃ­tols restants.

Analitza:
1. SUBTRAMES: Quines subtrames s'estan desenvolupant correctament? Quines s'han descuidat o han desaparegut?
2. PERSONATGES: Algun personatge important porta massa capÃ­tols sense aparÃ¨ixer o amb arc estancat?
3. PREFIGURACIONS: Quines prefiguracions plantades han de recollir-se en els capÃ­tols restants? UrgÃ¨ncia?
4. DERIVA DE TRAMA: Hi ha alguna desviaciÃ³ respecte a l'arc planificat originalment que calgui corregir?
5. RITME: El ritme actual (tensiÃ³ acumulada fins ara) Ã©s adequat per arribar al clÃ­max planificat?
6. ARC MORAL DEL PROTAGONISTA: El protagonista ha mostrat RESISTÃˆNCIA genuÃ¯na a la seva transformaciÃ³? (no compten dubtes retÃ²rics o monÃ²legs interns). Hi ha hagut almenys un moment de "backsliding" on intenta tornar als seus valors originals? Si la resposta Ã©s NO a qualsevol dels dos, marca "arc_lineal" com a problema greu i recomana un capÃ­tol de reversiÃ³.

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "estat_subtrames": [
    {"nom": "nom subtrama", "estat": "activa/descuidada/resolta", "urgent": true, "nota": "breu diagnÃ²stic"}
  ],
  "personatges_absents": ["nom1", "nom2"],
  "prefiguracions_urgents": [
    {"element": "descripciÃ³", "capitol_resolucio": 15, "nota": "breu indicaciÃ³ de com resoldre-la"}
  ],
  "deriva_detectada": "descripciÃ³ breu si n'hi ha, buit si tot va bÃ©",
  "arc_lineal": false,
  "ajustos_rumb": "instruccions concretes en 3-5 lÃ­nies per als capÃ­tols restants: quins fils recuperar, quins personatges fer aparÃ¨ixer, quines tensions apujar o baixar. Escrit com a nota interna de l'arquitecte per al model que escriurÃ  els capÃ­tols."
}`
  }];

  try {
    const response = await callLLMMulti(
      msgs,
      'Ets un editor sÃ¨nior de novelÂ·la. Retornes EXCLUSIVAMENT JSON vÃ lid, sense text addicional.',
      Object.assign({}, userConfig, { maxTokens: 2000 }),
      'arquitectura'
    );
    const data = parseJsonRobust(response);
    if (data && data.ajustos_rumb) {
      ESTAT._ajustosRumb = data.ajustos_rumb;
      ESTAT._checkpointIntermedi = data;
      console.log(`Checkpoint meitat novelÂ·la (cap.${capitolActual}/${totalCapitols}):`, data.ajustos_rumb);
    }
    return data;
  } catch (err) {
    console.warn('Checkpoint intermedi: error no bloquejant:', err.message);
    return null;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EpÃ­leg Resolutiu (Sonnet) â€” FASE 7: context real
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEpileg(instruccionsOpus, userConfig) {
  const registreCtx  = buildRegistreContext(ESTAT._estructuraCapitols.length);
  const systemPrompt = buildSystemPromptCapitol();

  // Ãšltim capÃ­tol complet (o Ãºltims 3000 chars)
  const numCaps      = ESTAT._capitols_generats.length;
  const ultimCapText = numCaps > 0 && ESTAT._capitols_generats[numCaps - 1]
    ? ESTAT._capitols_generats[numCaps - 1].slice(-3000)
    : '(No disponible)';

  // Primer parÃ graf del primer capÃ­tol (per tancament circular)
  const primerCapText = ESTAT._capitols_generats[0]
    ? ESTAT._capitols_generats[0].split(/\n\n+/).filter(p => p.trim())[0] || ''
    : '';

  // Prefiguracions pendents (de la revisiÃ³ global si existeix)
  const prefsPendents = ESTAT._revisioGlobal && Array.isArray(ESTAT._revisioGlobal.prefiguracions_pendents)
    ? ESTAT._revisioGlobal.prefiguracions_pendents
    : [];

  const msgs = [{
    role: 'user',
    content: `Escriu l'EPÃLEG de la novelÂ·la seguint les instruccions de l'editor.

${buildBriefNarratiu()}

DIAGNÃ’STIC I INSTRUCCIONS DE L'EDITOR (Opus):
${instruccionsOpus ? instruccionsOpus.substring(0, 2000) : '(No disponible)'}
${registreCtx}

PRIMER PARÃ€GRAF DE LA NOVELÂ·LA (per tancar el cercle narratiu):
${primerCapText || '(No disponible)'}

ÃšLTIM CAPÃTOL (per continuÃ¯tat de to i escena):
${ultimCapText}

${prefsPendents.length > 0 ? 'PREFIGURACIONS PENDENTS DE RESOLUCIÃ“:\n' + prefsPendents.map(p => `- ${p}`).join('\n') : ''}

L'epÃ­leg ha de:
- Tancar els fils narratius indicats per l'editor
- Connectar directament amb l'escena final de l'Ãºltim capÃ­tol (continuÃ¯tat de to)
- Fer eco del primer parÃ graf de la novelÂ·la (tancament circular)
- Tenir entre 600 i 1200 paraules
- Resoldre les prefiguracions pendents si n'hi ha

Escriu directament el text de l'epÃ­leg en catalÃ , sense tÃ­tol ni notes de l'autor.`
  }];

  const response = await callLLMMulti(msgs, systemPrompt, Object.assign({}, userConfig, { maxTokens: 3500 }), 'generacio');
  return { response };
}

// â”€â”€â”€ SISTEMA 1: BÃ­blia Narrativa â€” backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function inicialitzarBiblia(userConfig) {
  const brief = buildBriefNarratiu();
  const personatgesCtx = ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0
    ? ESTAT._personatgesSeleccionats.join('\n')
    : '(No definit)';

  const msgs = [{
    role: 'user',
    content: `Crea una bÃ­blia narrativa estructurada a partir del material existent.

${brief}

CONTE ORIGINAL (resum):
${ESTAT.conteText ? ESTAT.conteText.substring(0, 2000) + (ESTAT.conteText.length > 2000 ? '\n[â€¦]' : '') : '(No disponible)'}

BÃBLIA DE MÃ“N:
${ESTAT.worldbuilding ? ESTAT.worldbuilding.substring(0, 1500) + (ESTAT.worldbuilding.length > 1500 ? '\n[â€¦]' : '') : '(No definida)'}

ELENC DE PERSONATGES:
${personatgesCtx}

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "regles_mon": ["regla del mÃ³n 1", "regla del mÃ³n 2"],
  "llocs_importants": [{"nom": "nom del lloc", "descripcio": "descripciÃ³ breu del lloc i el seu paper"}],
  "objectes_clau": [{"nom": "nom de l'objecte", "significat": "significat narratiu o simbÃ²lic"}],
  "fitxes_personatges": [
    {
      "nom": "nom",
      "motivacions": "motivaciÃ³ principal (1 frase)",
      "secrets": "secret principal o buit",
      "estat_actual": "estat breu (1 frase)"
    }
  ],
  "fets_canonics": ["fet establert que NO es pot contradir 1", "fet establert 2"]
}

IMPORTANT: El JSON ha de ser COMPLET amb TOTS els personatges de l'elenc. MantÃ©n les descripcions concises (1 frase per camp) per assegurar que el JSON no es talli.`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari creant una bÃ­blia narrativa de referÃ¨ncia. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 6000 }),
    'arquitectura'
  );

  const dades = parseJsonRobust(response);
  if (dades) {
    if (dades.regles_mon)         ESTAT.bibliaNarrativa.regles_mon         = dades.regles_mon;
    if (dades.llocs_importants)   ESTAT.bibliaNarrativa.llocs_importants   = dades.llocs_importants;
    if (dades.objectes_clau)      ESTAT.bibliaNarrativa.objectes_clau      = dades.objectes_clau;
    if (dades.fitxes_personatges) ESTAT.bibliaNarrativa.fitxes_personatges = dades.fitxes_personatges;
    const fetsInicials = normalitzarFetsCanonics(dades.fets_canonics || []);
    ESTAT.bibliaNarrativa.fets_canonics = fetsInicials.length > 0
      ? fetsInicials
      : normalitzarFetsCanonics(((ESTAT._nkg && ESTAT._nkg.fets_canonics) || []).map(f => f.descripcio));
  }
  return { response };
}

async function completarBibliaPersonatges(userConfig) {
  const biblia = ESTAT.bibliaNarrativa;
  const nomsExistents = (biblia.fitxes_personatges || []).map(f => f.nom.toLowerCase());
  const personatgesFaltants = (ESTAT._personatgesSeleccionats || []).filter(nom => {
    const nomNet = nom.replace(/\*\*/g, '').split('|')[0].split(',')[0].trim().toLowerCase();
    return !nomsExistents.some(n => n.includes(nomNet) || nomNet.includes(n));
  });

  if (personatgesFaltants.length === 0) return;

  const msgs = [{
    role: 'user',
    content: `Crea fitxes per als personatges que falten a la bÃ­blia narrativa.

PERSONATGES QUE JA TENEN FITXA: ${nomsExistents.join(', ') || '(cap)'}

PERSONATGES QUE FALTEN:
${personatgesFaltants.join('\n')}

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "fitxes_personatges": [
    {
      "nom": "nom",
      "motivacions": "motivaciÃ³ principal (1 frase)",
      "secrets": "secret principal o buit",
      "estat_actual": "estat breu (1 frase)"
    }
  ]
}

Descripcions concises: 1 frase per camp.`
  }];

  const response = await callLLMMulti(msgs,
    'Retorna EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 2000 }), 'arquitectura');

  const dades = parseJsonRobust(response);
  if (dades && dades.fitxes_personatges) {
    biblia.fitxes_personatges = (biblia.fitxes_personatges || []).concat(dades.fitxes_personatges);
    console.log(`BÃ­blia completada: ${biblia.fitxes_personatges.length} fitxes totals`);
  }
}

async function actualitzarBiblia(textCapitol, idx, userConfig) {
  const biblia = ESTAT.bibliaNarrativa;
  const bibliaCurrent = JSON.stringify({
    fitxes_personatges: biblia.fitxes_personatges || [],
    fets_canonics:      (biblia.fets_canonics || []).slice(-10)
  });

  const msgs = [{
    role: 'user',
    content: `Actualitza la bÃ­blia narrativa amb el que ha passat en el CapÃ­tol ${idx + 1}.

BÃBLIA ACTUAL (resum):
${bibliaCurrent}

CAPÃTOL ${idx + 1} GENERAT:
${textCapitol.substring(0, 4000)}${textCapitol.length > 4000 ? '\n[â€¦text truncatâ€¦]' : ''}

Identifica NOMÃ‰S canvis reals (no repeteixis el que ja Ã©s a la bÃ­blia):

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid:
{
  "nous_fets_canonics": ["nou fet establert en aquest capÃ­tol"],
  "actualitzar_personatges": [
    {"nom": "nom", "nou_estat": "nou estat emocional/fÃ­sic", "nous_secrets": "secrets revelats o nous", "motivacions": "motivaciÃ³ actualitzada si ha canviat"}
  ],
  "nous_llocs": [{"nom": "lloc nou", "descripcio": "descripciÃ³"}],
  "nous_objectes": [{"nom": "objecte nou", "significat": "significat"}]
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari actualitzant una bÃ­blia narrativa. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 1500, model: getModelConfig(userConfig).modelDraft, _esDraft: true }),
    'generacio'
  );

  const canvis = parseJsonRobust(response) || {};
  if (!Array.isArray(canvis.nous_fets_canonics) || canvis.nous_fets_canonics.length === 0) {
    const fetsNkgCapitol = ((ESTAT._nkg && ESTAT._nkg.fets_canonics) || [])
      .filter(f => Number(f.capitol_origen) === idx + 1)
      .map(f => f.descripcio);
    if (fetsNkgCapitol.length > 0) canvis.nous_fets_canonics = fetsNkgCapitol;
  }
  aplicarCanvisBiblia(canvis);
  return { response };
}

// â”€â”€â”€ SISTEMA 2: Fase de Trames â€” backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function generarTrames(userConfig) {
  const brief = buildBriefNarratiu();
  const bibliaCtx = ESTAT.bibliaNarrativa.fitxes_personatges && ESTAT.bibliaNarrativa.fitxes_personatges.length > 0
    ? '\nPERSONATGES (bÃ­blia):\n' + ESTAT.bibliaNarrativa.fitxes_personatges.map(p => `${p.nom}: ${p.motivacions || ''}`).join('\n')
    : '';

  const msgs = [{
    role: 'user',
    content: `Dissenya l'arquitectura de trames per a aquesta novelÂ·la.

${brief}

CONTE ORIGINAL:
${ESTAT.conteText || '(No disponible)'}

BÃBLIA DE MÃ“N:
${ESTAT.worldbuilding || '(No definida)'}

ELENC DE PERSONATGES:
${ESTAT._personatgesSeleccionats ? ESTAT._personatgesSeleccionats.join('\n') : '(No definit)'}${bibliaCtx}

ESTILS DE PARLA:
${ESTAT.estilsParla || '(No definits)'}

Crea un disseny de trames entrellaÃ§ades que:
1. Tingui una trama principal clara que connecti amb el final planificat
2. 2-4 subtrames que enriqueixin el mÃ³n i els personatges secundaris
3. Un mapa de com les trames s'entrelaÃ§en capÃ­tol a capÃ­tol (aproximat, 12-22 capÃ­tols)
4. Cada subtrama ha de tenir una resoluciÃ³ prÃ²pia (no necessÃ riament al capÃ­tol final)

REGLA DE REALISME D'INVESTIGACIÃ“: Prohibit utilitzar "MacGuffins" propis del cinema d'acciÃ³ (com llapis USB encriptats amb autodestrucciÃ³, missatges pÃ²stums pre-gravats, claus amagades en llocs secrets o pistes plantades de forma inversemblant). Tota investigaciÃ³ o descobriment de la veritat s'ha de fer a travÃ©s de mÃ¨todes lents i realistes: creuament de dades financeres avorrides, solÂ·licituds de transparÃ¨ncia governamental, contradiccions en documents notarials o factures, testimonis que diuen mitges veritats.

IMPORTANT: El JSON ha de ser COMPLET. El mapa_entrellacat ha de cobrir TOTS els capÃ­tols (12-22 entrades). Les notes del mapa han de ser MOLT breus (3-5 paraules mÃ xim per estalviar espai).

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "trama_principal": {
    "descripcio": "descripciÃ³ de la trama principal en 3-5 lÃ­nies",
    "conflicte_central": "el conflicte central en una frase",
    "arc_protagonista": "com evoluciona el protagonista",
    "resolucio": "com i quan es resol"
  },
  "subtrames": [
    {
      "nom": "nom de la subtrama",
      "descripcio": "descripciÃ³ breu",
      "personatges_implicats": ["nom1", "nom2"],
      "capitol_inici": 2,
      "capitol_resolucio": 10,
      "com_entrellaÃ§a": "com s'entrellaÃ§a amb la trama principal"
    }
  ],
  "mapa_entrellacat": [
    {"capitol": 1, "trames_actives": ["trama_principal"], "notes": "establiment del mÃ³n"},
    {"capitol": 2, "trames_actives": ["trama_principal", "subtrama_1"], "notes": "s'introdueix la subtrama 1"}
  ]
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un arquitecte narratiu expert en construcciÃ³ de trames entrellaÃ§ades. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 8192 }),
    'arquitectura'
  );

  return { response };
}

async function completarMapaTrames(tramesTotals, capsEsperats, userConfig) {
  const tp = tramesTotals.trama_principal;
  const tpDesc = tp ? (typeof tp === 'string' ? tp : (tp.descripcio || JSON.stringify(tp))) : '?';
  const subtramesNoms = (tramesTotals.subtrames || []).map(st => st.nom).join(', ');
  const msgs = [{
    role: 'user',
    content: `Genera el mapa d'entrellaÃ§at COMPLET per a exactament ${capsEsperats} capÃ­tols.

TRAMA PRINCIPAL: ${tpDesc}
SUBTRAMES: ${subtramesNoms || '(cap)'}

Retorna EXCLUSIVAMENT un JSON vÃ lid amb EXACTAMENT ${capsEsperats} entrades:
{
  "mapa_entrellacat": [
    {"capitol": 1, "trames_actives": ["trama_principal"], "notes": "breu 3-5 paraules"},
    {"capitol": 2, "trames_actives": ["trama_principal", "nom_subtrama"], "notes": "breu"},
    ... fins a capitol ${capsEsperats}
  ]
}

CRÃTIC: Han de ser EXACTAMENT ${capsEsperats} entrades. Notes de 3-5 paraules MÃ€XIM.`
  }];
  const response = await callLLMMulti(msgs,
    'Retorna EXCLUSIVAMENT JSON vÃ lid. Cap text addicional.',
    Object.assign({}, userConfig, { maxTokens: 2048 }), 'arquitectura');
  return { response };
}

// â”€â”€â”€ SISTEMA 4: Checkpoint de coherÃ¨ncia â€” backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function executarCheckpoint(idx, userConfig) {
  const brief = buildBriefNarratiu();

  const capitolsEscrits = ESTAT._capitols_generats
    .slice(0, idx + 1)
    .map((text, i) => {
      if (!text) return null;
      const resum = (ESTAT.llibreRegistre.capitols[i] && ESTAT.llibreRegistre.capitols[i].resum_capitol)
        || text.substring(0, 300) + 'â€¦';
      return `CapÃ­tol ${i + 1}: ${resum}`;
    })
    .filter(Boolean)
    .join('\n');

  const ajustosAnteriors = ESTAT._ajustosRumb
    ? '\nAJUSTOS DE RUMB ANTERIORS:\n' + (typeof ESTAT._ajustosRumb === 'string' ? ESTAT._ajustosRumb : JSON.stringify(ESTAT._ajustosRumb))
    : '';

  // DetecciÃ³ programÃ tica de repeticions temÃ tiques (NKG)
  const repetidesTematiques = detectarRepeticionsTematiques();
  const repetidesTematiquesCtx = repetidesTematiques
    ? '\nREVELACIONS REPETIDES DETECTADES:\n' + repetidesTematiques.map(r =>
        `- "${r.tema}" repetida ${r.cops} vegades (caps. ${r.capitols.join(', ')})`
      ).join('\n') +
      '\nINSTRUCCIÃ“: Si una revelaciÃ³ emocional ja s\'ha produÃ¯t, el segÃ¼ent capÃ­tol ha de COMPLICAR-LA (afegir una capa nova, una contradicciÃ³, un cost emocional diferent) o SUPERAR-LA (el personatge ja ho sap i actua en conseqÃ¼Ã¨ncia, no ho "redescobeix").'
    : '';

  const tramesCtx = ESTAT.trames.trama_principal
    ? `\nTRAMA PRINCIPAL: ${typeof ESTAT.trames.trama_principal === 'string' ? ESTAT.trames.trama_principal : (ESTAT.trames.trama_principal.descripcio || '')}
SUBTRAMES: ${ESTAT.trames.subtrames.length > 0 ? ESTAT.trames.subtrames.map(st => st.nom + ': ' + (st.descripcio || '')).join(' | ') : '(cap)'}`
    : '';

  const msgs = [{
    role: 'user',
    content: `Fes un checkpoint de coherÃ¨ncia narrativa desprÃ©s del CapÃ­tol ${idx + 1}.

${brief}${tramesCtx}

CAPÃTOLS ESCRITS FINS ARA:
${capitolsEscrits}${ajustosAnteriors}${repetidesTematiquesCtx}

Verifica:
1. CoherÃ¨ncia entre capÃ­tols (no contradiccions, no lapsus de memÃ²ria dels personatges)
2. Les subtrames s'estan desenvolupant com estava planificat
3. El ritme narratiu Ã©s adequat (ni massa accelerat ni estancat)
4. Les prefiguracions plantades es mantenen sense resoldre prematurament
5. VITALITAT DELS SECUNDARIS: Per a cada personatge secundari, indica si ha tingut almenys una escena d'autonomia en els Ãºltims 4 capÃ­tols. Si algun secundari porta 4+ capÃ­tols sent nomÃ©s reactiu al protagonista, marca'l com a "estancat" i recomana una escena d'autonomia.

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid:
{
  "puntuacio_coherencia": 8,
  "valoracio_general": "descripciÃ³ breu de l'estat de la novelÂ·la en una frase",
  "problemes_detectats": ["problema concret 1 si n'hi ha"],
  "recomanacions": ["recomanaciÃ³ especÃ­fica per als prÃ²xims capÃ­tols"],
  "secundaris_estancats": ["nom del personatge estancat si n'hi ha"],
  "ajustos_rumb": "instruccions especÃ­fiques per als capÃ­tols ${idx + 2}-${idx + 4} si cal ajustar el rumb (buit si tot va bÃ©)"
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari fent un checkpoint de coherÃ¨ncia narrativa. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 1500 }),
    'arquitectura'
  );

  const dades = parseJsonRobust(response);
  mostrarCheckpoint(dades, idx);
  return { response, dades };
}

async function executarLoopCoherenciaFinal(userConfig) {
  const total = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols.length : 0;
  if (total <= 0) return;

  const idxFinal = total - 1;
  const puntuacioObjectiu = 8;
  const maxIteracions = 3;

  for (let iter = 1; iter <= maxIteracions; iter++) {
    const loaderEl = document.getElementById('loader-11-text');
    if (loaderEl) loaderEl.textContent = `ğŸ” RevisiÃ³ final de coherÃ¨ncia (${iter}/${maxIteracions})â€¦`;

    let dades = null;
    try {
      const checkpoint = await executarCheckpoint(idxFinal, userConfig);
      dades = checkpoint ? checkpoint.dades : null;
    } catch (err) {
      console.warn('Loop final coherÃ¨ncia: checkpoint fallit:', err.message);
      break;
    }

    const punts = Number((dades && dades.puntuacio_coherencia) || 0);
    if (punts >= puntuacioObjectiu) {
      toast(`âœ… CoherÃ¨ncia final validada (${punts}/10).`);
      return;
    }

    const blocInici = Math.max(0, idxFinal - (2 + (iter - 1) * 2));
    try {
      if (loaderEl) loaderEl.textContent = `ğŸ› ï¸ Aplicant correccions finals (${iter}/${maxIteracions})â€¦`;
      await microReescripturaBlocOpus(blocInici, idxFinal, userConfig);
    } catch (err) {
      console.warn('Loop final coherÃ¨ncia: micro-reescriptura fallida:', err.message);
      break;
    }
  }

  toast("â„¹ï¸ RevisiÃ³ final completada amb marge de millora. Revisa control d'arcs per ajustos addicionals.");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10.5: Generar Escaleta per Bloc de CapÃ­tols (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEscaletaBloc(capitols, offset, userConfig) {
  const brief = buildBriefNarratiu();
  const capsText = capitols.map((c, i) => `Cap. ${offset + i + 1}: ${c.titol || ''} â€” ${c.resum || ''}`).join('\n');
  const corbaTensio = ESTAT._corbaTensio || [];

  // Arc moral del protagonista (si existeix)
  const arcMoral = ESTAT._arcMoral;
  const arcMoralCtx = arcMoral ? (() => {
    const capsBloc = capitols.map((_, i) => offset + i + 1);
    const punts = [];
    if (arcMoral.backsliding && capsBloc.includes(arcMoral.backsliding.capitol)) {
      punts.push(`BACKSLIDING (cap. ${arcMoral.backsliding.capitol}): Almenys 2 escenes on el protagonista intenta genuÃ¯nament tornar al seu antic jo. Ha de ser un intent CREÃBLE, no un gest simbÃ²lic. DescripciÃ³: ${arcMoral.backsliding.descripcio}`);
    }
    if (arcMoral.punt_no_retorn && capsBloc.includes(arcMoral.punt_no_retorn.capitol)) {
      punts.push(`PUNT DE NO RETORN (cap. ${arcMoral.punt_no_retorn.capitol}): L'escena de decisiÃ³ ha de ser AMBIGUA moralment â€” el lector ha de poder defensar tant la decisiÃ³ com la seva alternativa. DescripciÃ³: ${arcMoral.punt_no_retorn.descripcio}`);
    }
    if (arcMoral.primera_fissura && capsBloc.includes(arcMoral.primera_fissura.capitol)) {
      punts.push(`PRIMERA FISSURA (cap. ${arcMoral.primera_fissura.capitol}): El moment on els principis del protagonista fallen per primera vegada. DescripciÃ³: ${arcMoral.primera_fissura.descripcio}`);
    }
    return punts.length > 0 ? '\n\nVERIFICACIÃ“ D\'ARC MORAL DEL PROTAGONISTA:\n' + punts.join('\n') : '';
  })() : '';
  const prompt = `Ets un dramaturg expert. Genera una escaleta detallada per escenes per als capÃ­tols segÃ¼ents de la novelÂ·la.

BRIEF:
${brief}

CAPÃTOLS A ESCALETEJAR:
${capsText}

ESCENES PER CAPÃTOL (adapta al ritme del capÃ­tol):
- Genera entre 5 i 8 escenes per a aquest capÃ­tol. (No menys de 5).
- CapÃ­tols d'exposiciÃ³/respiraciÃ³ (nivell tensiÃ³ â‰¤4): 5-6 escenes (~650 paraules/escena). Aprofita per desplegar el mÃ³n, explorar relacions i construir subtexte emocional.
- CapÃ­tols de desenvolupament (nivell tensiÃ³ 5-7): 6-7 escenes (~700 paraules/escena). Alterna acciÃ³ i respiraciÃ³; cada escena ha de capgirar o complicar la situaciÃ³ anterior.
- CapÃ­tols de clÃ­max/acciÃ³ (nivell tensiÃ³ â‰¥8): 7-8 escenes (~550 paraules/escena, ritme rÃ pid). REGLA CRÃTICA: En els clÃ­maxs, crea SEMPRE una escena de beat "introspecciÃ³" per a la PRESA DE DECISIÃ“ (mostrant el cost fÃ­sic/mental), separada i prÃ¨via a l'escena d'"acciÃ³" posterior.
- CapÃ­tol final/resoluciÃ³: 5-6 escenes (~750 paraules/escena, ritme pausat). DÃ³na espai per tancar fils secundaris i deixar una ressonÃ ncia emocional duradora.

TOTAL OBJECTIU: ~3.500-5.000 paraules per capÃ­tol. La novelÂ·la completa ha de fer entre 60.000 i 100.000 paraules (12-22 capÃ­tols Ã— ~4.000 paraules).

CORBA DE TENSIÃ“ (per orientar el ritme de cada capÃ­tol):
${corbaTensio.length > 0 ? corbaTensio.map(t => `Cap.${t.capitol}: nivell ${t.nivell} (${t.tipus})`).join(', ') : '(no disponible)'}${arcMoralCtx}

Cada escena ha d'incloure (camps OBLIGATORIS, res mÃ©s):
- nom: tÃ­tol breu (3-5 paraules)
- paraules_objectiu: nombre enter
- funcio_narrativa: 1 frase curta (mÃ xim 10 paraules)
- personatges: array de noms
- beat_narratiu: "diÃ leg" | "acciÃ³" | "introspecciÃ³" | "descripciÃ³"
- REGLA DE DIÃ€LEG: Com a mÃ­nim el 50% de les escenes d'un capÃ­tol han de tenir el "beat_narratiu" fixat a "diÃ leg". Prioritza sempre la interacciÃ³ verbal.
- Cada escena ha de tenir un objectiu fÃ­sic (avanÃ§ar en la trama) i un objectiu emocional o reflexiu (introspecciÃ³, record, subtrama).

NO incloguis emocio_entrada, emocio_sortida ni punt_inflexio per estalviar espai.

REGLA DE PROFUNDITAT DELS SECUNDARIS:
- Cada personatge secundari ha de tenir almenys 1 escena cada 4 capÃ­tols on actuÃ¯ per iniciativa prÃ²pia (no com a reacciÃ³ al protagonista).
- En aquestes escenes, el secundari ha de mostrar un desig, por o contradicciÃ³ que NO estigui directament relacionada amb la trama principal.
- Indica al camp "funcio_narrativa" quan una escena Ã©s d'"autonomia del secundari" amb el tag [AUTONOMIA: Nom].

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "escaletes": [
    {
      "capitol": 1,
      "titol": "tÃ­tol del capÃ­tol",
      "escenes": [
        {
          "nom": "nom breu",
          "paraules_objectiu": 450,
          "funcio_narrativa": "frase curta",
          "personatges": ["nom1"],
          "beat_narratiu": "diÃ leg"
        }
      ]
    }
  ]
}`;
  const msgs = [{ role: 'user', content: prompt }];
  const models = getModelConfig(userConfig);
  const response = await callLLMMulti(
    msgs,
    'Ets un dramaturg expert en narrativa i estructura d\'escenes.',
    Object.assign({}, userConfig, { maxTokens: 8192, model: models.modelArquitecte }),
    'arquitectura'
  );
  return { response };
}

async function cridaAPI_GenerarText(promptEscena, systemPrompt, userConfig, maxTokensOverride) {
  const models = getModelConfig(userConfig);
  const cfg = Object.assign({}, userConfig, {
    maxTokens: maxTokensOverride || Math.max(1500, (promptEscena.length / 2) | 0),
    model: models.modelGeneracio
  });
  return await callLLMMulti([{ role: 'user', content: promptEscena }], systemPrompt, cfg, 'generacio');
}

async function avaluarQualitatLiteraria(textEscena, userConfig) {
  const models = getModelConfig(userConfig);
  const textNet = String(textEscena || '').slice(0, 6000);

  // DetecciÃ³ programÃ tica de telling emocional (sense cost LLM)
  const instanciesTelling = detectarTellingEmocional(textNet);
  const tellingCtx = instanciesTelling.length > 3
    ? `\n   - TELLING EMOCIONAL DETECTAT: El text contÃ© ${instanciesTelling.length} instÃ ncies d'emocions explicades directament (${instanciesTelling.slice(0, 3).map(m => `"${m}"`).join(', ')}â€¦). Marca com a NO APROVAT si n'hi ha mÃ©s de 2 per escena.`
    : '';

  const promptAvaluador = `Ets un editor literari exigent i un filÃ²leg expert en llengua catalana. Llegeix aquest text:

"""${textNet}"""

La teva tasca tÃ© dues parts:
1. AVALUACIÃ“ LITERÃ€RIA: Rebutja l'escena immediatament si detectes qualsevol d'aquests errors:
   - INFO-DUMPING: Personatges explicant coses que l'altre personatge ja sap, Ãºnicament perquÃ¨ el lector se n'assabenti. Ã‰s el pecat capital de la narrativa.
   - MONÃ’LEG DE DOLENT: Antagonistes o figures de poder que expliquen els seus plans, motivacions o el funcionament del sistema de forma directa (monÃ²lecs estil James Bond). Les figures de poder han de parlar en eufemismes, mitges veritats i to institucional.
   - CLIXÃ‰S TECNOLÃ’GICS O D'ACCIÃ“: Teclejar frenÃ¨ticament per aturar un hackeig, objectes d'espia hiper-tecnolÃ²gics, USB encriptats, pistes amagades en llocs inversemblants.
   - CANVIS EMOCIONALS NO GUANYATS: Personatges que canvien radicalment de postura (moral, emocional, ideolÃ²gica) sense un procÃ©s de dubte i racionalitzaciÃ³ prÃ¨vi. Un sol capÃ­tol no Ã©s suficient per a una caiguda moral.
   - CLIXÃ‰S GENÃˆRICS: Resolucions mandroses, diÃ legs robÃ²tics, frases fetes del gÃ¨nere.
   - SOBRECÃ€RREGA SENSORIAL: Rebutja si hi ha mÃ©s de 2 adjectius per frase de mitjana o si cada parÃ graf contÃ© descripcions sensorials. La prosa ha de respirar: alterna parÃ grafs sensorials amb parÃ grafs d'acciÃ³ pura o diÃ leg sec.${tellingCtx}
2. CORRECCIÃ“ LINGÃœÃSTICA: Identifica qualsevol falta d'ortografia, castellanisme, expressiÃ³ calcada d'altres idiomes o gramÃ tica incorrecta en catalÃ .

Retorna ÃšNICAMENT un objecte JSON amb aquest format exacte:
{
  "aprovat": true/false,
  "critiques": "Descriu els errors narratius i/o llista les paraules/expressions incorrectes en catalÃ  i la seva forma correcta. Si tot Ã©s perfecte, deixa-ho buit."
}`;

  try {
    const raw = await callLLMMulti(
      [{ role: 'user', content: promptAvaluador }],
      'Ets un jutge literari i corrector lingÃ¼Ã­stic expert en catalÃ . Retorna Ãºnicament JSON vÃ lid.',
      Object.assign({}, userConfig, { maxTokens: 500, model: models.modelArquitecte }),
      'arquitectura'
    );
    const parsed = parseJsonRobust(raw);
    if (parsed && typeof parsed.aprovat === 'boolean') {
      return {
        aprovat: parsed.aprovat,
        critiques: typeof parsed.critiques === 'string' ? parsed.critiques : ''
      };
    }
  } catch (err) {
    console.warn('Jutge Literari: error de validaciÃ³, s\'aprova per no bloquejar:', err.message);
  }

  return { aprovat: true, critiques: '' };
}

async function generarIValidarEscena(promptEscena, systemPrompt, userConfig, opts = {}) {
  const intentsMaxims = Math.max(1, Number(opts.intentsMaxims) || 2);
  const maxTokens = opts.maxTokens || 3000;
  let escenaAprovada = false;
  let textEscenaGenerada = '';
  let intents = 0;
  let promptTreball = String(promptEscena || '');

  while (!escenaAprovada && intents < intentsMaxims) {
    intents++;
    textEscenaGenerada = await cridaAPI_GenerarText(promptTreball, systemPrompt, userConfig, maxTokens);

    const veredicte = await avaluarQualitatLiteraria(textEscenaGenerada, userConfig);
    if (veredicte.aprovat) {
      escenaAprovada = true;
    } else {
      console.log('El Jutge Literari ha rebutjat l\'escena. Reescrivint... Motius:', veredicte.critiques);
      promptTreball += `\n\nCRÃTICA DE L'EDITOR: La versiÃ³ anterior tenia els segÃ¼ents problemes: ${veredicte.critiques || 'massa clixÃ©s o prosa plana'}. Reescriu l'escena solucionant AQUESTS problemes especÃ­fics i evitant llocs comuns.`;
    }
  }

  return textEscenaGenerada || '';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 11: Escriure capÃ­tol per escenes (usa escaleta)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function escriureCapitolPerEscenes(idx, userConfig) {
  const escaletaCapitol = ESTAT._escaletes.find(e => e.capitol === idx + 1);
  if (!escaletaCapitol || !escaletaCapitol.escenes || escaletaCapitol.escenes.length === 0) {
    return await escriureCapitol(idx, userConfig);
  }
  const systemPrompt = buildSystemPromptCapitol();
  const contextCapitol = buildContextCapitol(idx);
  const escenes = escaletaCapitol.escenes;
  const instruccionsFinalCapitol = generarInstruccionsGanxoFinalCapitol(idx);
  let textsEscenes = [];
  for (let i = 0; i < escenes.length; i++) {
    const escena = escenes[i];
    if (document.getElementById('loader-11-text')) {
      document.getElementById('loader-11-text').textContent = `Escrivint capÃ­tol ${idx + 1} â€” Escena ${i + 1}/${escenes.length}: ${escena.nom || ''}â€¦`;
    }
    const esUltimaEscena = i === escenes.length - 1;
    const tensioEscena = (ESTAT._corbaTensio || []).find(t => t.capitol === idx + 1);
    const instruccioTensioEscena = obtenirInstruccionsDeTensio(tensioEscena ? tensioEscena.nivell : 5);
    const textEnllac = i > 0 ? obtenirTextEnllac(textsEscenes[i - 1]) : '';
    const tipusTransicio = i > 0 ? determinarTipusTransicio(escenes[i - 1], escena) : 'continuacio_directa';
    const instruccionsTransicio = buildInstruccionsTransicio(textEnllac, tipusTransicio);
    const promptEscena = `${contextCapitol}

## ESCENA ACTUAL A ESCRIURE
Escena ${i + 1} de ${escenes.length}: **${escena.nom || ''}**
FunciÃ³ narrativa: ${escena.funcio_narrativa || ''}
Personatges: ${(escena.personatges || []).join(', ')}
Paraules objectiu: ${escena.paraules_objectiu || 400}
${escena.punt_inflexio ? 'âš¡ Aquesta escena contÃ© un punt d\'inflexiÃ³ important.' : ''}
Ritme i tensiÃ³ objectiu: ${instruccioTensioEscena}

${instruccionsTransicio}${esUltimaEscena ? `TANCAMENT DEL CAPÃTOL:
${instruccionsFinalCapitol}

` : ''}Escriu ara aquesta escena en prosa literÃ ria completa, sense tÃ­tols ni metadades. Aproximadament ${escena.paraules_objectiu || 400} paraules.${!esUltimaEscena ? ' IMPORTANT: no tanquis la situaciÃ³ al final; deixa-la en continuÃ¯tat orgÃ nica cap a la segÃ¼ent escena.' : ''}`;
    const res = await generarIValidarEscena(
      promptEscena,
      systemPrompt,
      userConfig,
      { intentsMaxims: 2, maxTokens: Math.max(3000, (escena.paraules_objectiu || 700) * 2) }
    );
    textsEscenes.push(res || '');
  }
  return { response: textsEscenes.join('\n\n') };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CompressiÃ³ de MemÃ²ria Narrativa (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function comprimirMemoria(finsCapitol, userConfig) {
  const resumsAComprimir = (ESTAT.llibreRegistre.capitols || [])
    .slice(0, finsCapitol)
    .map(c => c ? c.resum_capitol : null)
    .filter(r => r);
  if (resumsAComprimir.length < 3) return;
  const prompt = `Ets un expert en narrativa. A continuaciÃ³ tens els resums dels primers ${finsCapitol} capÃ­tols d'una novelÂ·la. Crea una sinopsi comprimida en prosa fluÃ¯da de 400-500 paraules que capturi els elements essencials: trames principals, desenvolupament dels personatges, moments clau, i l'estat emocional i narratiu en aquest punt de la novelÂ·la.

RESUMS:
${resumsAComprimir.map((r, i) => `Cap. ${i + 1}: ${r}`).join('\n\n')}

Escriu la sinopsi en prosa contÃ­nua, sense llistes ni tÃ­tols. Ha de ser Ãºtil com a context per escriure els capÃ­tols segÃ¼ents.`;
  const msgs = [{ role: 'user', content: prompt }];
  const res = await callLLMMulti(
    msgs,
    'Ets un expert en sÃ­ntesi narrativa.',
    Object.assign({}, userConfig, { maxTokens: 1200 }),
    'arquitectura'
  );
  ESTAT._memoriasComprimides.push({
    finsCap: finsCapitol,
    text: res || ''
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NKG v4: Narrative Knowledge Graph
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function crearNKG() {
  return {
    personatges: {},
    llocs: {},
    objectes: {},
    fets_canonics: [],
    esdeveniments: [],
    relacions: [],
    ultima_actualitzacio: { capitol: 0, escena: 0 },
    versio: 1
  };
}

function nkgNormalitzarNom(nom) {
  if (!nom) return '';
  return nom.toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/\s+/g, '_').trim();
}

function nkgQueryPersonatge(nom) {
  const nkg = ESTAT._nkg;
  if (!nkg) return null;
  const clau = nkgNormalitzarNom(nom);
  const pers = nkg.personatges[clau];
  if (!pers) return null;

  const rels = nkg.relacions.filter(r =>
    nkgNormalitzarNom(r.origen) === clau || nkgNormalitzarNom(r.desti) === clau
  );
  const objectes = Object.values(nkg.objectes).filter(o =>
    o.posseidor && nkgNormalitzarNom(o.posseidor) === clau
  );
  const events = nkg.esdeveniments
    .filter(e => e.personatges_involucrats.some(p => nkgNormalitzarNom(p) === clau))
    .slice(-3);

  return { ...pers, relacions: rels, objectes_possedits: objectes, ultims_esdeveniments: events };
}

function nkgQueryEscenaContext(escenaSpec) {
  const nkg = ESTAT._nkg;
  if (!nkg) return '';

  const parts = [];
  const persPresents = escenaSpec.personatges || [];

  if (persPresents.length > 0) {
    parts.push('PERSONATGES EN ESCENA:');
    persPresents.forEach(nom => {
      const p = nkgQueryPersonatge(nom);
      if (p) {
        let desc = `â€¢ ${p.nom}: ${p.estat_emocional || 'neutre'}`;
        if (p.estat_fisic) desc += ` | FÃ­sic: ${p.estat_fisic}`;
        if (p.indumentaria_actual) desc += ` | Roba: ${p.indumentaria_actual}`;
        if (p.objectes_inventari && p.objectes_inventari.length > 0) desc += ` | Inventari: ${p.objectes_inventari.join(', ')}`;
        if (p.ubicacio) desc += ` | A: ${p.ubicacio}`;
        if (p.objectius && p.objectius.length > 0) desc += ` | Vol: ${p.objectius[0]}`;
        let passiuEmocional = p.passiu_emocional || '';
        if (!passiuEmocional && Array.isArray(p.traumes) && p.traumes.length > 0) passiuEmocional = p.traumes[0];
        if (!passiuEmocional && Array.isArray(p.pors) && p.pors.length > 0) passiuEmocional = p.pors[0];
        if (!passiuEmocional && Array.isArray(p.deutes) && p.deutes.length > 0) passiuEmocional = p.deutes[0];
        if (!passiuEmocional && ESTAT.bibliaNarrativa && Array.isArray(ESTAT.bibliaNarrativa.fitxes_personatges)) {
          const fitxa = ESTAT.bibliaNarrativa.fitxes_personatges.find(f => nkgNormalitzarNom(f.nom || '') === nkgNormalitzarNom(nom));
          if (fitxa) passiuEmocional = fitxa.secrets || fitxa.estat_actual || '';
        }
        if (passiuEmocional) desc += ` | Passiu emocional latent: ${passiuEmocional}`;
        if (p.secrets && p.secrets.length > 0) desc += ` | Amaga: ${p.secrets[0]}`;
        parts.push(desc);

        if (p.relacions) {
          p.relacions.forEach(r => {
            const altreNom = nkgNormalitzarNom(r.origen) === nkgNormalitzarNom(nom) ? r.desti : r.origen;
            if (persPresents.some(pp => nkgNormalitzarNom(pp) === nkgNormalitzarNom(altreNom))) {
              parts.push(`  â†” ${altreNom}: ${r.tipus} (confianÃ§a:${r.confianca}/10, tensiÃ³:${r.tensio}/10)`);
            }
          });
        }
      }
    });
  }

  if (escenaSpec.lloc) {
    const lloc = nkg.llocs[nkgNormalitzarNom(escenaSpec.lloc)];
    if (lloc) {
      parts.push(`\nLLOC: ${lloc.nom} â€” ${lloc.descripcio_sensorial || ''} (${lloc.ambient || ''})`);
    }
  }

  const objectesRellevants = Object.values(nkg.objectes).filter(o => {
    if (o.ubicacio && escenaSpec.lloc && nkgNormalitzarNom(o.ubicacio) === nkgNormalitzarNom(escenaSpec.lloc)) return true;
    if (o.posseidor && persPresents.some(p => nkgNormalitzarNom(p) === nkgNormalitzarNom(o.posseidor))) return true;
    return false;
  });
  if (objectesRellevants.length > 0) {
    parts.push('\nOBJECTES PRESENTS:');
    objectesRellevants.forEach(o => {
      parts.push(`â€¢ ${o.nom}${o.significat_simbolic ? ' â€” ' + o.significat_simbolic : ''}`);
    });
  }

  return parts.join('\n');
}

function nkgDetectarContradiccions(nouFet) {
  const nkg = ESTAT._nkg;
  if (!nkg) return [];
  const contradiccions = [];

  nkg.fets_canonics.forEach(() => {
    if (nouFet.personatge) {
      const nomNorm = nkgNormalitzarNom(nouFet.personatge);
      const pers = nkg.personatges[nomNorm];
      if (pers && !pers.viu && nouFet.descripcio && nouFet.descripcio.toLowerCase().includes(pers.nom.toLowerCase())) {
        contradiccions.push(`âš  ${pers.nom} Ã©s mort perÃ² apareix al nou fet`);
      }
    }
  });

  if (nouFet.tipus === 'ubicaciÃ³' && nouFet.personatge) {
    const nomNorm = nkgNormalitzarNom(nouFet.personatge);
    const pers = nkg.personatges[nomNorm];
    if (pers && pers.ubicacio && nouFet.descripcio !== pers.ubicacio) {
      contradiccions.push(`â„¹ ${pers.nom} estava a "${pers.ubicacio}", nou fet el posa a "${nouFet.descripcio}"`);
    }
  }

  return contradiccions;
}

function obtenirContextCapitolEnCurs(capitol, escenaIdx) {
  const capIdx = capitol - 1;
  if (!ESTAT._escenes_generades || !ESTAT._escenes_generades[capIdx] || escenaIdx <= 0) return '';

  const escenesCap = ESTAT._escenes_generades[capIdx];
  const blocs = [];
  for (let i = 0; i < escenaIdx; i++) {
    const txt = escenesCap[i];
    if (!txt) continue;
    const resumCurt = txt.length > 900 ? txt.slice(-900) : txt;
    blocs.push(`Escena ${i + 1}: ${resumCurt}`);
  }

  if (blocs.length === 0) return '';
  return `
CONTINUÃTAT DEL CAPÃTOL EN CURS (NO REPETIR AQUEST CONTINGUT):
${blocs.join('\n\n')}`;
}


function obtenirUltimesEscenes(n, capitolActual, escenaActual) {
  const fragments = [];

  if (ESTAT._escenes_generades && Object.keys(ESTAT._escenes_generades).length > 0) {
    const totesEscenes = [];
    for (const [capIdx, escenes] of Object.entries(ESTAT._escenes_generades)) {
      for (const [escIdx, text] of Object.entries(escenes)) {
        totesEscenes.push({ cap: parseInt(capIdx), esc: parseInt(escIdx), text: text });
      }
    }
    totesEscenes.sort((a, b) => a.cap !== b.cap ? a.cap - b.cap : a.esc - b.esc);

    const anteriors = totesEscenes.filter(e =>
      e.cap < capitolActual - 1 || (e.cap === capitolActual - 1 && e.esc < escenaActual)
    );
    const ultimes = anteriors.slice(-n);
    ultimes.forEach(e => {
      const text = e.text.length > 1600 ? '...' + e.text.slice(-1600) : e.text;
      fragments.push(text);
    });
  } else if (ESTAT._capitols_generats) {
    const capAnterior = capitolActual - 2;
    if (capAnterior >= 0 && ESTAT._capitols_generats[capAnterior]) {
      const text = ESTAT._capitols_generats[capAnterior];
      const ultims = text.split(/\n\n+/).slice(-3).join('\n\n');
      fragments.push(ultims.length > 1600 ? '...' + ultims.slice(-1600) : ultims);
    }
  }

  return fragments.length > 0 ? fragments.join('\n\n---\n\n') : '';
}

function nkgGenerarContextMinim(escenaSpec) {
  const parts = [];

  // CAPA 1: Estat viu del NKG (~200-300 tokens)
  const contextNKG = nkgQueryEscenaContext(escenaSpec);
  if (contextNKG) parts.push(contextNKG);

  // CAPA 2: CapÃ­tols anteriors literals (si hi caben en context)
  const capIdxActual = Math.max(0, (escenaSpec.capitol || 1) - 1);
  const capsContext = buildContextCapitolsComplets(capIdxActual);
  if (capsContext) parts.push(capsContext);

  // CAPA 3: Ãšltimes 2 escenes literals (~800 tokens)
  const ultimesEscenes = obtenirUltimesEscenes(2, escenaSpec.capitol, escenaSpec.escena || 1);
  if (ultimesEscenes) {
    parts.push('\nTEXT RECENT (mantÃ© continuÃ¯tat de veu i to):\n' + ultimesEscenes);
  }

  // Escaleta de l'escena actual
  if (escenaSpec.escaleta) {
    parts.push('\nESCALETA D\'AQUESTA ESCENA:');
    if (escenaSpec.escaleta.objectiu_dramatic) parts.push(`Objectiu dramÃ tic: ${escenaSpec.escaleta.objectiu_dramatic}`);
    if (escenaSpec.escaleta && (escenaSpec.escaleta.emocio_entrada || escenaSpec.escaleta.emocio_sortida)) {
      parts.push(`TransiciÃ³ emocional: ${escenaSpec.escaleta.emocio_entrada || '?'} â†’ ${escenaSpec.escaleta.emocio_sortida || '?'}`);
    }
    if (escenaSpec.escaleta.beat_narratiu) parts.push(`Beat narratiu: ${escenaSpec.escaleta.beat_narratiu}`);
  }

  // Prefiguracions actives
  const prefs = getPrefiguracionsActives(escenaSpec.capitol - 1);
  if (prefs.aPlantarAra.length > 0) {
    parts.push('\nPREFIGURACIONS A PLANTAR (subtilment):');
    prefs.aPlantarAra.forEach(p => parts.push(`- ${p.element}`));
  }
  if (prefs.aRecollirAra.length > 0) {
    parts.push('\nPREFIGURACIONS A RECOLLIR:');
    prefs.aRecollirAra.forEach(p => parts.push(`- ${p.element}`));
  }

  return parts.join('\n');
}

function nkgInicialitzar() {
  ESTAT._nkg = crearNKG();
  const nkg = ESTAT._nkg;

  // Poblar personatges des de l'elenc
  if (ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0) {
    ESTAT._personatgesSeleccionats.forEach(nom => {
      const clau = nkgNormalitzarNom(nom);
      if (clau) {
        nkg.personatges[clau] = {
          nom: nom,
          estat_fisic: '',
          estat_emocional: 'neutre',
          indumentaria_actual: '',
          objectes_inventari: [],
          objectes_descartats: [],
          ubicacio: '',
          objectius: [],
          secrets: [],
          viu: true,
          primera_aparicio: 0
        };
      }
    });
  }

  // Poblar lloc principal des del worldbuilding
  if (ESTAT.localitzacioTriada) {
    const clau = nkgNormalitzarNom(ESTAT.localitzacioTriada);
    const wbText = ESTAT.worldbuilding
      ? (typeof ESTAT.worldbuilding === 'string' ? ESTAT.worldbuilding : JSON.stringify(ESTAT.worldbuilding))
      : '';
    nkg.llocs[clau] = {
      nom: ESTAT.localitzacioTriada,
      descripcio_sensorial: wbText.substring(0, 200),
      ambient: ''
    };
  }

  // Fet canÃ²nic inicial des de l'arc global
  if (ESTAT._arcGlobal) {
    nkg.fets_canonics.push({
      descripcio: `Arc global: ${ESTAT._arcGlobal.substring(0, 200)}`,
      capitol_origen: 0,
      categoria: 'estructura'
    });
  }

  // Inicialitzar emmagatzematge d'escenes
  ESTAT._escenes_generades = {};

  console.log('NKG inicialitzat:', Object.keys(nkg.personatges).length, 'personatges,', Object.keys(nkg.llocs).length, 'llocs');
}


function nkgAplicarActualitzacions(dades, capitol, escena) {
  const nkg = ESTAT._nkg;
  if (!nkg) return;

  const personatgesActualitzats = dades.personatges || dades.personatges_actualitzats || [];
  if (personatgesActualitzats.length > 0) {
    personatgesActualitzats.forEach(p => {
      const clau = nkgNormalitzarNom(p.nom);
      if (!nkg.personatges[clau]) {
        nkg.personatges[clau] = {
          nom: p.nom,
          estat_fisic: '',
          estat_emocional: p.estat_emocional || '',
          indumentaria_actual: p.indumentaria_actual || '',
          objectes_inventari: Array.isArray(p.objectes_inventari) ? p.objectes_inventari : [],
          objectes_descartats: Array.isArray(p.objectes_descartats) ? p.objectes_descartats : [],
          ubicacio: p.ubicacio || '',
          objectius: p.nous_objectius || [],
          secrets: p.nous_secrets || [],
          viu: p.viu !== undefined ? p.viu : true,
          primera_aparicio: capitol
        };
      } else {
        const ex = nkg.personatges[clau];
        if (p.estat_emocional) ex.estat_emocional = p.estat_emocional;
        if (p.estat_fisic) ex.estat_fisic = p.estat_fisic;
        if (p.indumentaria_actual) ex.indumentaria_actual = p.indumentaria_actual;
        if (Array.isArray(p.objectes_inventari)) ex.objectes_inventari = p.objectes_inventari;
        if (Array.isArray(p.objectes_descartats) && p.objectes_descartats.length > 0) {
          if (!Array.isArray(ex.objectes_descartats)) ex.objectes_descartats = [];
          ex.objectes_descartats = ex.objectes_descartats.concat(p.objectes_descartats);
          if (ex.objectes_descartats.length > 20) ex.objectes_descartats = ex.objectes_descartats.slice(-20);
        }
        if (p.ubicacio) ex.ubicacio = p.ubicacio;
        if (p.viu !== undefined) ex.viu = p.viu;
        if (p.nous_objectius) {
          p.nous_objectius.forEach(o => { if (!ex.objectius.includes(o)) ex.objectius.push(o); });
          if (ex.objectius.length > 2) ex.objectius = ex.objectius.slice(-2);
        }
        if (p.nous_secrets) {
          p.nous_secrets.forEach(s => { if (!ex.secrets.includes(s)) ex.secrets.push(s); });
        }
        if (p.te_escena_autonoma) {
          if (!ex.autonomia_escenes) ex.autonomia_escenes = [];
          ex.autonomia_escenes.push(capitol);
        }
      }
    });
  }

  if (dades.nous_llocs) {
    dades.nous_llocs.forEach(ll => {
      const clau = nkgNormalitzarNom(ll.nom);
      if (!nkg.llocs[clau]) {
        nkg.llocs[clau] = { nom: ll.nom, descripcio_sensorial: ll.descripcio_sensorial || '', ambient: ll.ambient || '' };
      }
    });
  }

  if (dades.nous_objectes) {
    dades.nous_objectes.forEach(o => {
      const clau = nkgNormalitzarNom(o.nom);
      nkg.objectes[clau] = { nom: o.nom, ubicacio: o.ubicacio || '', posseidor: o.posseidor || null, significat_simbolic: o.significat_simbolic || '' };
    });
  }

  if (dades.canvis_relacions) {
    dades.canvis_relacions.forEach(r => {
      const existentIdx = nkg.relacions.findIndex(rel =>
        (nkgNormalitzarNom(rel.origen) === nkgNormalitzarNom(r.personatge_a) && nkgNormalitzarNom(rel.desti) === nkgNormalitzarNom(r.personatge_b)) ||
        (nkgNormalitzarNom(rel.origen) === nkgNormalitzarNom(r.personatge_b) && nkgNormalitzarNom(rel.desti) === nkgNormalitzarNom(r.personatge_a))
      );
      if (existentIdx >= 0) {
        const rel = nkg.relacions[existentIdx];
        if (r.tipus) rel.tipus = r.tipus;
        if (r.confianca !== undefined) rel.confianca = r.confianca;
        if (r.tensio !== undefined) rel.tensio = r.tensio;
        if (r.nota) {
          if (!rel.historial) rel.historial = [];
          rel.historial.push(`Cap.${capitol}: ${r.nota}`);
          if (rel.historial.length > 4) rel.historial = rel.historial.slice(-4);
        }
      } else {
        nkg.relacions.push({
          origen: r.personatge_a,
          desti: r.personatge_b,
          tipus: r.tipus || 'coneix',
          confianca: r.confianca || 5,
          tensio: r.tensio || 0,
          historial: r.nota ? [`Cap.${capitol}: ${r.nota}`] : []
        });
      }
    });
  }

  if (dades.nous_fets_canonics) {
    dades.nous_fets_canonics.forEach(fc => {
      nkg.fets_canonics.push({ descripcio: fc, capitol_origen: capitol, categoria: 'general' });
    });
    if (nkg.fets_canonics.length > 20) nkg.fets_canonics = nkg.fets_canonics.slice(-20);
  }

  if (dades.resum_esdeveniment) {
    nkg.esdeveniments.push({
      capitol: capitol,
      escena: escena,
      descripcio: dades.resum_esdeveniment,
      personatges_involucrats: personatgesActualitzats.map(p => p.nom),
      consequencies: []
    });
    if (nkg.esdeveniments.length > 30) nkg.esdeveniments = nkg.esdeveniments.slice(-30);
  }

  nkg.ultima_actualitzacio = { capitol, escena };
}


async function nkgActualitzarPostEscena(textEscena, capitol, escena, userConfig) {
  const nkg = ESTAT._nkg;
  if (!nkg) return;

  const persConeguts = Object.values(nkg.personatges).map(p => p.nom).join(', ');
  const estatPersistent = Object.values(nkg.personatges).map(p => {
    const inv = Array.isArray(p.objectes_inventari) && p.objectes_inventari.length > 0 ? p.objectes_inventari.join(', ') : '(buit)';
    const desc = Array.isArray(p.objectes_descartats) && p.objectes_descartats.length > 0
      ? p.objectes_descartats.slice(-3).map(o => `${o.objecte || '?'}@${o.ubicacio || '?'}`).join(' | ')
      : '(cap)';
    return `- ${p.nom}: emociÃ³=${p.estat_emocional || 'neutre'} | roba=${p.indumentaria_actual || '(sense dades)'} | inventari=${inv} | descartats=${desc}`;
  }).join('\n');

  const msgs = [{
    role: 'user',
    content: `Analitza aquest fragment de novelÂ·la i extreu-ne la informaciÃ³ narrativa estructurada.

PERSONATGES CONEGUTS: ${persConeguts || '(cap encara)'}

ESTAT PERSISTENT ABANS D'AQUESTA ESCENA (usa'l per mantenir continuÃ¯tat):
${estatPersistent || '(sense estat persistent previ)'}

IMPORTANT: Per omplir aquest JSON, has de llegir el text de la nova escena i tenir en compte l'inventari i la vestimenta que ja tenien els personatges prÃ¨viament. Si un personatge tenia una 'Pistola' a l'inventari i en aquest capÃ­tol no la fa servir ni la llenÃ§a, la 'Pistola' HA DE CONTINUAR dins del seu array \`objectes_inventari\`. NomÃ©s has de modificar la vestimenta, l'inventari o l'emociÃ³ si els esdeveniments d'aquest capÃ­tol ho justifiquen explÃ­citament (per exemple, si el personatge es canvia de roba, perd un objecte, pateix un accident o rep una mala notÃ­cia que n'alteri l'estat d'Ã nim).

TEXT:
${textEscena.substring(0, 3000)}${textEscena.length > 3000 ? '\n[â€¦text truncatâ€¦]' : ''}

Retorna EXCLUSIVAMENT un JSON vÃ lid:
{
  "personatges": [
    {
      "nom": "Nom del personatge",
      "estat_emocional": "DescripciÃ³ concisa del seu estat d'Ã nim a l'acabar l'escena.",
      "indumentaria_actual": "QuÃ¨ porta posat i en quin estat es troba (ex: 'Abric negre mullat, camisa arrugada').",
      "objectes_inventari": ["Pistola carregada", "Claus del cotxe", "Carta arrugada"],
      "objectes_descartats": [
        {
          "objecte": "Ganivet",
          "ubicacio": "A terra, sota la taula de la cuina"
        }
      ]
    }
  ]
}`
  }];

  const models = getModelConfig(userConfig);
  try {
    const response = await callLLMMulti(
      msgs,
      'Ets un analista narratiu. Extreu NOMÃ‰S informaciÃ³ explÃ­cita del text, no infereixis. IMPORTANT: Per omplir el JSON, conserva inventari i vestimenta prÃ¨via dels personatges i nomÃ©s canvia aquests camps si el text ho justifica explÃ­citament. Respon EXCLUSIVAMENT amb JSON vÃ lid.',
      Object.assign({}, userConfig, { maxTokens: 2000, model: models.modelDraft, _esDraft: true }),
      'generacio'
    );
    const dades = parseJsonRobust(response);
    if (dades) nkgAplicarActualitzacions(dades, capitol, escena);
    else console.warn("NKG: No s'ha pogut parsejar la resposta d'actualitzaciÃ³");
  } catch (err) {
    console.warn('NKG: Error actualitzant post-escena:', err.message);
  }
}


async function generarResumCompacte(finsCapitol, userConfig) {
  const nkg = ESTAT._nkg;
  if (!nkg) return;

  const eventsResum = nkg.esdeveniments
    .filter(e => e.capitol <= finsCapitol)
    .map(e => `Cap.${e.capitol}: ${e.descripcio}`)
    .join('\n');

  const persResum = Object.values(nkg.personatges)
    .map(p => `${p.nom}: ${p.estat_emocional}, a ${p.ubicacio || '?'}`)
    .join('; ');

  if (!eventsResum && !persResum) return;

  const msgs = [{
    role: 'user',
    content: `Genera un resum narratiu compacte de la novelÂ·la fins al capÃ­tol ${finsCapitol}.

ESDEVENIMENTS FINS ARA:
${eventsResum || '(cap registrat)'}

ESTAT ACTUAL DELS PERSONATGES:
${persResum || '(cap registrat)'}

INSTRUCCIONS:
- MÃ xim 400 paraules (ESTRICTE)
- Escriu en prosa fluÃ¯da, no en llista
- Inclou: trama principal, estat dels personatges clau, tensions obertes, girs importants
- NO incloguis detalls sensorials ni cites de diÃ legs
- El resum ha de permetre entendre on som a la novelÂ·la
- Escriu en catalÃ `
  }];

  const models = getModelConfig(userConfig);
  try {
    const response = await callLLMMulti(
      msgs,
      'Ets un editor literari. Genera resums narratius compactes i precisos.',
      Object.assign({}, userConfig, { maxTokens: 800, model: models.modelArquitecte }),
      'arquitectura'
    );
    ESTAT._resumCompacte = response || '';
    console.log('NKG: Resum compacte actualitzat fins al capÃ­tol', finsCapitol);
  } catch (err) {
    console.warn('NKG: Error generant resum compacte:', err.message);
  }
}

async function escriureEscenaDirecta(capitol, escenaIdx, escenaSpec, contextNKG, userConfig) {
  const systemPrompt = buildSystemPromptCapitol();
  const msgs = [{
    role: 'user',
    content: `Escriu l'escena ${escenaIdx + 1} del capÃ­tol ${capitol}.

${contextNKG}

INSTRUCCIONS:
- ${escenaSpec.paraules_objectiu || 700}-${(escenaSpec.paraules_objectiu || 700) + 200} paraules
- Escriu en catalÃ 
- Mostra, no expliquis`
  }];

  const res = await callLLMWithContinuation(msgs, systemPrompt, Object.assign({}, userConfig, { maxTokens: 6000 }), 'generacio');
  return res || '';
}

async function escriureEscenaDualPass(capitol, escenaIdx, escenaSpec, userConfig) {
  const systemPrompt = buildSystemPromptCapitol();
  const idx = capitol - 1;

  const nkgSpec = {
    capitol: capitol,
    escena: escenaIdx + 1,
    personatges: escenaSpec.personatges || [],
    lloc: escenaSpec.lloc || escenaSpec.localitzacio || '',
    escaleta: escenaSpec
  };

  // Obtenir context mÃ­nim del NKG
  const contextNKG = nkgGenerarContextMinim(nkgSpec);
  const contextCapitolEnCurs = obtenirContextCapitolEnCurs(capitol, escenaIdx);
  const escaletaCap = ESTAT._escaletes ? ESTAT._escaletes.find(e => e.capitol === capitol) : null;
  const totalEscenesCapitol = escaletaCap && Array.isArray(escaletaCap.escenes) ? escaletaCap.escenes.length : 1;
  const esUltimaEscenaCapitol = escenaIdx >= totalEscenesCapitol - 1;
  const instruccionsFinalCapitol = esUltimaEscenaCapitol
    ? generarInstruccionsGanxoFinalCapitol(capitol - 1)
    : '';

  const escenaAnterior = escenaIdx > 0 && escaletaCap && Array.isArray(escaletaCap.escenes)
    ? escaletaCap.escenes[escenaIdx - 1]
    : null;
  const textEscenaAnterior = (ESTAT._escenes_generades && ESTAT._escenes_generades[idx])
    ? ESTAT._escenes_generades[idx][escenaIdx - 1]
    : '';
  const textEnllac = obtenirTextEnllac(textEscenaAnterior);
  const tipusTransicio = determinarTipusTransicio(escenaAnterior, escenaSpec);
  const instruccionsTransicio = buildInstruccionsTransicio(textEnllac, tipusTransicio);

  // Instruccions de ritme
  const tensio = (ESTAT._corbaTensio || []).find(t => t.capitol === capitol);
  const nivellTensio = tensio ? Number(tensio.nivell) : 5;
  const instruccionsRitme = obtenirInstruccionsDeTensio(nivellTensio);

  // â”€â”€ PAS 1: DRAFT NARRATIU â”€â”€
  const promptDraft = [{
    role: 'user',
    content: `DRAFT NARRATIU â€” CapÃ­tol ${capitol}, Escena ${escenaIdx + 1}

${contextNKG}${contextCapitolEnCurs}

${instruccionsTransicio}
INSTRUCCIONS DE DRAFT:
- ContinuÃ¯tat estricta amb les escenes anteriors del mateix capÃ­tol
- PROHIBIT repetir literalment escenes, diÃ legs o descripcions ja escrites
- Escriu l'ESQUELET narratiu d'aquesta escena en ~500 paraules
- Prioritza: QUÃˆ PASSA, en quin ordre, quins diÃ legs avancen la trama
- NO et preocupis per la prosa, les descripcions ni els detalls sensorials
- Indica els beats principals: [DIÃ€LEG], [ACCIÃ“], [INTROSPECCIÃ“], [DESCRIPCIÃ“]
- Ritme: ${instruccionsRitme}
- Escriu en catalÃ `
  }];

  const models = getModelConfig(userConfig);

  let draft;
  try {
    draft = await callLLMMulti(promptDraft, systemPrompt,
      Object.assign({}, userConfig, { maxTokens: 2000, model: models.modelDraft, _esDraft: true }), 'generacio');
  } catch (err) {
    console.error('NKG: Error al draft:', err.message);
    return await escriureEscenaDirecta(capitol, escenaIdx, escenaSpec, contextNKG, userConfig);
  }

  // ValidaciÃ³ de contradiccions (programÃ tic, 0 tokens)
  const contradiccions = [];
  if (ESTAT._nkg && draft) {
    Object.values(ESTAT._nkg.personatges).forEach(p => {
      if (!p.viu && draft.toLowerCase().includes(p.nom.toLowerCase())) {
        contradiccions.push(`${p.nom} Ã©s mort perÃ² apareix al draft`);
      }
    });
  }

  if (contradiccions.length > 0) {
    console.warn('NKG: Contradiccions al draft:', contradiccions);
    const promptCorreccio = [{
      role: 'user',
      content: `CORRECCIÃ“ DEL DRAFT â€” Hi ha errors factuals:
${contradiccions.map(c => `- ${c}`).join('\n')}

DRAFT ORIGINAL:
${draft}

Reescriu el draft corregint NOMÃ‰S els errors indicats. MantÃ© la mateixa estructura. ~500 paraules. Escriu en catalÃ .`
    }];
    try {
      const correccio = await callLLMMulti(promptCorreccio, systemPrompt,
        Object.assign({}, userConfig, { maxTokens: 2000, model: models.modelDraft, _esDraft: true }), 'generacio');
      draft = correccio || draft;
    } catch (err) {
      console.warn('NKG: Error a la correcciÃ³ del draft, usant original:', err.message);
    }
  }

  // â”€â”€ PAS 2: EXPANSIÃ“ LITERÃ€RIA â”€â”€
  const goldenRef = ESTAT._goldenPassage
    ? `\nREFERÃˆNCIA DE VEU (mantÃ© aquest to i estil):\n${ESTAT._goldenPassage.substring(0, 800)}`
    : '';

  let estilsPresents = '';
  if (ESTAT.estilsParla && escenaSpec.personatges && escenaSpec.personatges.length > 0) {
    const estils = [];
    escenaSpec.personatges.forEach(nom => {
      if (typeof ESTAT.estilsParla === 'string' && ESTAT.estilsParla.includes(nom)) {
        const nomIdx = ESTAT.estilsParla.indexOf(nom);
        const nextIdx = ESTAT.estilsParla.indexOf('\n\n', nomIdx + nom.length);
        const bloc = ESTAT.estilsParla.substring(nomIdx, nextIdx > nomIdx ? nextIdx : nomIdx + 300);
        estils.push(bloc.substring(0, 200));
      }
    });
    if (estils.length > 0) estilsPresents = '\n\nESTILS DE PARLA:\n' + estils.join('\n');
  }

  // Escena d'autonomia de secundari (tag [AUTONOMIA: Nom] a funcio_narrativa)
  const funcioNarrativa = escenaSpec.funcio_narrativa || '';
  const autonomiaMatch = funcioNarrativa.match(/\[AUTONOMIA:\s*([^\]]+)\]/i);
  const instruccionsAutonomia = autonomiaMatch
    ? `\nESCENA D'AUTONOMIA DEL SECUNDARI: En aquesta escena, ${autonomiaMatch[1].trim()} actua per iniciativa prÃ²pia. Mostra un desig o una por que sigui INDEPENDENT de la trama principal. El protagonista pot estar present perÃ² ha de ser OBSERVADOR o fins i tot incÃ²mode davant les accions del secundari. El secundari ha de sorprendre el lector amb una decisiÃ³ o revelaciÃ³ que no es pugui predir.`
    : '';

  let instruccionsBeat = '';
  const beat = (escenaSpec.beat_narratiu || escenaSpec.funcio_narrativa || '').toLowerCase();

  // Recuperem el nivell de tensiÃ³ de l'obra per a l'escena actual
  const tensioObj = (ESTAT._corbaTensio || []).find(t => t.capitol === capitol);
  const tensioNivell = tensioObj ? tensioObj.nivell : 5;
  const conf = ESTAT.configProjecte || { genere: '', autor_referencia: '', focus_climax: '' };

  if (beat.includes('diÃ leg') || beat.includes('dialog')) {
    instruccionsBeat = "MÃ­nim 70% diÃ leg directe. Els personatges han de parlar, interrompre's i reaccionar en temps real. Cada personatge ha de sonar diferent. Acotacions mÃ­nimes i zero resums de conversa.";
  } else if (beat.includes('introspecciÃ³') || beat.includes('introspeccio') || beat.includes('decisiÃ³')) {
    // LLÃ’GICA DINÃ€MICA DE PACING DEL CLÃMAX
    if (tensioNivell >= 8) {
      instruccionsBeat = `MOMENT DE DECISIÃ“ CLIMÃ€TICA. Atura el temps narratiu i NO acceleris el tempo emocional.
      Respecta l'estil de l'obra (GÃ¨nere: ${conf.genere} / Autor: ${conf.autor_referencia}).
      El personatge lluita amb la seva resistÃ¨ncia interna. Mostra el pes del seu COST ACUMULAT (fÃ­sic o emocional) abans de prendre la decisiÃ³.
      Enfoca't en detalls minÃºsculs coherents amb: ${conf.focus_climax}.`;
    } else {
      instruccionsBeat = 'Ritme pausat. Pensaments del personatge. Reflexions internes.';
    }
  } else if (beat.includes('acciÃ³') || beat.includes('accio')) {
    instruccionsBeat = 'Frases curtes i directes. Ritme trepidant. Verbs d\'acciÃ³. Poc diÃ leg.';
  } else if (beat.includes('descripciÃ³') || beat.includes('descripcio')) {
    instruccionsBeat = 'Detalls sensorials: olors, sons, textures, llum. El lloc cobra vida.';
  }

  // Millora 8: VariÃ ncia de veu (programÃ tic, 0 tokens LLM)
  const ultimaEscenaText = obtenirUltimesEscenes(1, capitol, escenaIdx + 1);
  const instruccionsVariancia = ultimaEscenaText
    ? generarInstruccionsVariancia(analitzarVarianciaVeu(ultimaEscenaText))
    : '';

  // Millora 6: Manual d'estil de referÃ¨ncia
  let manualRef = '';
  if (ESTAT._manualEstil) {
    const m = ESTAT._manualEstil;
    const linies = [];
    if (m.longitud_frases) linies.push(`â€¢ ${m.longitud_frases}`);
    if (m.estil_dialeg) linies.push(`â€¢ DiÃ leg: ${m.estil_dialeg}`);
    if (m.sensorialitat) linies.push(`â€¢ Sensorialitat: ${m.sensorialitat}`);
    if (m.ritme) linies.push(`â€¢ Ritme: ${m.ritme}`);
    if (linies.length > 0) manualRef = '\nMANUAL D\'ESTIL:\n' + linies.join('\n');
  }

  const promptExpansio = `EXPANSIÃ“ LITERÃ€RIA â€” CapÃ­tol ${capitol}, Escena ${escenaIdx + 1}

DRAFT (esquelet narratiu â€” mantÃ© l'estructura i els beats):
${draft}
${contextCapitolEnCurs}
${goldenRef}
${estilsPresents}${manualRef}

${instruccionsTransicio}
INSTRUCCIONS D'EXPANSIÃ“:
- Expandeix el draft a prosa literÃ ria completa: ${escenaSpec.paraules_objectiu || 700}-${(escenaSpec.paraules_objectiu || 700) + 200} paraules
- El draft Ã©s l'esquelet; tu poses la carn, la pell i la sang
- Afegeix: detalls sensorials (mÃ­nim 2 sentits per escena), subtexte als diÃ legs, ritme de la prosa
- Evita sobrecarregar d'adjectius: tria noms i verbs concrets abans que ornaments
- Evita mots infreqÃ¼ents o artificiosos en la parla quotidiana; usa catalÃ  natural i creÃ¯ble
- ${obtenirInstruccionsDeTensio(tensioNivell)}
- ${instruccionsBeat || 'Equilibra narraciÃ³, diÃ leg i descripciÃ³'}
- PROHIBIT RESUMIR: No resumeixis l'acciÃ³, el pas del temps ni les converses. Mostra l'acciÃ³ en temps real, segon a segon. Escriu els diÃ legs complets amb interrupcions, silencis, llenguatge corporal i micro-expressions.
- INTEGRACIÃ“ DE L'ENTORN: Utilitza les dades del context (clima, objectes de l'inventari, detalls de la localitzaciÃ³) de manera activa. Els personatges han d'interactuar fÃ­sicament amb l'entorn abans o durant les converses per alentir el ritme i donar volum i realisme al text.
- Mostra les interaccions en temps real. Assegura't que almenys el 40% del text de l'escena sigui diÃ leg directe amb intercanvis rÃ pids i incisius.
- Mostra, no expliquis: NO escriguis "estava trist" â†’ mostra-ho amb gestos, paraules, mirada
- PROHIBIT TELLING EMOCIONAL: Mai escriguis 'sentia por/rÃ bia/tristesa'. Mostra-ho amb: tensiÃ³ muscular, objectes manipulats compulsivament, canvis en la respiraciÃ³, microexpressions, accions involuntÃ ries (tremolor, suor, veu trencada). Cada emociÃ³ s'ha de deduir, mai etiquetar.
- FUNCIÃ“ D'INSINUACIÃ“ (ANTI-EXPOSICIÃ“): PROHIBIT explicar directament mecanismes tÃ¨cnics (cripto, fluxos, arquitectura interna). Mostra la conseqÃ¼Ã¨ncia, no el mecanisme.
- Respecta escrupolosament els salts de lÃ­nia en els diÃ legs: un parÃ graf nou per a cada personatge que parla.
- No repeteixis informaciÃ³, accions ni frases de les escenes anteriors del mateix capÃ­tol; avanÃ§a sempre
- ComenÃ§a directament amb la narraciÃ³, sense titular${instruccionsVariancia ? '\n- VARIÃ€NCIA: ' + instruccionsVariancia : ''}${instruccionsAutonomia}
- ${instruccionsFinalCapitol || "MantÃ©n la progressiÃ³ narrativa de l'escena."}
- Escriu en catalÃ `;

  try {
    const textFinal = await generarIValidarEscena(
      promptExpansio,
      systemPrompt,
      Object.assign({}, userConfig, { model: models.modelGeneracio }),
      { intentsMaxims: 2, maxTokens: 6000 }
    );

    if (!ESTAT._escenes_generades) ESTAT._escenes_generades = {};
    if (!ESTAT._escenes_generades[idx]) ESTAT._escenes_generades[idx] = {};
    ESTAT._escenes_generades[idx][escenaIdx] = textFinal;

    // Actualitzar NKG amb el text generat
    await nkgActualitzarPostEscena(textFinal, capitol, escenaIdx + 1, userConfig);

    return textFinal || '';
  } catch (err) {
    console.error('NKG: Error a l\'expansiÃ³:', err.message);
    return draft || '';
  }
}

async function generarCapitolNKG(idx, userConfig) {
  const capitol = idx + 1;
  const escaletaCap = ESTAT._escaletes ? ESTAT._escaletes.find(e => e.capitol === capitol) : null;
  const escenes = escaletaCap ? (escaletaCap.escenes || null) : null;

  let textComplet = '';

  if (ESTAT._nkg && escenes && Array.isArray(escenes) && escenes.length > 0) {
    // Escriptura d'un sol missatge per capÃ­tol (NKG + totes les escenes)
    const loaderEl = document.getElementById('loader-11-text');
    if (loaderEl) loaderEl.textContent = `âœï¸ CapÃ­tol ${capitol}: generaciÃ³ unificada (1 missatge + tancament opcional)â€¦`;

    const contextNKG = nkgGenerarContextMinim({
      capitol,
      escena: 1,
      personatges: [...new Set(escenes.flatMap(sc => sc.personatges || []))],
      lloc: escenes[0] ? (escenes[0].lloc || escenes[0].localitzacio || '') : '',
      escaleta: { capÃ­tol: capitol, escenes }
    });
    const contextCapitol = buildContextCapitol(idx);
    const instruccionsFinalCapitol = generarInstruccionsGanxoFinalCapitol(idx);

    const escenesText = escenes.map((sc, i) => {
      return `ESCENA ${i + 1}/${escenes.length}
- Nom: ${sc.nom || ''}
- FunciÃ³ narrativa: ${sc.funcio_narrativa || ''}
- Personatges: ${(sc.personatges || []).join(', ')}
- Paraules objectiu: ${sc.paraules_objectiu || 500}
- Beat narratiu: ${sc.beat_narratiu || 'equilibrat'}`;
    }).join('\n\n');

    const paraulesTotal = escenes.reduce((acc, sc) => acc + (sc.paraules_objectiu || 500), 0);
    const systemPrompt = buildSystemPromptCapitol();
    const msgs = [{
      role: 'user',
      content: `Escriu el CAPÃTOL ${capitol} complet en una sola resposta, integrant TOTES les escenes de l'escaleta en ordre.

${contextNKG}

${contextCapitol}

ESCALETA DEL CAPÃTOL:
${escenesText}

INSTRUCCIONS ESTRICTES:
- Escriu totes les escenes en ordre i posa aquest marcador al comenÃ§ament de cada escena: [[ESCENA_1]], [[ESCENA_2]], etc.
- NO afegeixis cap altre encapÃ§alament ni metadades
- Dins de cada escena escriu prosa literÃ ria completa i transicions naturals
- Respecta personatges, continuÃ¯tat factual i estat del NKG
- No repeteixis informaciÃ³, accions ni frases
- MantÃ©n catalÃ  natural i consistent
- LONGITUD OBLIGATÃ’RIA: Aquest capÃ­tol ha de tenir entre ${Math.round(paraulesTotal * 0.9)} i ${Math.round(paraulesTotal * 1.1)} paraules en total (suma de totes les escenes). Presa't el teu temps per desenvolupar cada escena amb el ritme adequat. Utilitza descripcions sensorials riques, diÃ legs ben construÃ¯ts i accions fÃ­siques per expandir el text. NO precipitis el final ni resumeixis els esdeveniments per acabar rÃ pid. Desenvolupa la prosa de manera literÃ ria fins a assolir aquesta extensiÃ³ de paraules.
- ${instruccionsFinalCapitol}`
    }];

    const textRaw = await callLLMOneShotConditionalCompletion(
      msgs,
      systemPrompt,
      Object.assign({}, userConfig, { maxTokens: Math.max(12000, paraulesTotal * 2), model: getModelConfig(userConfig).modelGeneracio }),
      'generacio'
    );

    const escenesParsejades = parseEscenesUnificades(textRaw, escenes.length);
    if (escenesParsejades.length > 0) {
      textComplet = escenesParsejades.map(e => e.text).join('\n\n');
      if (!ESTAT._escenes_generades) ESTAT._escenes_generades = {};
      ESTAT._escenes_generades[idx] = {};
      escenesParsejades.forEach((e, i) => {
        ESTAT._escenes_generades[idx][i] = e.text;
      });
    } else {
      textComplet = textRaw;
      if (!ESTAT._escenes_generades) ESTAT._escenes_generades = {};
      ESTAT._escenes_generades[idx] = { 0: textComplet };
    }

    await nkgActualitzarPostEscena(textComplet, capitol, escenes.length, userConfig);
  } else if (ESTAT._nkg) {
    // NKG actiu perÃ² sense escaleta: escriptura dual-pass del capÃ­tol com una sola escena
    const cap = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols[idx] : null;
    const escenaSpec = {
      personatges: cap ? (cap.personatges || []) : [],
      lloc: cap ? (cap.localitzacio || '') : '',
      objectiu_dramatic: cap ? (cap.resum || '') : '',
      funcio_narrativa: cap ? (cap.fil_principal || '') : '',
      beat_narratiu: cap ? (cap.to_ritme || 'equilibrat') : 'equilibrat',
      paraules_objectiu: 3500
    };
    const loaderEl = document.getElementById('loader-11-text');
    if (loaderEl) loaderEl.textContent = `âœï¸ CapÃ­tol ${capitol}: draft â†’ expansiÃ³â€¦`;
    textComplet = await escriureEscenaDualPass(capitol, 0, escenaSpec, userConfig);
  } else {
    // Fallback: sistema antic sense NKG
    const res = await escriureCapitolPerEscenes(idx, userConfig);
    return res;
  }

  // Guardar capÃ­tol complet
  if (!ESTAT._capitols_generats) ESTAT._capitols_generats = [];
  ESTAT._capitols_generats[idx] = textComplet;

  // Generar resum compacte cada 3 capÃ­tols o al primer
  if (capitol === 1 || capitol % 3 === 0) {
    const loaderEl = document.getElementById('loader-11-text');
    if (loaderEl) loaderEl.textContent = 'ğŸ”µ Actualitzant resum narratiuâ€¦';
    await generarResumCompacte(capitol, userConfig);
  }

  // Checkpoint de coherÃ¨ncia a meitat de novelÂ·la (novelÂ·les â‰¥16 capÃ­tols)
  const totalCapitols = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols.length : 12;
  const capitolMig = Math.floor(totalCapitols / 2);
  if (totalCapitols >= 16 && capitol === capitolMig) {
    try {
      const loaderEl = document.getElementById('loader-11-text');
      if (loaderEl) loaderEl.textContent = `ğŸŸ¡ Checkpoint de coherÃ¨ncia a meitat de novelÂ·la (cap.${capitol}/${totalCapitols})â€¦`;
      const checkpoint = await controlArcsIntermedi(capitol, userConfig);
      if (checkpoint) {
        mostrarCheckpointIntermedi(checkpoint, capitol, totalCapitols);
      }
    } catch (err) {
      console.warn('Checkpoint intermedi: error no bloquejant:', err.message);
    }
  }

  // Millora 7: Micro-reescriptura cada 3 capÃ­tols (Sonnet diagnostica i reescriu)
  if (capitol % 3 === 0 || capitol === totalCapitols) {
    try {
      const loaderEl = document.getElementById('loader-11-text');
      if (loaderEl) loaderEl.textContent = 'ğŸ”´ Revisant passatges feblesâ€¦';
      await microReescripturaBlocOpus(Math.max(0, idx - 2), idx, userConfig);
      if (capitol === totalCapitols && totalCapitols >= 12) {
        console.log('Micro-reescriptura final: verificant tancament narratiu');
      }
    } catch (err) {
      console.warn('Micro-reescriptura: error no bloquejant:', err.message);
    }
  }

  return { response: textComplet };
}

function renderitzarNKG() {
  const nkg = ESTAT._nkg;
  if (!nkg) return '<p style="color:var(--text2)">NKG no inicialitzat</p>';

  let html = '<div>';

  html += `<h4 style="color:var(--accent2);margin-bottom:8px;">ğŸ“‹ Personatges (${Object.keys(nkg.personatges).length})</h4>`;
  Object.values(nkg.personatges).forEach(p => {
    const color = p.viu ? 'var(--success)' : '#dc3545';
    html += `<div style="border-left:3px solid ${color};padding-left:8px;margin:4px 0;font-size:.85rem;">`;
    html += `<strong>${escHtml(p.nom)}</strong>`;
    if (p.estat_emocional) html += ` â€” ${escHtml(p.estat_emocional)}`;
    if (p.ubicacio) html += ` | ğŸ“ ${escHtml(p.ubicacio)}`;
    if (p.objectius && p.objectius.length > 0) html += `<br>ğŸ¯ ${escHtml(p.objectius.join(', '))}`;
    html += '</div>';
  });

  if (nkg.relacions.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:12px 0 8px;">ğŸ”— Relacions (${nkg.relacions.length})</h4>`;
    nkg.relacions.forEach(r => {
      html += `<div style="font-size:.82rem;padding:2px 0;">${escHtml(r.origen)} â†” ${escHtml(r.desti)}: ${escHtml(r.tipus)} (âš¡${r.tensio}/10)</div>`;
    });
  }

  const eventsRecents = nkg.esdeveniments.slice(-5);
  if (eventsRecents.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:12px 0 8px;">ğŸ“… Esdeveniments recents</h4>`;
    eventsRecents.forEach(e => {
      html += `<div style="font-size:.82rem;padding:2px 0;">Cap.${e.capitol}: ${escHtml(e.descripcio)}</div>`;
    });
  }

  html += '</div>';
  return html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DetecciÃ³ de Repeticions (anÃ lisi local, sense LLM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function detectarRepeticions() {
  const capitolsAmbText = ESTAT._capitols_generats.filter(t => t && t.length > 0);
  if (capitolsAmbText.length < 3) return null;

  function getNgrams(text, n) {
    const paraules = text.toLowerCase().replace(/[.,;:!?Â«Â»""''()\[\]]/g, ' ').split(/\s+/).filter(p => p.length > 2);
    const ngrams = {};
    for (let i = 0; i <= paraules.length - n; i++) {
      const ng = paraules.slice(i, i + n).join(' ');
      ngrams[ng] = (ngrams[ng] || 0) + 1;
    }
    return ngrams;
  }

  // Bigrames i trigrames per capÃ­tol
  const bigramesPerCapitol = capitolsAmbText.map(t => getNgrams(t, 2));
  const trigramesPerCapitol = capitolsAmbText.map(t => getNgrams(t, 3));

  // Paraules de stop (comunes en catalÃ /castellÃ /anglÃ¨s)
  const stopWords = new Set(['que', 'del', 'les', 'els', 'una', 'uns', 'unes', 'per', 'amb', 'com', 'tot', 'tots', 'tota', 'totes', 'mÃ©s', 'molt', 'perÃ²', 'quan', 'fins', 'des', 'pel', 'als', 'sense', 'sobre', 'entre', 'cap', 'seu', 'seva', 'seus', 'seves', 'era', 'eren', 'havia', 'havien', 'ser', 'estar', 'han', 'has', 'hem']);

  function filtrarNgrams(ngramsList) {
    // Compta en quants capÃ­tols apareix cada ngram
    const comptador = {};
    ngramsList.forEach(ngrams => {
      Object.keys(ngrams).forEach(ng => {
        const paraules = ng.split(' ');
        // Filtra si totes les paraules sÃ³n stop words
        if (paraules.every(p => stopWords.has(p))) return;
        comptador[ng] = (comptador[ng] || 0) + 1;
      });
    });
    return Object.entries(comptador)
      .filter(([, c]) => c >= 3)
      .sort((a, b) => b[1] - a[1]);
  }

  const bigramesRepetits = filtrarNgrams(bigramesPerCapitol);
  const trigramesRepetits = filtrarNgrams(trigramesPerCapitol);

  if (bigramesRepetits.length === 0 && trigramesRepetits.length === 0) return null;
  return { bigrames: bigramesRepetits, trigrames: trigramesRepetits };
}

function detectarRepeticionsTematiques() {
  const nkg = ESTAT._nkg;
  if (!nkg || !nkg.esdeveniments || nkg.esdeveniments.length < 5) return null;

  // Agrupar esdeveniments per tipus de revelaciÃ³
  const revelacions = nkg.esdeveniments.filter(e =>
    /descobr|revel|adona[r']?.*compte|s'assabent|comprÃ¨n|entÃ©n/i.test(e.descripcio)
  );

  // Detectar revelacions repetides (mateix personatge + mateixa temÃ tica)
  const grups = {};
  revelacions.forEach(r => {
    const personatgesClau = (r.personatges_involucrats || []).sort().join('+');
    const tema = r.descripcio.toLowerCase()
      .replace(/[^a-zA-ZÃ Ã¨Ã©Ã­Ã²Ã³ÃºÃ¼Ã§Ã€ÃˆÃ‰ÃÃ’Ã“ÃšÃœÃ‡\s]/g, '')
      .split(/\s+/).filter(p => p.length > 3).slice(0, 5).join(' ');
    const clau = `${personatgesClau}::${tema}`;
    if (!grups[clau]) grups[clau] = [];
    grups[clau].push(r);
  });

  const repetides = Object.entries(grups)
    .filter(([, rs]) => rs.length >= 2)
    .map(([clau, rs]) => ({
      tema: clau,
      cops: rs.length,
      capitols: rs.map(r => r.capitol)
    }));

  return repetides.length > 0 ? repetides : null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MILLORA 6: VEU SEMILLA â€” Analitzar estil de referÃ¨ncia (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function manualEstilMassaCurt(manual) {
  if (!manual || typeof manual !== 'object') return true;
  const camps = ['longitud_frases', 'estil_dialeg', 'sensorialitat', 'ritme', 'vocabulari', 'punt_de_vista'];
  const presents = camps.filter(c => manual[c] != null && String(manual[c]).trim().length > 20);
  const charsTotals = presents.reduce((acc, c) => acc + String(manual[c]).trim().length, 0);
  return presents.length < 4 || charsTotals < 260;
}

async function analitzarVeuSemilla(textReferencia, userConfig) {
  const promptBase = `Ets un expert en estil literari. Analitza el fragment de text d'un autor de referÃ¨ncia i genera un MANUAL D'ESTIL concret i accionable per a un escriptor.

FRAGMENT DE REFERÃˆNCIA:
${textReferencia.substring(0, 4000)}

IMPORTANT:
- Cada camp textual ha de tenir com a mÃ­nim 2 frases i ser especÃ­fic.
- No retallis idees a mitja frase.
- Evita resumir en una sola lÃ­nia.

Retorna EXCLUSIVAMENT JSON (sense cap altre text) amb el format:
{
  "longitud_frases": "descripciÃ³ concreta (ex: frases curtes 8-12 paraules, entremesclades amb perÃ­odes llargs)",
  "estil_dialeg": "com es construeixen els diÃ legs (ex: acotacions mÃ­nimes, diÃ leg tallat per acciÃ³)",
  "sensorialitat": "quins sentits predominen i com s'usen (ex: tÃ ctil i visual, metÃ fores kinÃ¨stiques)",
  "ritme": "patrÃ³ rÃ­tmic (ex: acceleraciÃ³ a l'acciÃ³ amb frases curtes, pauses reflexives amb subordinades)",
  "vocabulari": "registre i trets lexicals (ex: colÂ·loquial amb arcaismes puntuals, evita adjectius abstractes)",
  "punt_de_vista": "focalitzaciÃ³ i distÃ ncia narrativa",
  "trets_distinctius": ["tret 1", "tret 2", "tret 3"]
}`;

  const prompt = [{ role: 'user', content: promptBase }];
  const models = getModelConfig(userConfig);

  const res = await callLLMMulti(prompt, 'Ets un crÃ­tic literari expert en anÃ lisi estilÃ­stica. Analitza amb precisiÃ³ quirÃºrgica.',
    Object.assign({}, userConfig, { maxTokens: 2500, model: models.modelArquitecte }), 'arquitectura');

  let manual = parseJsonRobust(res) || parseManualEstilFallback(res);
  if (!manualEstilMassaCurt(manual)) return manual;

  const promptRetry = [{
    role: 'user',
    content: promptBase + '\n\nReescriu la resposta amb MÃ‰S DETALL i assegura que tots els camps estiguin complets i no tallats.'
  }];

  const resRetry = await callLLMMulti(promptRetry, 'Ets un crÃ­tic literari expert en anÃ lisi estilÃ­stica. Analitza amb precisiÃ³ quirÃºrgica.',
    Object.assign({}, userConfig, { maxTokens: 2200 }), 'arquitectura');

  manual = parseJsonRobust(resRetry) || parseManualEstilFallback(resRetry);
  return manual;
}

function parseManualEstilFallback(text) {
  if (!text || typeof text !== 'string') return null;

  const clean = text
    .replace(/```(?:json)?/gi, '')
    .replace(/```/g, '')
    .replace(/\r/g, '')
    .trim();

  const manual = {};
  const fieldMap = {
    longitud_frases: ['longitud_frases', 'longitud de frases'],
    estil_dialeg: ['estil_dialeg', 'estil de dialeg', 'estil de diÃ leg', 'dialeg', 'diÃ leg'],
    sensorialitat: ['sensorialitat'],
    ritme: ['ritme'],
    vocabulari: ['vocabulari'],
    punt_de_vista: ['punt_de_vista', 'punt de vista']
  };

  const lines = clean.split('\n').map(l => l.trim()).filter(Boolean);
  for (const line of lines) {
    const normalized = line
      .replace(/^[-*â€¢\d.)\s]+/, '')
      .replace(/^\*\*(.*?)\*\*$/, '$1')
      .trim();

    const m = normalized.match(/^([^:]+):\s*(.+)$/);
    if (!m) continue;

    const rawKey = m[1].trim().replace(/^"|"$/g, '').replace(/^'|'$/g, '');
    const key = rawKey.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').trim();
    const value = m[2].trim().replace(/^"|"$/g, '').replace(/^'|'$/g, '').replace(/,$/, '').trim();
    if (!value) continue;

    for (const [target, aliases] of Object.entries(fieldMap)) {
      if (aliases.includes(key)) {
        manual[target] = value;
        break;
      }
    }
  }

  const trets = [];
  const tretsBlock = clean.match(/(?:trets?_distinctius|trets? distintius)\s*:\s*([\s\S]{0,500})/i);
  if (tretsBlock) {
    const rawTrets = tretsBlock[1].trim();
    const arrayMatch = rawTrets.match(/^\[(.*)\]$/s);
    if (arrayMatch) {
      arrayMatch[1]
        .split(',')
        .map(v => v.replace(/^\s*["']?|["']?\s*$/g, '').trim())
        .filter(Boolean)
        .slice(0, 6)
        .forEach(t => trets.push(t));
    } else {
      const tretsLines = rawTrets
        .split('\n')
        .map(l => l.replace(/^[-*â€¢\d.)\s]+/, '').replace(/[",]$/g, '').trim())
        .filter(Boolean)
        .slice(0, 6);
      trets.push(...tretsLines);
    }
  }

  if (trets.length === 0) {
    lines
      .filter(l => /^[-*â€¢]/.test(l) || /^\d+[.)]/.test(l))
      .map(l => l.replace(/^[-*â€¢\d.)\s]+/, '').trim())
      .filter(Boolean)
      .slice(0, 3)
      .forEach(t => trets.push(t));
  }

  if (trets.length > 0) manual.trets_distinctius = trets;

  return Object.keys(manual).length > 0 ? manual : null;
}

async function processarVeuSemilla() {
  const textarea = document.getElementById('veuSemilla');
  const resultDiv = document.getElementById('veuSemilla-result');
  if (!textarea || !resultDiv) return;

  const text = textarea.value.trim();
  if (text.length < 200) {
    resultDiv.style.color = 'var(--danger)';
    resultDiv.textContent = 'âš ï¸ Enganxa almenys 200 carÃ cters de text de referÃ¨ncia.';
    return;
  }

  resultDiv.style.color = 'var(--text2)';
  resultDiv.textContent = 'ğŸ”µ Opus analitzant estil de referÃ¨nciaâ€¦';

  try {
    const manual = await analitzarVeuSemilla(text, USER_CONFIG);
    if (manual) {
      ESTAT._veuSemilla = text;
      ESTAT._manualEstil = manual;

      const CAMPS_CONEGUTS = ['trets_distinctius', 'longitud_frases', 'estil_dialeg', 'sensorialitat', 'ritme', 'vocabulari', 'punt_de_vista'];

      let tretsHtml = '';
      if (manual.trets_distinctius != null) {
        const trets = Array.isArray(manual.trets_distinctius)
          ? manual.trets_distinctius
          : String(manual.trets_distinctius).split(/[,Â·\n]+/).map(t => t.trim()).filter(Boolean);
        if (trets.length > 0) {
          tretsHtml = `<div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:12px">${trets.map(t => `<span style="background:var(--surface2);border:1px solid var(--border);border-radius:16px;padding:2px 10px;font-size:.82rem;color:var(--text2)">${escHtml(t)}</span>`).join('')}</div>`;
        }
      }

      const ETIQUETES = { longitud_frases: 'Longitud de frases', estil_dialeg: 'Estil de diÃ leg', sensorialitat: 'Sensorialitat', ritme: 'Ritme', vocabulari: 'Vocabulari', punt_de_vista: 'Punt de vista' };
      let campsHtml = '';
      for (const [clau, etiqueta] of Object.entries(ETIQUETES)) {
        if (manual[clau] != null) {
          campsHtml += `<div style="margin-bottom:8px"><span style="font-size:.78rem;font-weight:600;color:var(--accent2);text-transform:uppercase;letter-spacing:.04em">${etiqueta}</span><div style="font-size:.88rem;color:var(--text);margin-top:2px">${escHtml(String(manual[clau]))}</div></div>`;
        }
      }

      const extresHtml = Object.keys(manual)
        .filter(k => !CAMPS_CONEGUTS.includes(k) && manual[k] != null)
        .map(k => `<div style="margin-bottom:8px"><span style="font-size:.78rem;font-weight:600;color:var(--accent2);text-transform:uppercase;letter-spacing:.04em">${escHtml(k)}</span><div style="font-size:.88rem;color:var(--text);margin-top:2px">${escHtml(String(manual[k]))}</div></div>`)
        .join('');

      resultDiv.style.color = '';
      resultDiv.innerHTML = `<div style="background:var(--surface2);border:1px solid var(--border);border-radius:10px;padding:16px;margin-top:8px"><div style="font-weight:600;color:var(--success);margin-bottom:10px">âœ… Manual d'estil generat</div>${tretsHtml}${campsHtml}${extresHtml}</div>`;
    } else {
      resultDiv.style.color = 'var(--danger)';
      resultDiv.textContent = 'âš ï¸ No s\'ha pogut analitzar l\'estil. Intenta-ho de nou.';
    }
  } catch (err) {
    resultDiv.style.color = 'var(--danger)';
    resultDiv.textContent = `âš ï¸ Error: ${err.message}`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MILLORA 8: DETECTOR DE VEU PLANA â€” anÃ lisi programÃ tica (0 LLM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function detectarTellingEmocional(text) {
  if (!text) return [];
  const patrons = [
    /\b(sentia|se sentia|estava|es trobava|es va sentir|va sentir-se)\s+(trist[ae]?|content[ae]?|enfadat|enfadada|nerviÃ³s|nerviosa|espantat|espantada|feliÃ§|angoixat|angoixada|frustrat|frustrada|confÃ³s|confosa|avergonyit|avergonyida|culpable|satisfe[ct]|alleujat|alleujada|eufÃ²ric|eufÃ²rica|deprimit|deprimida|sol[ae]?|abandonat|abandonada)/gi,
    /\b(una (ona|onada|rampa|punxada|fiblada) de? (por|rÃ bia|tristesa|angoixa|pÃ nic|alegria|culpa|vergonya))/gi,
    /\b(el cor li|el cor se li|li va fer|li feia)\s+(un salt|un nus|mal|por|pena)/gi,
    /\b(amb (por|rÃ bia|tristesa|alegria|vergonya|culpa))\b/gi
  ];
  const matches = [];
  patrons.forEach(p => {
    let m;
    while ((m = p.exec(text)) !== null) {
      matches.push(m[0]);
    }
  });
  return matches;
}

function analitzarVarianciaVeu(text) {
  if (!text || text.length < 50) return null;

  // Segmentar en frases
  const frases = text.split(/[.!?]+/).map(f => f.trim()).filter(f => f.length > 5);
  if (frases.length < 3) return null;

  const longituds = frases.map(f => f.split(/\s+/).length);
  const mitja = longituds.reduce((a, b) => a + b, 0) / longituds.length;
  const variancia = longituds.reduce((a, b) => a + Math.pow(b - mitja, 2), 0) / longituds.length;
  const cv = mitja > 0 ? Math.sqrt(variancia) / mitja : 0;

  // Frases consecutives de longitud similar (diferÃ¨ncia <= 2 paraules)
  let consecutivesSimilars = 0;
  for (let i = 1; i < longituds.length; i++) {
    if (Math.abs(longituds[i] - longituds[i - 1]) <= 2) consecutivesSimilars++;
  }
  const ratioConsecutives = longituds.length > 1 ? consecutivesSimilars / (longituds.length - 1) : 0;

  // Starts repetitius (primers 2 mots)
  const starts = frases.map(f => f.split(/\s+/).slice(0, 2).join(' ').toLowerCase());
  const startCounts = {};
  starts.forEach(s => { startCounts[s] = (startCounts[s] || 0) + 1; });
  const startsRepetits = Object.values(startCounts).filter(c => c >= 2).reduce((a, b) => a + b, 0);
  const ratioStarts = frases.length > 0 ? startsRepetits / frases.length : 0;

  // Adverbis en -ment
  const adverbis = (text.match(/\b\w+ment\b/gi) || []).length;
  const adverbisPerfrase = frases.length > 0 ? adverbis / frases.length : 0;

  // ProporciÃ³ de diÃ leg (per senyals tipogrÃ fics)
  const dialogLines = (text.match(/[Â«Â»"â€”]/g) || []).length;
  const ratioDialeg = text.length > 0 ? dialogLines / (text.length / 100) : 0;

  // Densitat adjectival: adjectius / substantius estimats
  const sufixosAdjectiu = /\b\w+(?:osa|Ã³s|ant|ent|ble|iva|iu|al|ar|ic|ica|oses|osos|als|ars|ics|iques|ants|ents|bles|ives|ius)\b/gi;
  const sufixosVerb = /\b\w+(?:ar|er|ir|re|ava|aven|ava|ia|ies|Ã |aran|eran|iran|at|ada|ats|ades|ant)\b/gi;
  const paraules = text.split(/\s+/).filter(p => p.length > 3);
  const nombreAdjectius = (text.match(sufixosAdjectiu) || []).length;
  const nombreVerbs = (text.match(sufixosVerb) || []).length;
  const nombreSubstantius = Math.max(1, paraules.length - nombreAdjectius - nombreVerbs);
  const densitat_adjectival = nombreAdjectius / nombreSubstantius;

  // Densitat sensorial: paraules sensorials per cada 100 paraules
  const PARAULES_SENSORIALS = new Set([
    'olor','pudor','fragÃ ncia','aroma','efluvi','pestilÃ¨ncia','flaire','perfum','tufor',
    'llum','foscor','claror','penombra','resplendor','enlluernament','fosca','lluminositat',
    'fred','calor','humitat','sequedat','escalfor','glaÃ§or','tibiesa','ardor',
    'soroll','silenci','xiulet','murmuri','cruixit','estrÃ¨pit','renou','brunzit','retruny',
    'textura','aspre','suau','rugÃ³s','llis','viscÃ³s','tou','dur','sedÃ³s','escabrÃ³s',
    'dolÃ§','amarg','Ã cid','salat','acre','salitre','gasoil','metÃ lÂ·lic','picant',
    'vibraciÃ³','pols','boira','vapor','brisa','teranyina','freda','cÃ lida','pesada',
    'tÃ¨nue','brillant','opac','mat','translÃºcid','fosc','clar'
  ]);
  const totalParaules = Math.max(1, text.split(/\s+/).filter(p => p.length > 1).length);
  const nombreSensorials = text.toLowerCase().split(/\s+/).filter(p =>
    PARAULES_SENSORIALS.has(p.replace(/[.,;:!?Â«Â»""''()\[\]]/g, ''))
  ).length;
  const densitat_sensorial = (nombreSensorials / totalParaules) * 100;

  return { cv, mitja, ratioConsecutives, ratioStarts, adverbisPerfrase, ratioDialeg, nFrases: frases.length, densitat_adjectival, densitat_sensorial };
}

function generarInstruccionsVariancia(metriques) {
  if (!metriques) return '';

  const instruccions = [];

  if (metriques.cv < 0.25) {
    instruccions.push('alterna frases curtes (3-5 paraules) amb frases llargues (15+ paraules) per trencar la monotonia rÃ­tmica');
  }
  if (metriques.ratioConsecutives > 0.6) {
    instruccions.push('evita que 3 frases seguides tinguin la mateixa longitud; trenca el paralÂ·lelisme');
  }
  if (metriques.ratioStarts > 0.3) {
    instruccions.push('varia els inicis de frase (no repeteixis el mateix subjecte o connector)');
  }
  if (metriques.adverbisPerfrase > 0.5) {
    instruccions.push('substitueix adverbis en -ment per verbs mÃ©s precisos');
  }
  if (metriques.cv < 0.2 && metriques.ratioConsecutives > 0.65 && metriques.ratioDialeg < 0.7) {
    instruccions.push("to quirÃºrgic detectat: trenca la monotonia amb diÃ legs fragmentats, interrupcions i un parÃ graf d'introspecciÃ³ emocional pura que mostri vulnerabilitat sense explicar-la");
  }
  if (metriques.densitat_adjectival !== undefined && metriques.densitat_adjectival > 0.6) {
    instruccions.push("PODA D'ADJECTIUS: MÃ xim 1 adjectiu per substantiu. Substitueix adjectius per verbs precisos o accions. Exemple: en lloc de 'la porta pesada i rovellada' â†’ 'la porta va grinyolar'");
  }
  if (metriques.densitat_sensorial !== undefined && metriques.densitat_sensorial > 3) {
    instruccions.push("SATURACIÃ“ SENSORIAL: Aquesta escena ja tÃ© prou detalls sensorials. Prioritza acciÃ³ i diÃ leg. Reserva les descripcions sensorials per a 1-2 moments clau de l'escena, no per a cada frase");
  }

  return instruccions.join('; ');
}

function renderitzarAnalisiVeu(capitolIdx) {
  const text = ESTAT._capitols_generats ? ESTAT._capitols_generats[capitolIdx] : null;
  if (!text) return '';

  const m = analitzarVarianciaVeu(text);
  if (!m) return '';

  const cvPct = Math.round(m.cv * 100);
  const cvColor = m.cv >= 0.35 ? 'var(--success)' : m.cv >= 0.2 ? '#ffc107' : 'var(--danger)';
  const consec = Math.round(m.ratioConsecutives * 100);
  const adv = m.adverbisPerfrase.toFixed(2);

  return `<div style="margin-top:12px;padding:10px;background:var(--surface2);border-radius:8px;font-size:.82rem;">
  <strong style="color:var(--accent2);">ğŸ“Š AnÃ lisi de Veu â€” CapÃ­tol ${capitolIdx + 1}</strong>
  <div style="margin-top:6px;display:grid;grid-template-columns:1fr 1fr;gap:4px;">
    <span>VariÃ ncia de ritme (CV):</span><span style="color:${cvColor};font-weight:600">${cvPct}% ${m.cv >= 0.35 ? 'âœ“' : m.cv >= 0.2 ? '~' : 'âš '}</span>
    <span>Frases consecutives similars:</span><span style="color:${consec > 60 ? 'var(--danger)' : 'var(--text)'}">${consec}%</span>
    <span>Adverbis per frase:</span><span style="color:${m.adverbisPerfrase > 0.5 ? 'var(--danger)' : 'var(--text)'}">${adv}</span>
    <span>Longitud mitja:</span><span>${Math.round(m.mitja)} paraules</span>
  </div>
</div>`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MILLORA 7: MICRO-REESCRIPTURA PER BLOCS (Opus + Sonnet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function microReescripturaBlocOpus(blocIniciIdx, blocFinalIdx, userConfig) {
  const capitolsBloc = [];
  for (let i = blocIniciIdx; i <= blocFinalIdx; i++) {
    if (ESTAT._capitols_generats && ESTAT._capitols_generats[i]) {
      capitolsBloc.push({ idx: i, text: ESTAT._capitols_generats[i] });
    }
  }
  if (capitolsBloc.length === 0) return;

  // PAS 1: Opus diagnostica els passatges febles
  const textsPerDiagnosi = capitolsBloc.map(c =>
    `=== CapÃ­tol ${c.idx + 1} ===\n${c.text.substring(0, 2000)}`
  ).join('\n\n');

  const promptDiagnosi = [{
    role: 'user',
    content: `Analitza els capÃ­tols i identifica exactament 3-5 passatges febles (telling, clixÃ©s, prosa plana, diÃ leg genÃ¨ric) o ERRORS DE FORMAT (com ara solapament de diÃ legs de diferents personatges en un mateix parÃ graf).

${textsPerDiagnosi}

Retorna EXCLUSIVAMENT JSON:
{
  "passatges": [
    {
      "capitol_idx": 0,
      "text_original": "fragment exacte de mÃ xim 150 paraules",
      "problema": "descripciÃ³ breu del problema",
      "instruccio": "instrucciÃ³ especÃ­fica per reescriure'l"
    }
  ]
}`
  }];

  const models = getModelConfig(userConfig);
  let diagnosi;
  try {
    const res = await callLLMMulti(promptDiagnosi,
      'Ets un editor literari professional. Sigues precÃ­s i exigent. Respon EXCLUSIVAMENT amb JSON vÃ lid.',
      Object.assign({}, userConfig, { maxTokens: 1500, model: models.modelArquitecte }), 'arquitectura');
    diagnosi = parseJsonRobust(res);
  } catch (err) {
    console.warn('Micro-reescriptura: diagnosi fallida:', err.message);
    return;
  }

  if (!diagnosi || !diagnosi.passatges || diagnosi.passatges.length === 0) return;

  // PAS 2: Sonnet reescriu cada passatge identificat
  let goldenActualitzat = false;
  for (const passatge of diagnosi.passatges) {
    const capIdx = passatge.capitol_idx;
    if (!ESTAT._capitols_generats || !ESTAT._capitols_generats[capIdx] || !passatge.text_original) continue;

    const promptReescriptura = [{
      role: 'user',
      content: `Reescriu aquest passatge aplicant la instrucciÃ³. MantÃ©n la mateixa longitud aproximada i la continuÃ¯tat narrativa.

PASSATGE ORIGINAL:
${passatge.text_original}

PROBLEMA: ${passatge.problema}
INSTRUCCIÃ“: ${passatge.instruccio}

Retorna NOMÃ‰S el text reescrit, sense cap explicaciÃ³ ni metadades.`
    }];

    try {
      const reescrit = await callLLMMulti(promptReescriptura,
        'Ets un escriptor literari expert en revisiÃ³ de prosa. Reescriu amb precisiÃ³ quirÃºrgica.',
        Object.assign({}, userConfig, { maxTokens: 1500, model: models.modelGeneracio }), 'generacio');

      if (reescrit && reescrit.length > 50) {
        const capActual = ESTAT._capitols_generats[capIdx];
        const textOrigNorm = passatge.text_original.substring(0, 100);
        if (capActual.includes(textOrigNorm)) {
          ESTAT._capitols_generats[capIdx] = capActual.replace(passatge.text_original, reescrit);
        }

        // Actualitzar golden passage si el reescrit tÃ© la longitud adequada
        if (!goldenActualitzat) {
          const nParaules = reescrit.split(/\s+/).length;
          if (nParaules >= 150 && nParaules <= 250) {
            if (ESTAT._goldenPassageCapitol < 0 || capIdx >= ESTAT._goldenPassageCapitol) {
              ESTAT._goldenPassage = reescrit.substring(0, 1200);
              ESTAT._goldenPassageCapitol = capIdx;
              goldenActualitzat = true;
            }
          }
        }
      }
    } catch (err) {
      console.warn(`Micro-reescriptura: error al passatge del capÃ­tol ${capIdx}:`, err.message);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALCULADORA DE COST I QUALITAT â€” v5.1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function calcularEstimacioNovella() {
  const models = getModelConfig();
  const numCaps = ESTAT._nombreCapitols || 12;
  const escenesMitjana = 6.5;
  const totalEscenes = Math.round(numCaps * escenesMitjana);

  const regDraft = MODEL_REGISTRY[models.modelDraft];
  const regGen   = MODEL_REGISTRY[models.modelGeneracio];
  const regArq   = MODEL_REGISTRY[models.modelArquitecte];
  if (!regDraft || !regGen || !regArq) return null;

  // â”€â”€â”€ COST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const factor = numCaps / 12;
  const tD = ROLS_MODEL.draft.tokens_estimats;
  const tG = ROLS_MODEL.generacio.tokens_estimats;
  const tA = ROLS_MODEL.arquitecte.tokens_estimats;

  const costDraft = (tD.input * factor * regDraft.input_per_m / 1000000) +
                    (tD.output * factor * regDraft.output_per_m / 1000000);
  const costGen   = (tG.input * factor * regGen.input_per_m / 1000000) +
                    (tG.output * factor * regGen.output_per_m / 1000000);
  const costArq   = (tA.input * factor * regArq.input_per_m / 1000000) +
                    (tA.output * factor * regArq.output_per_m / 1000000);
  const costTotal = costDraft + costGen + costArq;

  // â”€â”€â”€ QUALITAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const totalTok = (tD.input + tD.output) + (tG.input + tG.output) + (tA.input + tA.output);
  const pesDraft = (tD.input + tD.output) / totalTok;
  const pesGen   = (tG.input + tG.output) / totalTok;
  const pesArq   = (tA.input + tA.output) / totalTok;

  const qDraft = regDraft.qualitat[ROLS_MODEL.draft.clau_qualitat];
  const qGen   = regGen.qualitat[ROLS_MODEL.generacio.clau_qualitat];
  const qArq   = regArq.qualitat[ROLS_MODEL.arquitecte.clau_qualitat];

  const qGlobal = Math.round(
    qDraft * pesDraft * 0.7 +
    qGen   * pesGen   * 1.4 +
    qArq   * pesArq   * 0.9
  );

  let penalitzacioCatala = 0;
  if (regGen.proveidor !== 'anthropic')   penalitzacioCatala += 5;
  if (regDraft.proveidor !== 'anthropic') penalitzacioCatala += 2;
  if (regArq.proveidor !== 'anthropic')   penalitzacioCatala += 3;

  const qualitatFinal = Math.max(40, qGlobal - penalitzacioCatala);
  const estrelles = qualitatFinal >= 85 ? 5 : qualitatFinal >= 78 ? 4 :
                    qualitatFinal >= 70 ? 3 : qualitatFinal >= 60 ? 2 : 1;
  const ratioQP = qualitatFinal / (costTotal || 0.01);
  const etiquetaRatio = ratioQP > 25 ? 'ğŸ† Excepcional' : ratioQP > 18 ? 'âœ… Molt bo' :
                        ratioQP > 12 ? 'ğŸ‘ Bo' : ratioQP > 8 ? 'âš ï¸ Car' : 'ğŸ’¸ Molt car';

  return {
    modelDraft: regDraft.nomCurt, modelGeneracio: regGen.nomCurt, modelArquitecte: regArq.nomCurt,
    costDraft: costDraft.toFixed(2), costGeneracio: costGen.toFixed(2),
    costArquitecte: costArq.toFixed(2), costTotal: costTotal.toFixed(2),
    qualitatDraft: qDraft, qualitatGeneracio: qGen, qualitatArquitecte: qArq,
    qualitatGlobal: qualitatFinal, penalitzacioCatala, estrelles, etiquetaRatio,
    capitols: numCaps, escenes: totalEscenes, paraulesEstimades: totalEscenes * 530,
    avisos: generarAvisos(models, regDraft, regGen, regArq)
  };
}

function generarAvisos(models, regDraft, regGen, regArq) {
  const avisos = [];
  if (regGen.proveidor !== 'anthropic')
    avisos.push(`âš ï¸ ${regGen.nomCurt} genera prosa en catalÃ  menys natural que els models Claude.`);
  if (regArq.proveidor !== 'anthropic')
    avisos.push(`â„¹ï¸ ${regArq.nomCurt} pot interpretar pitjor instruccions en catalÃ  als prompts d'arquitectura.`);
  if (regDraft.context_max < 200000)
    avisos.push(`âš ï¸ ${regDraft.nomCurt} tÃ© context limitat (${Math.round(regDraft.context_max/1000)}K). Pot afectar escenes amb molt context NKG.`);
  if (regDraft.input_per_m > regGen.input_per_m)
    avisos.push(`ğŸ’¡ El model de draft (${regDraft.nomCurt}) Ã©s mÃ©s car que el de generaciÃ³ (${regGen.nomCurt}). Considera intercanviar-los.`);
  if (regGen.qualitat.prosa < 70)
    avisos.push(`âš ï¸ ${regGen.nomCurt} tÃ© qualitat de prosa limitada (${regGen.qualitat.prosa}/100). La novelÂ·la necessitarÃ  mÃ©s ediciÃ³ humana.`);
  const proveidors = new Set([regDraft.proveidor, regGen.proveidor, regArq.proveidor]);
  if (proveidors.size > 1)
    avisos.push(`â„¹ï¸ CombinaciÃ³ multi-proveÃ¯dor (${[...proveidors].join(', ')}). Assegura't de tenir claus API per a tots.`);
  return avisos;
}

// Backward-compatible alias (cridat des de la fase d'estructura)
function estimarCostNovella() { return calcularEstimacioNovella(); }
function mostrarEstimacioCost() {
  const est = calcularEstimacioNovella();
  if (!est) return '';
  const veuLine = '';
  return `ğŸ“Š ${est.capitols} capÃ­tols Â· ~${est.escenes} escenes Â· ~${est.paraulesEstimades.toLocaleString()} paraules\nğŸ’° $${est.costTotal} ${est.etiquetaRatio} Â· Qualitat: ${est.qualitatGlobal}/100 ${'â˜…'.repeat(est.estrelles)}${'â˜†'.repeat(5-est.estrelles)}\n   Draft: $${est.costDraft} Â· GeneraciÃ³: $${est.costGeneracio} Â· Arquitectura: $${est.costArquitecte}`;
}

// â”€â”€ UI: Funcions del panell de models â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function poblarSelectorsModels() {
  const selectors = {
    'selectModelDraft': 'draft',
    'selectModelGen':   'generacio',
    'selectModelArq':   'arquitecte'
  };
  Object.entries(selectors).forEach(([selectId, rol]) => {
    const select = document.getElementById(selectId);
    if (!select) return;
    select.innerHTML = '';
    Object.entries(MODEL_REGISTRY).forEach(([modelId, info]) => {
      const qualitat = info.qualitat[ROLS_MODEL[rol].clau_qualitat];
      const option = document.createElement('option');
      option.value = modelId;
      option.textContent = `${info.nomCurt} â€” $${info.input_per_m}/$${info.output_per_m}/M â€” Q:${qualitat}`;
      select.appendChild(option);
    });
  });
  const models = getModelConfig();
  const selDraft = document.getElementById('selectModelDraft');
  const selGen   = document.getElementById('selectModelGen');
  const selArq   = document.getElementById('selectModelArq');
  if (selDraft) selDraft.value = models.modelDraft;
  if (selGen)   selGen.value   = models.modelGeneracio;
  if (selArq)   selArq.value   = models.modelArquitecte;
  actualitzarEstimacio();
}

function actualitzarEstimacio() {
  const est = calcularEstimacioNovella();
  if (!est) return;

  const qDraftEl = document.getElementById('qualitatDraft');
  const qGenEl   = document.getElementById('qualitatGen');
  const qArqEl   = document.getElementById('qualitatArq');
  if (qDraftEl) qDraftEl.innerHTML = renderBarraQualitat(est.qualitatDraft, '$' + est.costDraft);
  if (qGenEl)   qGenEl.innerHTML   = renderBarraQualitat(est.qualitatGeneracio, '$' + est.costGeneracio);
  if (qArqEl)   qArqEl.innerHTML   = renderBarraQualitat(est.qualitatArquitecte, '$' + est.costArquitecte);

  const panell = document.getElementById('panellEstimacio');
  if (panell) {
    const estrellesHTML = 'â˜…'.repeat(est.estrelles) + 'â˜†'.repeat(5 - est.estrelles);
    panell.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;">
        <div><strong style="font-size:1.3em;">$${est.costTotal}</strong><span style="color:#666;margin-left:8px;">${est.etiquetaRatio}</span></div>
        <div><span style="color:#f5a623;font-size:1.2em;">${estrellesHTML}</span><span style="margin-left:6px;">Qualitat: ${est.qualitatGlobal}/100</span></div>
      </div>
      <div style="margin-top:8px;color:#666;font-size:0.85em;">
        ${est.capitols} capÃ­tols Â· ~${est.escenes} escenes Â· ~${est.paraulesEstimades.toLocaleString()} paraules${est.penalitzacioCatala > 0 ? ` Â· <span style="color:#e67e22;">-${est.penalitzacioCatala}pts catalÃ </span>` : ''}
      </div>
      <div style="margin-top:6px;font-size:0.8em;color:#888;">
        Draft: $${est.costDraft} Â· GeneraciÃ³: $${est.costGeneracio} Â· Arquitectura: $${est.costArquitecte}
      </div>`;
  }

  const panellAvisos = document.getElementById('panellAvisos');
  if (panellAvisos) {
    panellAvisos.innerHTML = est.avisos.length > 0
      ? est.avisos.map(a => `<div style="padding:4px 0;border-bottom:1px solid #eee;">${a}</div>`).join('')
      : '';
  }

  // Actualitzar tambÃ© el div de l'estructura (si Ã©s visible)
  const costEl = document.getElementById('estimacio-cost');
  if (costEl && costEl.textContent) costEl.textContent = mostrarEstimacioCost();
}

function renderBarraQualitat(qualitat, cost) {
  const color = qualitat >= 85 ? '#28a745' : qualitat >= 75 ? '#5cb85c' :
                qualitat >= 65 ? '#f0ad4e' : '#d9534f';
  const ample = Math.min(100, qualitat);
  return `<div style="display:flex;align-items:center;gap:6px;"><div style="flex:1;background:#e9ecef;border-radius:4px;height:8px;overflow:hidden;"><div style="width:${ample}%;background:${color};height:100%;border-radius:4px;"></div></div><span style="font-size:0.8em;min-width:30px;">${qualitat}</span><span style="font-size:0.75em;color:#999;">${cost}</span></div>`;
}

function guardarClausAPI() {
  const anthropic = document.getElementById('anthropicApiKey')?.value?.trim();
  const gemini    = document.getElementById('geminiApiKey')?.value?.trim();
  const openai    = document.getElementById('openaiApiKey')?.value?.trim();
  if (anthropic) ESTAT._anthropicApiKey = anthropic;
  if (gemini)    ESTAT._geminiApiKey    = gemini;
  if (openai)    ESTAT._openaiApiKey    = openai;
  actualitzarModelsDisponibles();
}

function actualitzarModelsDisponibles() {
  const teAnthropic = !!(ESTAT._anthropicApiKey || (USER_CONFIG && USER_CONFIG.provider === 'anthropic' && USER_CONFIG.apiKey));
  const teGemini    = !!(ESTAT._geminiApiKey || (USER_CONFIG && (USER_CONFIG.provider === 'gemini' || USER_CONFIG.provider === 'google') && USER_CONFIG.apiKey));
  const teOpenai    = !!(ESTAT._openaiApiKey || (USER_CONFIG && USER_CONFIG.provider === 'openai' && USER_CONFIG.apiKey));

  document.querySelectorAll('#panellModels select option').forEach(option => {
    const model = MODEL_REGISTRY[option.value];
    if (!model) return;
    const disponible =
      (model.proveidor === 'anthropic' && teAnthropic) ||
      (model.proveidor === 'google'    && teGemini) ||
      (model.proveidor === 'openai'    && teOpenai);
    option.disabled = !disponible;
    if (!disponible && !option.textContent.includes('(sense clau)')) {
      option.textContent += ' (sense clau)';
    } else if (disponible) {
      option.textContent = option.textContent.replace(' (sense clau)', '');
    }
  });
}

// â”€â”€ InicialitzaciÃ³ del selector de models en carregar la pÃ gina â”€â”€
document.addEventListener('DOMContentLoaded', function() {
  // Aplicar preset econÃ²mic per defecte i poblar selectors
  aplicarPreset('economic');
  actualitzarConfigProvider();
  if (typeof poblarSelectorsModels === 'function') poblarSelectorsModels();
  if (typeof guardarClausAPI === 'function') guardarClausAPI();

  // Comprovar si hi ha algun projecte guardat a localStorage
  comprovarProjecteGuardat();
});

</script>
</body>
</html>
