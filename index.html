<!DOCTYPE html>
<html lang="ca">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Conte IA</title>
<style>
  :root {
    --bg:       #0f0f13;
    --surface:  #1a1a24;
    --surface2: #22222f;
    --border:   #2e2e42;
    --accent:   #7c6af7;
    --accent2:  #a78bfa;
    --text:     #e8e8f0;
    --text2:    #9898b0;
    --success:  #4ade80;
    --warning:  #fbbf24;
    --radius:   12px;
    --font:     'Segoe UI', system-ui, sans-serif;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--font);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 24px 16px 60px;
  }

  /* â”€â”€ Header â”€â”€ */
  header {
    width: 100%;
    max-width: 860px;
    text-align: center;
    margin-bottom: 32px;
  }
  header h1 {
    font-size: 2rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 6px;
  }
  header p { color: var(--text2); font-size: .95rem; }


  /* â”€â”€ Accions rÃ pides projecte (top-right) â”€â”€ */
  .project-actions-top {
    position: fixed;
    top: 12px;
    right: 12px;
    z-index: 1100;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: flex-end;
    max-width: min(92vw, 520px);
  }
  .project-actions-top .btn {
    padding: 8px 12px;
    font-size: .8rem;
  }
  @media (max-width: 720px) {
    .project-actions-top {
      position: sticky;
      top: 6px;
      right: auto;
      width: 100%;
      max-width: 860px;
      margin: 0 auto 10px;
    }
  }

  /* â”€â”€ Progress bar â”€â”€ */
  #progress-wrap {
    width: 100%;
    max-width: 860px;
    margin-bottom: 28px;
  }
  .progress-steps {
    display: flex;
    gap: 6px;
    align-items: center;
    overflow-x: auto;
    padding-bottom: 4px;
  }
  .step-pill {
    flex-shrink: 0;
    padding: 5px 14px;
    border-radius: 99px;
    font-size: .75rem;
    font-weight: 600;
    background: var(--surface2);
    color: var(--text2);
    border: 1px solid var(--border);
    transition: all .3s;
  }
  .step-pill.done   { background: #2a2a3d; color: var(--accent2); border-color: var(--accent); }
  .step-pill.active { background: var(--accent); color: #fff; border-color: var(--accent); }
  .step-arrow { color: var(--border); font-size: .8rem; flex-shrink: 0; }

  /* â”€â”€ Card â”€â”€ */
  .card {
    width: 100%;
    max-width: 860px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 28px;
    margin-bottom: 20px;
  }
  .card h2 {
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 18px;
    color: var(--accent2);
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .card h2 .icon { font-size: 1.4rem; }

  /* â”€â”€ Select â”€â”€ */
  select {
    width: 100%;
    padding: 12px 16px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-size: 1rem;
    font-family: var(--font);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8'%3E%3Cpath fill='%239898b0' d='M6 8L0 0h12z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 16px center;
    padding-right: 40px;
  }
  select:focus { outline: none; border-color: var(--accent); }

  input[type=text],
  input[type=password] {
    width: 100%;
    padding: 12px 16px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-size: .95rem;
    font-family: var(--font);
  }
  input[type=text]:focus,
  input[type=password]:focus { outline: none; border-color: var(--accent); }

  .field-label {
    display: block;
    font-size: .85rem;
    color: var(--text2);
    margin: 14px 0 8px;
  }

  /* â”€â”€ Botons â”€â”€ */
  .btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 11px 24px;
    border-radius: 8px;
    font-size: .95rem;
    font-weight: 600;
    cursor: pointer;
    border: none;
    transition: all .2s;
    font-family: var(--font);
  }
  .btn-primary   { background: var(--accent); color: #fff; }
  .btn-primary:hover { background: #6b5be0; transform: translateY(-1px); }
  .btn-secondary { background: var(--surface2); color: var(--text); border: 1px solid var(--border); }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent2); }
  .btn-ghost { background: transparent; color: var(--text2); border: 1px solid var(--border); }
  .btn-ghost:hover { color: var(--text); border-color: var(--text2); }
  .btn:disabled { opacity: .4; cursor: not-allowed; transform: none !important; }
  .btn-row { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 20px; }

  /* â”€â”€ Pills de selecciÃ³ (estil narratiu) â”€â”€ */
  .opts-row {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 4px;
  }
  .opt-pill {
    flex: 1;
    min-width: 130px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 2px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    text-align: center;
    font-size: .88rem;
    font-weight: 600;
    transition: all .2s;
    line-height: 1.4;
    user-select: none;
  }
  .opt-pill small {
    display: block;
    font-weight: 400;
    color: var(--text2);
    font-size: .75rem;
    margin-top: 4px;
  }
  .opt-pill:hover   { border-color: var(--accent); }
  .opt-pill.chosen  { border-color: var(--accent); background: #1e1b38; color: var(--accent2); }
  .opt-pill.chosen small { color: var(--accent2); }

  /* â”€â”€ Llista de premisses â”€â”€ */
  .premise-list { display: flex; flex-direction: column; gap: 10px; }
  .premise-item {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 2px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    transition: all .2s;
  }
  .premise-item:hover  { border-color: var(--accent); }
  .premise-item.chosen { border-color: var(--accent); background: #1e1b38; }
  .premise-item input[type=radio] { margin-top: 2px; accent-color: var(--accent); flex-shrink: 0; }
  .premise-item label { cursor: pointer; line-height: 1.5; font-size: .95rem; }

  /* â”€â”€ Badge Recomanat â”€â”€ */
  .badge-recomanat {
    display: inline-block;
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    color: #fff;
    font-size: .68rem;
    font-weight: 700;
    padding: 2px 9px;
    border-radius: 99px;
    text-transform: uppercase;
    letter-spacing: .07em;
    margin-right: 8px;
    vertical-align: middle;
    flex-shrink: 0;
  }

  /* â”€â”€ Loader â”€â”€ */
  .loader-wrap {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    padding: 32px 0;
    color: var(--text2);
    font-size: .9rem;
  }
  .loader-wrap.visible { display: flex; }
  .spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin .8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* â”€â”€ Toast â”€â”€ */
  #toast {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%) translateY(80px);
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 12px 24px;
    border-radius: 99px;
    font-size: .9rem;
    transition: transform .3s;
    z-index: 9999;
    pointer-events: none;
  }
  #toast.show { transform: translateX(-50%) translateY(0); }

  /* â”€â”€ Reader del conte â”€â”€ */
  .conte-reader {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 40px 48px;
    font-family: 'Georgia', 'Times New Roman', serif;
    font-size: 1.05rem;
    line-height: 1.9;
    color: var(--text);
    max-height: 72vh;
    overflow-y: auto;
  }
  .conte-reader p {
    margin-bottom: 1.1em;
    text-indent: 0;
  }
  @media (max-width: 600px) {
    .conte-reader { padding: 24px 20px; font-size: .97rem; }
  }
  .conte-wordcount {
    font-size: .78rem;
    color: var(--text2);
    margin-top: 10px;
    text-align: right;
  }

  /* â”€â”€ Millora â”€â”€ */
  .millora-row {
    display: flex;
    gap: 10px;
    margin-top: 14px;
  }
  .millora-row input {
    flex: 1;
    padding: 10px 14px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-size: .9rem;
    font-family: var(--font);
  }
  .millora-row input:focus { outline: none; border-color: var(--accent); }
  .millora-row input::placeholder { color: var(--text2); }

  /* â”€â”€ Export â”€â”€ */
  .export-link {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    color: var(--accent2);
    text-decoration: none;
    font-size: .9rem;
    font-weight: 600;
    padding: 8px 16px;
    border: 1px solid var(--accent);
    border-radius: 8px;
    transition: all .2s;
  }
  .export-link:hover { background: #1e1b38; }

  /* â”€â”€ Worldbuilding multi-select â”€â”€ */
  .world-item {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 2px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    transition: all .2s;
  }
  .world-item:hover  { border-color: var(--accent); }
  .world-item.chosen { border-color: var(--accent); background: #1e1b38; }
  .world-item input[type=checkbox] { margin-top: 3px; accent-color: var(--accent); flex-shrink: 0; width: 16px; height: 16px; cursor: pointer; }
  .world-item label { cursor: pointer; line-height: 1.5; font-size: .95rem; }

  /* â”€â”€ Resultat worldbuilding â”€â”€ */
  .worldbuilding-result {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 28px 32px;
    font-size: .95rem;
    line-height: 1.85;
    color: var(--text);
  }
  .worldbuilding-result .world-bloc {
    margin-bottom: 22px;
  }
  .worldbuilding-result .world-bloc:last-child {
    margin-bottom: 0;
  }
  .worldbuilding-result .world-bloc-titol {
    color: var(--accent2);
    font-weight: 700;
    font-size: 1rem;
    margin-bottom: 6px;
  }
  .worldbuilding-result .world-bloc-desc {
    color: var(--text);
    padding-left: 12px;
    border-left: 2px solid var(--border);
  }

  /* â”€â”€ Estils de parla (fase 9) â”€â”€ */
  .veu-result {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  .veu-card {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 22px 26px;
  }
  .veu-card-nom {
    color: var(--accent2);
    font-weight: 700;
    font-size: 1.05rem;
    margin-bottom: 14px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border);
  }
  .veu-card-camps {
    display: flex;
    flex-direction: column;
    gap: 10px;
    font-size: .92rem;
    line-height: 1.6;
  }
  .veu-camp-label {
    color: var(--text2);
    font-size: .75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .07em;
    margin-bottom: 3px;
  }
  .veu-camp-val {
    color: var(--text);
    padding-left: 10px;
    border-left: 2px solid var(--border);
  }
  .veu-exemple {
    margin-top: 4px;
    padding: 10px 16px;
    background: var(--surface);
    border-radius: 8px;
    font-family: 'Georgia', serif;
    font-style: italic;
    color: var(--accent2);
    font-size: .95rem;
    line-height: 1.65;
    border-left: 3px solid var(--accent);
  }

  /* â”€â”€ SecciÃ³ amagada â”€â”€ */
  .hidden { display: none !important; }

  /* â”€â”€ Badges de model (Sonnet / Opus) â”€â”€ */
  .badge-model {
    display: inline-flex;
    align-items: center;
    padding: 2px 10px;
    border-radius: 99px;
    font-size: .68rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .06em;
    vertical-align: middle;
    margin-left: 8px;
  }
  .badge-sonnet { background: rgba(124,106,247,.2); color: var(--accent2); border: 1px solid var(--accent); }
  .badge-opus   { background: rgba(96,165,250,.15); color: #93c5fd;        border: 1px solid #60a5fa; }

  /* â”€â”€ Modal overlay (Llibre de Registre) â”€â”€ */
  .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.78);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }
  .modal-overlay.hidden { display: none !important; }
  .modal-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 28px;
    max-width: 680px;
    width: 100%;
    max-height: 82vh;
    overflow-y: auto;
  }

  /* â”€â”€ Llista de capÃ­tols â”€â”€ */
  .capitol-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 9px 14px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: .85rem;
    transition: all .2s;
  }
  .capitol-item.actiu { border-color: var(--accent); background: #1e1b38; }
  .capitol-item.fet   { border-color: var(--success); }
  .capitol-num   { font-weight: 700; color: var(--text2); min-width: 26px; font-size: .8rem; flex-shrink: 0; }
  .capitol-titol { flex: 1; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .capitol-item.actiu .capitol-titol { color: var(--accent2); font-weight: 600; }
  .capitol-item.fet   .capitol-num   { color: var(--success); }
  .capitol-copy { background:none; border:none; color:var(--text2); cursor:pointer; padding:2px 6px; border-radius:4px; font-size:.85rem; opacity:.55; transition:opacity .15s; flex-shrink:0; }
  .capitol-copy:hover { opacity:1; color:var(--accent2); }
  .capitol-detall-wrap {
    margin-top: 16px;
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px;
    background: var(--surface2);
  }
  .capitol-detall-box {
    position: relative;
    margin-bottom: 12px;
    padding: 12px 14px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: var(--surface);
  }
  .capitol-detall-box h4 {
    font-size: .88rem;
    color: var(--accent2);
    margin-bottom: 8px;
    padding-right: 30px;
  }
  .capitol-detall-copy {
    position: absolute;
    top: 8px;
    right: 8px;
    background: transparent;
    border: none;
    color: var(--text2);
    cursor: pointer;
    font-size: .9rem;
  }
  .capitol-detall-copy:hover { color: var(--accent2); }

  /* â”€â”€ Panel de revisiÃ³ (Opus) â”€â”€ */
  .review-panel {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 18px 22px;
    margin-top: 14px;
  }

  /* â”€â”€ Checkbox gran de configuraciÃ³ â”€â”€ */
  .checkbox-row {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    cursor: pointer;
    margin-top: 14px;
    transition: border-color .2s;
  }
  .checkbox-row:hover { border-color: var(--accent); }
  .checkbox-row input[type=checkbox] {
    width: 18px; height: 18px;
    accent-color: var(--accent);
    flex-shrink: 0;
    cursor: pointer;
    margin-top: 2px;
  }
  .checkbox-row label { cursor: pointer; line-height: 1.5; }

  /* â”€â”€ Camps de config per proveÃ¯dor â”€â”€ */
  .config-section { margin-top: 4px; }
</style>
</head>
<body>

<div class="project-actions-top">
  <button class="btn btn-ghost" onclick="exportarCopiaSeguretat()">ğŸ’¾ Exportar projecte</button>
  <button class="btn btn-ghost" onclick="obrirImportarCopiaSeguretat()">ğŸ“¥ Importar projecte</button>
</div>

<header>
  <h1>ğŸ“– Conte IA</h1>
  <p>Crea el teu conte pas a pas amb intelÂ·ligÃ¨ncia artificial</p>
</header>

<!-- CONFIGURACIÃ“ INICIAL -->
<div class="card" id="card-config">
  <h2><span class="icon">âš™ï¸</span> ConfiguraciÃ³</h2>

  <label class="field-label" for="config-provider">ProveÃ¯dor</label>
  <select id="config-provider" onchange="actualitzarConfigProvider()">
    <option value="anthropic">Anthropic (Claude) â€” Sistema dual Sonnet + Opus</option>
    <option value="openai">OpenAI (GPT-4o)</option>
    <option value="gemini">Google (Gemini 1.5)</option>
  </select>

  <!-- Camps especÃ­fics Anthropic (model dual) -->
  <div id="config-anthropic-fields" class="config-section">
    <label class="field-label" for="config-model-generacio">
      Model de generaciÃ³ <span style="color:var(--text2);font-size:.78rem;">â€” escriptura creativa</span>
    </label>
    <input type="text" id="config-model-generacio" value="claude-sonnet-4-6" placeholder="claude-sonnet-4-6">

    <label class="field-label" for="config-model-arquitectura">
      Model d'arquitectura <span style="color:var(--text2);font-size:.78rem;">â€” disseny i revisiÃ³</span>
    </label>
    <input type="text" id="config-model-arquitectura" value="claude-opus-4-6" placeholder="claude-opus-4-6">

    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px;">
      <div>
        <label class="field-label" for="config-provider-generacio" style="margin-bottom:4px;">ProveÃ¯dor GeneraciÃ³</label>
        <select id="config-provider-generacio">
          <option value="anthropic">Anthropic (Claude)</option>
          <option value="gemini">Google (Gemini)</option>
          <option value="openai">OpenAI (GPT)</option>
        </select>
      </div>
      <div>
        <label class="field-label" for="config-provider-arquitectura" style="margin-bottom:4px;">ProveÃ¯dor Arquitectura</label>
        <select id="config-provider-arquitectura">
          <option value="anthropic">Anthropic (Claude)</option>
          <option value="gemini">Google (Gemini)</option>
          <option value="openai">OpenAI (GPT)</option>
        </select>
      </div>
    </div>

    <div class="checkbox-row" onclick="document.getElementById('config-flux-automatic').click()">
      <input type="checkbox" id="config-flux-automatic" onclick="event.stopPropagation()">
      <label for="config-flux-automatic">
        <strong>Flux automÃ tic</strong> â€” Opus revisa cada capÃ­tol i Sonnet el corregeix si cal
        <small style="display:block;color:var(--text2);font-size:.78rem;margin-top:2px;">Si estÃ  desactivat, la revisiÃ³ Ã©s manual (botons per capÃ­tol)</small>
      </label>
    </div>

    <label class="field-label" for="config-target-qualitat" style="margin-top:10px;">Qualitat objectiu del jutge (0-100)</label>
    <input type="number" id="config-target-qualitat" min="60" max="98" step="1" value="85" placeholder="85">
    <small style="display:block;color:var(--text2);font-size:.78rem;margin-top:4px;">El generador iterarÃ  fins assolir aquest llindar (amb lÃ­mit de seguretat d'intents).</small>

    <!-- Panell de selecciÃ³ de models flexible v5.1 -->
    <div id="panellModels" style="margin-top:14px;padding:14px;border:1px solid var(--border);border-radius:8px;">
      <h3 style="margin:0 0 10px;font-size:1em;">âš™ï¸ ConfiguraciÃ³ de Models</h3>

      <div style="margin-bottom:10px;">
        <label style="font-weight:bold;font-size:.85em;">Presets rÃ pids:</label>
        <div style="display:flex;gap:6px;margin-top:4px;flex-wrap:wrap;">
          <button onclick="aplicarPreset('economic')"   class="btn" style="padding:3px 8px;font-size:.78rem;" title="Haiku+Sonnet+Sonnet">ğŸ’° EconÃ²mic</button>
          <button onclick="aplicarPreset('equilibrat')" class="btn" style="padding:3px 8px;font-size:.78rem;" title="Sonnet+Sonnet+Sonnet">âš–ï¸ Equilibrat</button>
          <button onclick="aplicarPreset('premium')"    class="btn" style="padding:3px 8px;font-size:.78rem;" title="Sonnet+Sonnet+Opus">ğŸ‘‘ Premium</button>
          <button onclick="aplicarPreset('maxim')"      class="btn" style="padding:3px 8px;font-size:.78rem;" title="Sonnet+Opus+Opus">ğŸ”¬ MÃ xim</button>
          <button onclick="aplicarPreset('barat_gpt')"  class="btn" style="padding:3px 8px;font-size:.78rem;" title="GPT-5.2 per tot">ğŸ¤– GPT-5.2</button>
          <button onclick="aplicarPreset('gemini')"     class="btn" style="padding:3px 8px;font-size:.78rem;" title="Gemini 3 Pro per tot">ğŸŒ Gemini 3</button>
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-bottom:10px;">
        <div>
          <label style="font-size:.82em;font-weight:bold;">ğŸ“ Draft / ExtracciÃ³</label>
          <p style="font-size:.73em;color:var(--text2);margin:2px 0 4px;">Esquelets, fets NKG</p>
          <select id="selectModelDraft" onchange="setModelPerRol('draft', this.value)" style="width:100%;font-size:.78rem;"></select>
          <div id="qualitatDraft" style="font-size:.78em;margin-top:3px;"></div>
        </div>
        <div>
          <label style="font-size:.82em;font-weight:bold;">âœï¸ GeneraciÃ³ LiterÃ ria</label>
          <p style="font-size:.73em;color:var(--text2);margin:2px 0 4px;">Prosa, expansiÃ³</p>
          <select id="selectModelGen" onchange="setModelPerRol('generacio', this.value)" style="width:100%;font-size:.78rem;"></select>
          <div id="qualitatGen" style="font-size:.78em;margin-top:3px;"></div>
        </div>
        <div>
          <label style="font-size:.82em;font-weight:bold;">ğŸ—ï¸ Arquitecte / Revisor</label>
          <p style="font-size:.73em;color:var(--text2);margin:2px 0 4px;">Estructura, diagnÃ²stic</p>
          <select id="selectModelArq" onchange="setModelPerRol('arquitecte', this.value)" style="width:100%;font-size:.78rem;"></select>
          <div id="qualitatArq" style="font-size:.78em;margin-top:3px;"></div>
        </div>
      </div>

      <div id="panellEstimacio" style="background:var(--surface2);border-radius:6px;padding:10px;font-size:.88em;"></div>
      <div id="panellAvisos" style="margin-top:6px;font-size:.82em;"></div>
    </div>
  </div>

  <!-- Camp Ãºnic per a OpenAI / Gemini -->
  <div id="config-single-model-field" class="config-section hidden">
    <label class="field-label" for="config-model-single">Model</label>
    <input type="text" id="config-model-single" placeholder="gpt-4o" value="gpt-4o">
  </div>

  <label class="field-label" for="anthropicApiKey">ğŸ”‘ Anthropic API Key</label>
  <input type="password" id="anthropicApiKey" placeholder="sk-ant-..." oninput="guardarClausAPI()">

  <label class="field-label" for="geminiApiKey" style="margin-top:6px;">ğŸ”‘ Google Gemini API Key <span style="color:var(--text2);font-size:.78rem;">(opcional â€” per a models Gemini)</span></label>
  <input type="password" id="geminiApiKey" placeholder="AIza..." oninput="guardarClausAPI()">

  <label class="field-label" for="openaiApiKey" style="margin-top:6px;">ğŸ”‘ OpenAI API Key <span style="color:var(--text2);font-size:.78rem;">(opcional â€” per a models GPT)</span></label>
  <input type="password" id="openaiApiKey" placeholder="sk-..." oninput="guardarClausAPI()">

  <div style="margin-top:20px;padding-top:16px;border-top:1px solid var(--border);">
    <h3 style="margin:0 0 10px;font-size:1em;">ğŸ­ Estil i To Global del Projecte</h3>

    <label class="field-label" for="config-genere">GÃ¨nere Literari</label>
    <input type="text" id="config-genere" value="Thriller / Nordic Noir" placeholder="ex: CiÃ¨ncia-FicciÃ³, Nordic Noir...">

    <label class="field-label" for="config-autor">Autor de ReferÃ¨ncia</label>
    <input type="text" id="config-autor" value="Stieg Larsson" placeholder="ex: Stieg Larsson, Tolkien...">

    <label class="field-label" for="config-focus-climax">Focus del ClÃ­max (Cost acumulat)</label>
    <input type="text" id="config-focus-climax" value="Cost fÃ­sic extrem, esgotament mental, entorns freds i hostils, cinisme" placeholder="ex: Esgotament fÃ­sic, xoc moral...">
  </div>

  <div class="btn-row">
    <button class="btn btn-primary" onclick="guardarIComencar()">Guardar i ComenÃ§ar Nou</button>
    <button id="btn-reprendre" class="btn btn-secondary hidden" onclick="reprendreProjecteLocal()">ğŸ“‚ Reprendre projecte anterior</button>
    <button class="btn btn-ghost" onclick="exportarCopiaSeguretat()">ğŸ’¾ Exportar cÃ²pia (.json)</button>
    <button class="btn btn-ghost" onclick="obrirImportarCopiaSeguretat()">ğŸ“¥ Importar cÃ²pia</button>
    <input type="file" id="input-copia-seguretat" accept="application/json,.json" class="hidden" onchange="importarCopiaSeguretat(event)">
  </div>
</div>

<!-- Progress -->
<div id="progress-wrap" class="hidden">
  <div class="progress-steps" id="steps-bar">
    <div class="step-pill active" data-step="0">GÃ¨nere</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="1">Premissa</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="2">Estil</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="3">Protagonista</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="4">LocalitzaciÃ³</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="5">Final</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="6">Escriptura</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="7">MÃ³n</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="8">Personatges</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="9">Veus</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="9.2">Psicologia</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="9.3">Ferida/Arc</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="9.4">Relacions</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="9.5">Trames</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="10">Estructura</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="10.5">Escaleta</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="11">CapÃ­tols</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="12">Control d'Arcs</div>
  </div>
</div>

<!-- FASE 0: SelecciÃ³ de gÃ¨nere -->
<div class="card hidden" id="fase-0">
  <h2><span class="icon">ğŸ­</span> Tria el gÃ¨nere</h2>
  <label class="field-label" for="sel-tematica">Tipus de conte</label>
  <select id="sel-tematica">
    <option value="">â€” Selecciona un autor â€”</option>
    <option value="conte negre nÃ²rdic (Stieg Larsson)">Stieg Larsson â€” Noir, misteri i crÃ­tica social</option>
    <option value="conte fantÃ stic Ã¨pic (J.R.R. Tolkien)">J.R.R. Tolkien â€” Fantasia Ã¨pica</option>
    <option value="conte de ciÃ¨ncia-ficciÃ³ distÃ²pica (Philip K. Dick)">Philip K. Dick â€” Distopia, paranoia i drogues</option>
    <option value="conte de misticisme xamÃ nic (Carlos Castaneda)">Carlos Castaneda â€” Misticisme xamÃ nic</option>
  </select>
  <div class="btn-row">
    <button class="btn btn-primary" onclick="iniciarFase1()">âœ¨ Generar premisses</button>
  </div>
</div>

<!-- FASE 1: SelecciÃ³ de premissa -->
<div class="card hidden" id="fase-1">
  <h2><span class="icon">ğŸ’¡</span> Tria la premissa</h2>
  <div class="loader-wrap" id="loader-1">
    <div class="spinner"></div>
    <span>Generant 10 premissesâ€¦</span>
  </div>
  <div id="llista-premisses" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase1" onclick="iniciarFase2()">ğŸ¨ Triar estil narratiu</button>
  </div>
</div>

<!-- FASE 2: Estil narratiu (sense crida a LLM) -->
<div class="card hidden" id="fase-2">
  <h2><span class="icon">ğŸ¨</span> Estil narratiu</h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:4px;">Defineix el to, la perspectiva i la longitud del conte.</p>

  <label class="field-label">To i atmosfera</label>
  <select id="sel-to">
    <option value="">â€” Tria el to â€”</option>
    <option value="misteri i suspens creixent">Misteri i suspens</option>
    <option value="terror psicolÃ²gic i claustrofÃ²bic">Terror psicolÃ²gic</option>
    <option value="realisme mÃ gic poÃ¨tic">Realisme mÃ gic</option>
    <option value="humor negre i irÃ²nic">Humor negre</option>
    <option value="melancolia i bittersweet">Melancolia / bittersweet</option>
    <option value="thriller emocional d'alta tensiÃ³">Thriller emocional</option>
    <option value="tendresa i vulnerabilitat">Tendresa i vulnerabilitat</option>
    <option value="absurd i kafkiÃ ">Absurd / kafkiÃ </option>
    <option value="meravella i mÃ gia continguda">MÃ gia i meravella</option>
    <option value="rÃ bia i tensiÃ³ social">RÃ bia i tensiÃ³ social</option>
  </select>

  <label class="field-label">Perspectiva narrativa</label>
  <div class="opts-row" id="opts-perspectiva">
    <div class="opt-pill" data-group="perspectiva" data-val="primera persona (narrador protagonista)" onclick="triarPill(this)">
      1a persona
      <small>Jo narrador</small>
    </div>
    <div class="opt-pill" data-group="perspectiva" data-val="tercera persona limitada (focalitzaciÃ³ Ãºnica en el protagonista)" onclick="triarPill(this)">
      3a persona
      <small>FocalitzaciÃ³ Ãºnica</small>
    </div>
    <div class="opt-pill" data-group="perspectiva" data-val="segona persona (el lector Ã©s el protagonista)" onclick="triarPill(this)">
      2a persona
      <small>Tu ets el protagonista</small>
    </div>
  </div>

  <label class="field-label">Longitud del conte</label>
  <div class="opts-row" id="opts-paraules">
    <div class="opt-pill" data-group="paraules" data-val="500" onclick="triarPill(this)">
      Microconte
      <small>~500 paraules</small>
    </div>
    <div class="opt-pill" data-group="paraules" data-val="1500" onclick="triarPill(this)">
      Conte curt
      <small>~1.500 paraules</small>
    </div>
    <div class="opt-pill" data-group="paraules" data-val="3000" onclick="triarPill(this)">
      Conte llarg
      <small>~3.000 paraules</small>
    </div>
  </div>

  <!-- Veu Semilla (opcional) -->
  <div style="margin-top:20px;padding-top:16px;border-top:1px solid var(--border);">
    <label class="field-label">Veu de ReferÃ¨ncia (opcional) <span style="font-weight:400;color:var(--text2)">â€” Enganxa 2-3 pÃ gines d'un autor que t'agradi</span></label>
    <textarea id="veuSemilla" style="width:100%;min-height:120px;background:var(--surface2);border:1px solid var(--border);border-radius:8px;color:var(--text);padding:12px;font-size:.88rem;resize:vertical;" placeholder="Opcional: enganxa un fragment d'un autor de referÃ¨ncia (mÃ­nim 200 carÃ cters). Opus analitzarÃ  el seu estil i en generarÃ  un manual per guiar l'escriptura."></textarea>
    <button class="btn btn-secondary" style="margin-top:8px;" onclick="processarVeuSemilla()">ğŸ­ Analitzar estil de referÃ¨ncia <span class="badge-model badge-opus">Opus</span></button>
    <div id="veuSemilla-result" style="margin-top:8px;font-size:.83rem;color:var(--success);"></div>
  </div>
  <div class="btn-row">
    <button class="btn btn-primary" onclick="iniciarFase3()">ğŸ‘¤ Triar protagonista</button>
  </div>
</div>

<!-- FASE 3: Protagonista -->
<div class="card hidden" id="fase-3">
  <h2><span class="icon">ğŸ‘¤</span> Tria el protagonista</h2>
  <div class="loader-wrap" id="loader-3">
    <div class="spinner"></div>
    <span>Generant protagonistesâ€¦</span>
  </div>
  <div id="llista-personatges" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase3" onclick="iniciarFase4()">ğŸ“ Triar la localitzaciÃ³</button>
  </div>
</div>

<!-- FASE 4: Localitzacions -->
<div class="card hidden" id="fase-4">
  <h2><span class="icon">ğŸ“</span> Tria la localitzaciÃ³</h2>
  <div class="loader-wrap" id="loader-4">
    <div class="spinner"></div>
    <span>Generant 5 localitzacionsâ€¦</span>
  </div>
  <div id="llista-localitzacions" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase4" onclick="iniciarFase5()">ğŸ Triar el final</button>
  </div>
</div>

<!-- FASE 5: Finals -->
<div class="card hidden" id="fase-5">
  <h2><span class="icon">ğŸ</span> Tria el final</h2>
  <div class="loader-wrap" id="loader-5">
    <div class="spinner"></div>
    <span>Generant 5 finals possiblesâ€¦</span>
  </div>
  <div id="llista-finals" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase5" onclick="iniciarEscriptura()">âœï¸ Escriure el conte</button>
  </div>
</div>

<!-- FASE 6: Escriptura -->
<div class="card hidden" id="fase-6">
  <h2><span class="icon">âœï¸</span> El teu conte</h2>
  <div class="loader-wrap" id="loader-6">
    <div class="spinner"></div>
    <span id="loader-6-text">Escrivint el conteâ€¦</span>
  </div>
  <div id="conte-wrap" class="hidden">
    <div class="conte-reader" id="conte-cos"></div>
    <div class="conte-wordcount" id="conte-wordcount"></div>

    <!-- Millora -->
    <div class="millora-row">
      <input type="text" id="millora-input" placeholder="Vols millorar alguna cosa? (ex: Â«fes l'ending mÃ©s abrupteÂ»)">
      <button class="btn btn-secondary" onclick="handleMillorarConte()">âœ¨ Millorar</button>
    </div>

    <div class="btn-row">
      <button class="btn btn-secondary" onclick="regenerarConte()">ğŸ”„ Regenerar</button>
      <button class="btn btn-secondary" onclick="exportarDoc()">ğŸ“„ Exportar TXT + Google Docs</button>
      <button class="btn btn-primary"   onclick="iniciarFase7()">ğŸŒ Expandir a novelÂ·la</button>
    </div>
    <div id="export-link-wrap" class="hidden" style="margin-top:14px;"></div>
  </div>
</div>

<!-- FASE 7: Worldbuilding -->
<div class="card hidden" id="fase-7">
  <h2><span class="icon">ğŸŒ</span> ExpansiÃ³ del mÃ³n</h2>
  <div class="loader-wrap" id="loader-7">
    <div class="spinner"></div>
    <span id="loader-7-text">Analitzant el conte per proposar elements de mÃ³nâ€¦</span>
  </div>

  <div id="world-selector" class="hidden">
    <p style="color:var(--text2);font-size:.9rem;margin-bottom:16px;">Selecciona els elements que vols expandir a la bÃ­blia de mÃ³n. Els <span style="color:var(--accent2);font-weight:600;">Recomanats</span> ja estan marcats:</p>
    <div id="llista-world" class="premise-list"></div>
    <div class="btn-row">
      <button class="btn btn-primary" onclick="expandirElementsSeleccionats()">ğŸŒ Expandir seleccionats</button>
    </div>
  </div>

  <div id="world-result-wrap" class="hidden">
    <div class="worldbuilding-result" id="world-result-cos"></div>
    <div class="btn-row" style="margin-top:20px;">
      <button class="btn btn-secondary" onclick="tornarASeleccioWorld()">â† Tornar a la selecciÃ³</button>
      <button class="btn btn-primary"   onclick="iniciarFase8()">ğŸ‘¥ Crear elenc de personatges</button>
    </div>
  </div>
</div>


<!-- FASE 8: Elenc de personatges -->
<div class="card hidden" id="fase-8">
  <h2><span class="icon">ğŸ‘¥</span> Elenc de personatges</h2>
  <div class="loader-wrap" id="loader-8">
    <div class="spinner"></div>
    <span id="loader-8-text">Proposant el cast de personatgesâ€¦</span>
  </div>

  <div id="elenc-selector" class="hidden">
    <p style="color:var(--text2);font-size:.9rem;margin-bottom:16px;">Selecciona els personatges que formaran part de la novelÂ·la. Els <span style="color:var(--accent2);font-weight:600;">Recomanats</span> ja estan marcats:</p>
    <div id="llista-elenc" class="premise-list"></div>
    <div class="btn-row">
      <button class="btn btn-primary" onclick="generarEstilsParla()">ğŸ—£ï¸ Definir estils de parla</button>
    </div>
  </div>
</div>

<!-- FASE 9: Estils de parla -->
<div class="card hidden" id="fase-9">
  <h2><span class="icon">ğŸ—£ï¸</span> Estils de parla</h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Perfil de veu i registre narratiu per a cada personatge de l'elenc.</p>
  <div class="loader-wrap" id="loader-9">
    <div class="spinner"></div>
    <span>Definint la veu de cada personatgeâ€¦</span>
  </div>

  <div id="estils-result" class="hidden">
    <div class="veu-result" id="estils-cos"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-secondary" onclick="tornarAElenc()">â† Tornar a l'elenc</button>
      <button class="btn btn-primary" onclick="iniciarFasePsicologia()">ğŸ§  Analitzar Psicologia</button>
    </div>
  </div>
</div>

<!-- FASE 9.2: Perfils PsicolÃ²gics -->
<div class="card hidden" id="fase-9-2">
  <h2><span class="icon">ğŸ§ </span> Perfils PsicolÃ²gics</h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">AnÃ lisi de personalitat i estat d'Ã nim base del protagonista i de l'elenc que has seleccionat a la fase 8.</p>
  <div class="loader-wrap" id="loader-9-2">
    <div class="spinner"></div>
    <span>Analitzant la psicologia dels personatges...</span>
  </div>

  <div id="psicologia-result" class="hidden">
    <div id="psicologia-cos" class="veu-result"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-secondary" onclick="hideCard('fase-9-2');showCard('fase-9');">â† Tornar a Veus</button>
      <button class="btn btn-primary" onclick="iniciarFaseFeridaArc()">ğŸ©¹ Definir Ferida + Arc</button>
    </div>
  </div>
</div>



<!-- FASE 9.3: Ferida nuclear + mÃ scara + arc intern -->
<div class="card hidden" id="fase-9-3">
  <h2><span class="icon">ğŸ©¹</span> Ferida Nuclear i Arc Intern</h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Consolidem la psicologia profunda: ferida nuclear, mÃ scara social i etapa de l'arc intern (5 etapes).</p>
  <div class="loader-wrap" id="loader-9-3">
    <div class="spinner"></div>
    <span>Definint ferides i arcs interns...</span>
  </div>

  <div id="ferida-arc-result" class="hidden">
    <div id="ferida-arc-cos" class="veu-result"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-secondary" onclick="hideCard('fase-9-3');showCard('fase-9-2');">â† Tornar a Psicologia</button>
      <button class="btn btn-primary" onclick="iniciarFaseRelacions()">ğŸ§· Matriu relacional</button>
    </div>
  </div>
</div>

<!-- FASE 9.4: Matriu relacional emocional -->
<div class="card hidden" id="fase-9-4">
  <h2><span class="icon">ğŸ§·</span> Matriu Relacional Emocional</h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Definim la tensiÃ³ emocional entre parelles de personatges per reforÃ§ar conflicte i subtext.</p>
  <div class="loader-wrap" id="loader-9-4">
    <div class="spinner"></div>
    <span>Calculant dinÃ miques de relaciÃ³...</span>
  </div>

  <div id="relacions-result" class="hidden">
    <div id="relacions-cos" class="veu-result"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-secondary" onclick="hideCard('fase-9-4');showCard('fase-9-3');">â† Tornar a Ferida/Arc</button>
      <button class="btn btn-primary" onclick="iniciarFaseTrames()">ğŸ•¸ï¸ Dissenyar Trames Opus</button>
    </div>
  </div>
</div>

<!-- FASE 9.5: Disseny de Trames (Opus) -->
<div class="card hidden" id="fase-9-5">
  <h2><span class="icon">ğŸ•¸ï¸</span> Disseny de Trames <span class="badge-model badge-opus">Opus</span></h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Opus dissenya la trama principal i les subtrames abans d'estructurar els capÃ­tols.</p>
  <div class="loader-wrap" id="loader-9-5">
    <div class="spinner" style="border-top-color:#60a5fa;"></div>
    <span id="loader-9-5-text">ğŸ”µ Opus dissenyant les tramesâ€¦</span>
  </div>
  <div id="trames-result" class="hidden">
    <div id="trames-cos"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-primary" onclick="iniciarFase10()">ğŸ“ Crear Estructura <span class="badge-model badge-opus">Opus</span></button>
    </div>
  </div>
</div>

<!-- FASE 10: Estructura de la novelÂ·la (Opus) -->
<div class="card hidden" id="fase-10">
  <h2><span class="icon">ğŸ“</span> Estructura de la novelÂ·la <span class="badge-model badge-opus">Opus</span></h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Opus dissenya l'arquitectura narrativa completa â€” capÃ­tols, arcs i fils â€” a partir de tot el material generat.</p>
  <div class="loader-wrap" id="loader-10">
    <div class="spinner" style="border-top-color:#60a5fa;"></div>
    <span id="loader-10-text">ğŸ”µ Opus dissenyant l'estructuraâ€¦</span>
  </div>
  <div id="estructura-wrap" class="hidden">
    <div id="estructura-cos"></div>
    <div id="estimacio-cost" style="white-space:pre;font-family:monospace;font-size:.82rem;color:var(--text2);background:var(--surface2);border-radius:8px;padding:12px 16px;margin:16px 0;border-left:3px solid var(--accent2);display:block;"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-primary" onclick="iniciarFaseEscaleta()">ğŸ“– Escriure capÃ­tols <span class="badge-model badge-sonnet">Sonnet</span></button>
    </div>
  </div>
</div>

<!-- FASE 10.5: Escaleta per Escenes (Opus) -->
<div class="card hidden" id="fase-10-5">
  <h2>ğŸ“‹ Fase 10.5 â€” Escaleta per Escenes</h2>
  <p>Opus genera l'escaleta detallada per escenes de tots els capÃ­tols, incloent objectiu de paraules i funciÃ³ narrativa de cada escena.</p>
  <div class="loader-wrap" id="loader-10-5"><span class="spinner"></span><span id="loader-10-5-text">Generant escaletaâ€¦</span></div>
  <div id="escaleta-result"></div>
  <button class="btn hidden" id="btn-fase11" onclick="iniciarFase11()">Continuar â†’ Escriptura</button>
</div>

<!-- FASE 11: Escriptura de capÃ­tols (Sonnet + registre) -->
<div class="card hidden" id="fase-11">
  <h2><span class="icon">ğŸ“–</span> Escriptura de capÃ­tols</h2>

  <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:14px;flex-wrap:wrap;gap:8px;">
    <div id="capitol-progress-text" style="color:var(--text2);font-size:.88rem;"></div>
    <div style="display:flex; gap:8px;">
      <button id="btn-pausa-flux" class="btn btn-ghost hidden" style="padding:7px 14px;font-size:.82rem;color:var(--warning);border-color:var(--warning);" onclick="togglePausaFlux()">â¸ Pausar AutomÃ tic</button>
      <button id="btn-mode-manual-capitols" class="btn btn-ghost hidden" style="padding:7px 14px;font-size:.82rem;" onclick="toggleModeManualCapitols()">ğŸ§­ Mode: AutomÃ tic total</button>
      <button class="btn btn-ghost" style="padding:7px 14px;font-size:.82rem;" onclick="obrirLlibreRegistre()">ğŸ““ Llibre de Registre</button>
      <button class="btn btn-ghost" style="padding:7px 14px;font-size:.82rem;" onclick="obrirBiblia()">ğŸ“š BÃ­blia Narrativa</button>
    </div>
  </div>

  <div id="capitol-llista" style="display:flex;flex-direction:column;gap:6px;margin-bottom:20px;max-height:260px;overflow-y:auto;"></div>
  <div id="capitol-seguent-manual-wrap" class="hidden" style="margin-top:-8px;margin-bottom:16px;">
    <button id="btn-capitol-seguent-manual" class="btn btn-primary" onclick="iniciarSeguentCapitolManual()">â–¶ ComenÃ§ar proper capÃ­tol</button>
  </div>

  <div class="loader-wrap" id="loader-11">
    <div class="spinner"></div>
    <span id="loader-11-text">ğŸŸ£ Sonnet escrivint el capÃ­tolâ€¦</span>
  </div>

  <div id="capitol-actual-wrap" class="hidden">
    <div id="capitol-actual-titol" style="font-size:1.05rem;font-weight:700;color:var(--accent2);margin-bottom:14px;padding-bottom:10px;border-bottom:1px solid var(--border);"></div>
    <div class="conte-reader" id="capitol-actual-cos"></div>
    <div class="conte-wordcount" id="capitol-actual-wordcount"></div>
    <div id="revisio-panel" class="hidden review-panel"></div>
    <div id="checkpoint-intermedi-panel" class="hidden" style="margin-top:16px;padding:16px;background:var(--surface2);border-radius:10px;border-left:3px solid #f59e0b;"></div>
    <div class="btn-row" id="capitol-accions" style="margin-top:16px;"></div>
  </div>

  <div id="capitol-detall-wrap" class="hidden capitol-detall-wrap">
    <div id="capitol-detall-content"></div>
    <div class="btn-row" style="margin-top:8px;">
      <button class="btn btn-secondary" onclick="executarSegonaRevisioOpusCapitol()">ğŸ” Segona RevisiÃ³ Opus</button>
      <button class="btn btn-primary" onclick="exportarDetallCapitolActualTxt()">ğŸ“¤ Exportar tot (.txt)</button>
    </div>
  </div>

  <div id="btn-control-arcs-wrap" class="hidden" style="margin-top:24px;padding-top:20px;border-top:1px solid var(--border);">
    <p style="color:var(--text2);font-size:.88rem;margin-bottom:14px;text-align:center;">Tots els capÃ­tols estan escrits.</p>

    <!-- RevisiÃ³ Global (loader) -->
    <div id="revisio-global-loader" class="hidden" style="display:flex;align-items:center;gap:10px;color:var(--text2);font-size:.88rem;margin-bottom:16px;padding:14px;background:var(--surface2);border-radius:8px;">
      <div class="spinner" style="border-top-color:#60a5fa;width:24px;height:24px;border-width:2px;"></div>
      <span>ğŸ”µ Opus fent revisiÃ³ global transversalâ€¦</span>
    </div>

    <!-- Resultats de la RevisiÃ³ Global -->
    <div id="revisio-global-result" class="hidden" style="margin-bottom:16px;"></div>

    <!-- Botons de reescriptura suggerits per Opus -->
    <div id="revisio-global-reescriptures" style="margin-bottom:16px;display:flex;gap:10px;flex-wrap:wrap;"></div>

    <!-- Botons de flux -->
    <div style="text-align:center;display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
      <button class="btn btn-primary hidden" id="btn-control-arcs" onclick="iniciarFase12()">ğŸ“‹ Control d'Arcs Narratius <span class="badge-model badge-opus">Opus</span></button>
      <button class="btn btn-secondary" onclick="obrirManuscrit()">ğŸ–‹ï¸ Mode Manuscrit</button>
      <button class="btn btn-secondary" onclick="descarregarNovella()">ğŸ“– Descarregar NovelÂ·la</button>
      <button class="btn btn-ghost" onclick="generarInformePostMortem()" style="color:var(--accent); border-color:var(--accent);">ğŸ§  Informe Post-Mortem (Opus)</button>
    </div>

    <div id="post-mortem-wrap" class="hidden" style="margin-top:30px; padding:20px; background:var(--surface2); border:1px solid var(--accent); border-radius:8px;">
      <h3 style="color:var(--accent); margin-top:0;">ğŸ§  Informe Editorial i TÃ¨cnic (Post-Mortem)</h3>
      <div id="post-mortem-content" class="conte-reader" style="font-size:0.95rem;"></div>
    </div>

  </div>
</div>

<!-- FASE 12: Control d'Arcs Narratius (Opus - light) -->
<div class="card hidden" id="fase-12">
  <h2><span class="icon">ğŸ“‹</span> Control d'Arcs Narratius <span class="badge-model badge-opus">Opus</span></h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Opus avalua la novelÂ·la a partir dels resums â€” sense llegir el text complet â€” per estalviar tokens.</p>
  <div class="loader-wrap" id="loader-12">
    <div class="spinner" style="border-top-color:#60a5fa;"></div>
    <span>ğŸ”µ Opus analitzant els arcs narratiusâ€¦</span>
  </div>
  <div id="arcs-result" class="hidden">
    <div id="arcs-cos"></div>
    <div id="termometre-veritat" style="margin-top:16px;"></div>
    <div class="btn-row" style="margin-top:20px;">
      <button class="btn btn-primary hidden" id="btn-epileg" onclick="escriureEpileg()">âœ¨ Escriure EpÃ­leg Resolutiu <span class="badge-model badge-sonnet">Sonnet</span></button>
    </div>
  </div>
  <div id="epileg-loader-wrap" class="hidden" style="padding:20px 0;border-top:1px solid var(--border);margin-top:20px;">
    <div style="display:flex;align-items:center;gap:10px;color:var(--text2);font-size:.88rem;margin-bottom:14px;">
      <div class="spinner" style="width:24px;height:24px;border-width:2px;"></div>
      <span>ğŸŸ£ Sonnet escrivint l'epÃ­legâ€¦</span>
    </div>
  </div>
  <div id="epileg-cos" class="hidden" style="margin-top:20px;padding-top:20px;border-top:1px solid var(--border);">
    <h3 style="font-size:1rem;font-weight:600;color:var(--accent2);margin-bottom:14px;">EpÃ­leg</h3>
    <div class="conte-reader" id="epileg-text"></div>
    <div class="btn-row" style="margin-top:20px;">
      <button class="btn btn-secondary" onclick="obrirManuscrit()">ğŸ–‹ï¸ Mode Manuscrit</button>
      <button class="btn btn-primary" onclick="descarregarNovella()">ğŸ“– Descarregar NovelÂ·la Completa</button>
    </div>
  </div>
</div>

<div class="modal-overlay hidden" id="modal-manuscrit">
  <div class="modal-box" style="max-width:960px; height:85vh; display:flex; flex-direction:column;">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:14px;">
      <h3 style="font-size:1.2rem;font-weight:600;color:var(--accent2);">ğŸ–‹ï¸ Mode Manuscrit</h3>
      <button class="btn btn-ghost" style="padding:6px 14px;" onclick="tancarManuscrit()">âœ• Tancar</button>
    </div>
    <div style="display:flex; gap:16px; flex:1; overflow:hidden;">
      <div id="manuscrit-sidebar" style="width:160px; overflow-y:auto; border-right:1px solid var(--border); padding-right:10px; display:flex; flex-direction:column; gap:6px;">
      </div>
      <div style="flex:1; display:flex; flex-direction:column; overflow-y:hidden; padding-right:4px;">
        <div id="manuscrit-editor" class="conte-reader" contenteditable="true" style="flex:1; outline:none; margin-bottom:14px; min-height:300px; padding:20px; overflow-y:auto;" onblur="guardarManuscritActual()"></div>
        <div style="display:flex; gap:10px; align-items:center; background:var(--surface2); padding:10px; border-radius:8px; border:1px solid var(--border);">
          <span style="font-size:1.2rem;">âœ¨</span>
          <input type="text" id="manuscrit-instruccio" placeholder="Subratlla un text i escriu quÃ¨ vols millorar (ex: fes-ho mÃ©s fosc)" style="flex:1; padding:8px 12px; border-radius:6px; border:1px solid var(--border); background:var(--surface); color:var(--text); font-family:var(--font);">
          <button class="btn btn-primary" style="padding:8px 16px; font-size:.85rem;" onclick="reescriureSeleccioManuscrit(event)">Reescriure IA</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal: Llibre de Registre -->
<div class="modal-overlay hidden" id="modal-registre">
  <div class="modal-box">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px;">
      <h3 style="font-size:1.1rem;font-weight:600;color:var(--accent2);">ğŸ““ Llibre de Registre</h3>
      <button class="btn btn-ghost" style="padding:6px 14px;" onclick="tancarModalRegistre()">âœ• Tancar</button>
    </div>
    <div id="registre-cos"></div>
  </div>
</div>

<!-- Modal: BÃ­blia Narrativa -->
<div class="modal-overlay hidden" id="modal-biblia">
  <div class="modal-box" style="max-width:760px;">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px;">
      <h3 style="font-size:1.1rem;font-weight:600;color:var(--accent2);">ğŸ“š BÃ­blia Narrativa</h3>
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="btn-regenerar-biblia" class="btn btn-ghost" style="padding:6px 14px;font-size:.82rem;" onclick="regenerarBibliaNarrativa()">ğŸ”„ Regenerar</button>
        <button class="btn btn-ghost" style="padding:6px 14px;" onclick="tancarModalBiblia()">âœ• Tancar</button>
      </div>
    </div>
    <div id="biblia-cos"></div>
  </div>
</div>

<div id="toast"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     FRONTEND â€” utilitats i lÃ²gica de navegaciÃ³
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITATS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function escHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function showCard(id)  { document.getElementById(id).classList.remove('hidden'); }
function hideCard(id)  { document.getElementById(id).classList.add('hidden'); }
function showLoader(n) { document.getElementById('loader-' + n).classList.add('visible'); }
function hideLoader(n) {
  document.getElementById('loader-' + n).classList.remove('visible');
  // Autoguardat cada cop que un procÃ©s de la IA acaba
  guardarProjecteLocal();
}
function showBtn(id)   { document.getElementById(id).classList.remove('hidden'); }

// --- GESTOR DE FLUX AUTOMÃ€TIC (CUA RESILIENT) ---
const GestorFlux = {
  pausat: false,
  cua: [],
  enExecucio: false,
  afegirTasca(nom, funcio, delayMs = 0) {
    this.cua.push({ nom, funcio, delayMs });
    this.processarCua();
  },
  async processarCua() {
    if (this.enExecucio || this.pausat || this.cua.length === 0) return;
    this.enExecucio = true;
    const tasca = this.cua.shift();
    console.log(`[GestorFlux] Preparant: ${tasca.nom} (espera de ${tasca.delayMs / 1000}s)`);
    if (tasca.delayMs > 0) {
      await new Promise(r => setTimeout(r, tasca.delayMs));
    }
    if (!this.pausat) {
      try { await tasca.funcio(); }
      catch (e) { console.error(`[GestorFlux] Error a ${tasca.nom}:`, e); }
    } else {
      // Si s'ha pausat durant l'espera, tornem a posar la tasca al principi de la cua
      this.cua.unshift(tasca);
    }
    this.enExecucio = false;
    this.processarCua();
  },
  pausar() {
    this.pausat = true;
    const btn = document.getElementById('btn-pausa-flux');
    if (btn) btn.innerHTML = 'â–¶ Reprendre AutomÃ tic';
    toast("Flux automÃ tic pausat. S'aturarÃ  en acabar l'acciÃ³ en curs.");
  },
  reprendre() {
    this.pausat = false;
    const btn = document.getElementById('btn-pausa-flux');
    if (btn) btn.innerHTML = 'â¸ Pausar AutomÃ tic';
    toast('Flux automÃ tic reprÃ¨s.');
    this.processarCua();
  }
};

function togglePausaFlux() {
  if (GestorFlux.pausat) GestorFlux.reprendre();
  else GestorFlux.pausar();
}


function esModeManualEntreCapitols() {
  return !!(USER_CONFIG && USER_CONFIG.fluxAutomatic && ESTAT._modeManualCapitols);
}

function actualitzarBotoModeManualCapitols() {
  const btn = document.getElementById('btn-mode-manual-capitols');
  if (!btn) return;
  const visible = !!(USER_CONFIG && USER_CONFIG.fluxAutomatic);
  btn.classList.toggle('hidden', !visible);
  btn.textContent = esModeManualEntreCapitols() ? 'ğŸ§­ Mode: Manual entre capÃ­tols' : 'ğŸ§­ Mode: AutomÃ tic total';
}

function toggleModeManualCapitols() {
  ESTAT._modeManualCapitols = !ESTAT._modeManualCapitols;
  if (!ESTAT._modeManualCapitols) {
    amagarBotoSeguentCapitolManual();
  }
  actualitzarBotoModeManualCapitols();
  toast(ESTAT._modeManualCapitols ? 'Mode manual entre capÃ­tols activat.' : 'Mode automÃ tic total activat.');
}

function mostrarBotoSeguentCapitolManual(nextIdx) {
  const wrap = document.getElementById('capitol-seguent-manual-wrap');
  const btn = document.getElementById('btn-capitol-seguent-manual');
  if (!wrap || !btn) return;
  ESTAT._capitolPendentManual = nextIdx;
  btn.textContent = `â–¶ ComenÃ§ar CapÃ­tol ${nextIdx + 1}`;
  wrap.classList.remove('hidden');
}

function amagarBotoSeguentCapitolManual() {
  ESTAT._capitolPendentManual = null;
  const wrap = document.getElementById('capitol-seguent-manual-wrap');
  if (wrap) wrap.classList.add('hidden');
}

function iniciarSeguentCapitolManual() {
  const idx = ESTAT._capitolPendentManual;
  if (idx === null || idx === undefined) {
    toast('No hi ha capÃ­tol pendent.');
    return;
  }
  amagarBotoSeguentCapitolManual();
  generarCapitol(idx);
}

// --- SISTEMA DE PERSISTÃˆNCIA ---
const CLAU_PROJECTE_ACTUAL = 'booki_projecte_actual';
const CLAU_HISTORIAL = 'booki_projecte_historial';
const MAX_SNAPSHOTS = 6;

function construirSnapshotProjecte() {
  return {
    versio: 1,
    guardat_el: new Date().toISOString(),
    estat: ESTAT,
    config: USER_CONFIG
  };
}

function guardarProjecteLocal() {
  if (ESTAT.fase === 0) return; // No guardem si no ha comenÃ§at
  try {
    const snapshot = construirSnapshotProjecte();
    localStorage.setItem(CLAU_PROJECTE_ACTUAL, JSON.stringify(snapshot));

    const hist = JSON.parse(localStorage.getItem(CLAU_HISTORIAL) || '[]');
    hist.push(snapshot);
    const histCurt = hist.slice(-MAX_SNAPSHOTS);
    localStorage.setItem(CLAU_HISTORIAL, JSON.stringify(histCurt));
  } catch (e) {
    console.warn("No s'ha pogut guardar a localStorage:", e);
  }
}

function comprovarProjecteGuardat() {
  const guardat = localStorage.getItem(CLAU_PROJECTE_ACTUAL);
  if (guardat) {
    document.getElementById('btn-reprendre').classList.remove('hidden');
  }
}

function aplicarSnapshotProjecte(dades) {
  if (!dades || !dades.estat) throw new Error('Format de cÃ²pia no vÃ lid');

  Object.assign(ESTAT, dades.estat);
  USER_CONFIG = dades.config || USER_CONFIG;

  if (ESTAT._anthropicApiKey) document.getElementById('anthropicApiKey').value = ESTAT._anthropicApiKey;
  if (ESTAT._openaiApiKey) document.getElementById('openaiApiKey').value = ESTAT._openaiApiKey;
  if (ESTAT._geminiApiKey) document.getElementById('geminiApiKey').value = ESTAT._geminiApiKey;

  if (typeof poblarSelectorsModels === 'function') poblarSelectorsModels();
  if (typeof sincronitzarCampsConfigModels === 'function') sincronitzarCampsConfigModels();
  if (typeof guardarClausAPI === 'function') guardarClausAPI();

  const targetQualitatInput = document.getElementById('config-target-qualitat');
  if (targetQualitatInput && USER_CONFIG && USER_CONFIG.targetQualitat != null) {
    targetQualitatInput.value = USER_CONFIG.targetQualitat;
  }

  restaurarInterficieDesDeEstat();
}

function reprendreProjecteLocal() {
  const guardat = localStorage.getItem(CLAU_PROJECTE_ACTUAL);
  if (!guardat) return;
  try {
    const dades = JSON.parse(guardat);
    aplicarSnapshotProjecte(dades);
    toast('Projecte recuperat amb Ã¨xit.');
  } catch (e) {
    toast('Error en recuperar el projecte: ' + e.message);
  }
}

function exportarCopiaSeguretat() {
  if (ESTAT.fase === 0) {
    toast('Encara no hi ha cap projecte per exportar.');
    return;
  }
  try {
    const snapshot = construirSnapshotProjecte();
    const nom = `booki_backup_fase_${String(ESTAT.fase).replace('.', '_')}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
    const blob = new Blob([JSON.stringify(snapshot, null, 2)], { type: 'application/json;charset=utf-8' });
    descarregarBlobFitxer(blob, nom);
    toast('CÃ²pia exportada: ' + nom);
  } catch (err) {
    toast("No s'ha pogut exportar la cÃ²pia: " + err.message);
  }
}

function obrirImportarCopiaSeguretat() {
  const input = document.getElementById('input-copia-seguretat');
  if (!input) return;
  input.value = '';
  input.click();
}

function importarCopiaSeguretat(event) {
  const file = event && event.target && event.target.files ? event.target.files[0] : null;
  if (!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    try {
      const dades = JSON.parse(String(reader.result || '{}'));
      aplicarSnapshotProjecte(dades);
      localStorage.setItem(CLAU_PROJECTE_ACTUAL, JSON.stringify(dades));
      toast('CÃ²pia importada correctament.');
    } catch (err) {
      toast('Fitxer de cÃ²pia invÃ lid: ' + err.message);
    }
  };
  reader.onerror = () => toast("No s'ha pogut llegir el fitxer de cÃ²pia.");
  reader.readAsText(file, 'utf-8');
}

function restaurarInterficieDesDeEstat() {
  hideCard('card-config');
  document.getElementById('progress-wrap').classList.remove('hidden');

  const fase = ESTAT.fase;
  updateProgress(fase);

  // Mostrar totes les fases fins a la fase actual per poder reprendre
  // i re-treballar des de qualsevol punt del pipeline.
  document.querySelectorAll('.card').forEach(c => {
    if (c.id === 'card-config') return;
    const idMatch = c.id.match(/^fase-(\d+)(?:-(\d+))?$/);
    if (!idMatch) return;
    const faseCard = parseFloat(idMatch[1] + (idMatch[2] ? '.' + idMatch[2] : ''));
    if (faseCard <= fase) c.classList.remove('hidden');
    else c.classList.add('hidden');
  });

  // Reconstruir l'estat visual depenent de la fase
  if (fase >= 1 && ESTAT._premissaLista.length > 0) renderPremisses(ESTAT._premissaLista.map((p, i) => `${i+1}. ${p}`).join('\\n'));
  if (fase >= 3 && ESTAT._llistaProtagonistes.length > 0) renderProtagonistes(ESTAT._llistaProtagonistes.map((p, i) => `${i+1}. ${p}`).join('\\n'));
  if (fase >= 4 && ESTAT._llistaLocalitzacions.length > 0) renderLlistaAmbRecomanat(ESTAT._llistaLocalitzacions.map((p, i) => `${i+1}. ${p}`).join('\\n'), 'llista-localitzacions', '_llistaLocalitzacions', '_idxLocalitzacio', 'btn-fase4');
  if (fase >= 5 && ESTAT._llistaFinals.length > 0) renderLlistaAmbRecomanat(ESTAT._llistaFinals.map((p, i) => `${i+1}. ${p}`).join('\\n'), 'llista-finals', '_llistaFinals', '_idxFinal', 'btn-fase5');
  if (fase >= 6 && ESTAT.conteText) mostrarConte(ESTAT.conteText);
  if (fase >= 7 && ESTAT.worldbuilding) mostrarResultatWorldbuilding(ESTAT.worldbuilding);
  if (fase >= 9 && ESTAT.estilsParla) mostrarEstilsParla(ESTAT.estilsParla);
  if (fase >= 9.2 && ESTAT._perfilsPersonatges && Object.keys(ESTAT._perfilsPersonatges).length > 0) mostrarPerfilsPsicologics({ personatges: Object.values(ESTAT._perfilsPersonatges) });
  if (fase >= 9.3 && ESTAT._perfilsPersonatges && Object.keys(ESTAT._perfilsPersonatges).length > 0) mostrarFeridaArc({ personatges: Object.values(ESTAT._perfilsPersonatges) });
  if (fase >= 9.4 && ESTAT._matriuRelacional && ESTAT._matriuRelacional.length > 0) mostrarMatriuRelacional(ESTAT._matriuRelacional);
  if (fase >= 10 && ESTAT._estructuraCapitols.length > 0) mostrarEstructura('ReconstruÃ¯t des de memÃ²ria (dades en JSON actiu)');
  if (fase >= 10.5 && ESTAT._escaletes.length > 0) {
    mostrarEscaleta(ESTAT._escaletes);
    document.getElementById('btn-fase11').classList.remove('hidden');
  }
  if (fase >= 11) {
    renderLlistaCapitols();
    if (ESTAT._nkg) nkgInicialitzar(); // Re-assigna objectes de memÃ²ria
    ESTAT._nkg = ESTAT._nkg; // MantÃ© el reference si ja hi era

    // Si estem a meitat d'escriure
    const capActual = ESTAT._capitolActual || 0;
    if (ESTAT._capitols_generats[capActual]) {
      mostrarCapitol(capActual, ESTAT._capitols_generats[capActual]);
      mostrarAccionsCapitolSimple(capActual, capActual >= ESTAT._estructuraCapitols.length - 1);
    }
  }
}

// --- EFECTE D'ESCRIPTURA EN VIU ---
async function efecteEscripturaHTML(elementId, htmlContent, msPerChar = 3) {
  const el = document.getElementById(elementId);
  if (!el) return;
  el.innerHTML = '';

  // Creem un element temporal per parsejar les etiquetes (com <p>, <strong>...)
  const temp = document.createElement('div');
  temp.innerHTML = htmlContent;

  async function typeNode(node, parent) {
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent;
      for (let i = 0; i < text.length; i++) {
        parent.appendChild(document.createTextNode(text[i]));
        // Scroll automÃ tic suau cap avall mentre escriu
        const scrollContainer = el.closest('.conte-reader') || el;
        if (scrollContainer.scrollHeight - scrollContainer.scrollTop > scrollContainer.clientHeight) {
            scrollContainer.scrollTop = scrollContainer.scrollHeight;
        }
        await new Promise(r => setTimeout(r, msPerChar));
      }
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      const clone = node.cloneNode(false); // Copia l'etiqueta buida
      parent.appendChild(clone);
      for (let i = 0; i < node.childNodes.length; i++) {
        await typeNode(node.childNodes[i], clone);
      }
    }
  }

  // Si l'usuari clica l'element, accelera l'escriptura (salta l'efecte)
  let saltarEfecte = false;
  el.onclick = () => { saltarEfecte = true; };

  for (let i = 0; i < temp.childNodes.length; i++) {
    if (saltarEfecte) {
      el.innerHTML = htmlContent;
      break;
    }
    await typeNode(temp.childNodes[i], el);
  }
  el.onclick = null; // Netegem l'esdeveniment
}

function toast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 3200);
}

function updateProgress(fase) {
  document.querySelectorAll('.step-pill').forEach(el => {
    const s = parseFloat(el.dataset.step);
    el.classList.remove('active', 'done');
    if (s < fase)  el.classList.add('done');
    if (s === fase) el.classList.add('active');
  });
}

function compteParaules(text) {
  return text.trim().split(/\s+/).filter(w => w.length > 0).length;
}

function netejarTabulacionsInicials(text = '') {
  if (!text) return '';
  return String(text)
    .replace(/\r\n/g, '\n')
    .replace(/^[\t \u00A0]+/gm, '');
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ESTAT GLOBAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let USER_CONFIG = null;

const ESTAT = {
  fase:             0,
  tematica:         '',
  history:          [],
  premissaTriada:   '',
  _premissaLista:   [],
  _premissaIdx:     undefined,
  estil: {
    to:          '',
    perspectiva: '',
    paraules:    1500,
    desc:        ''
  },
  _llistaProtagonistes:  [],
  _idxProtagonista:      null,
  protagonistaTriat:     '',
  _llistaLocalitzacions: [],
  _idxLocalitzacio:      null,
  localitzacioTriada:    '',
  _llistaFinals:         [],
  _idxFinal:             null,
  finalTriat:            '',
  // Escriptura per parts
  _historyBeforeEscriptura: [],
  _totalParts:              1,
  _partActual:              1,
  _partsTexts:              [],
  conteText:                '',
  // Worldbuilding
  worldbuilding:            null,
  // Elenc de personatges (fase 8)
  _elencPersonatges:        [],
  // Estils de parla (fase 9)
  _personatgesSeleccionats: [],
  estilsParla:              null,
  _perfilsPersonatges:      {},
  _matriuRelacional:        [],
  _matriuRelacionalHistorial: [],
  _arcTransitionWarnings:   [],
  _plaReescripturaPsicologica: null,
  // NovelÂ·la (fases 10-12)
  estructuraNovella:        null,
  _estructuraCapitols:      [],
  _capitolActual:           0,
  _capitols_generats:       [],
  _revisioInstruccions:     {},
  _metaCapitols:            {},
  _revisionsOpus:           {},
  _revisionsOpusFinals:     {},
  _controlArcs:             null,
  _checkpointIntermedi:     null,
  epileg:                   null,
  _epileg_generat:          '',
  // NovelÂ·la: dades de l'estructura JSON
  _arcGlobal:               '',
  _arcMoral:                null,
  _temesCentrals:           [],
  _prefiguracions:          [],
  _corbaTensio:             [],
  titol_novella:            '',
  _revisioGlobal:           null,
  _ajustosRumb:             null,
  // BÃ­blia Narrativa Persistent (sistema 1)
  bibliaNarrativa: {
    regles_mon:         [],
    llocs_importants:   [],
    objectes_clau:      [],
    fitxes_personatges: [],
    timeline:           [],
    xarxa_relacions:    [],
    fets_canonics:      []
  },
  // Trames i subtrames (sistema 2)
  trames: {
    trama_principal: null,
    subtrames:        [],
    mapa_entrellacat: []
  },
  llibreRegistre: {
    capitols:          [],
    estat_personatges: [],
    fils_oberts:       [],
    fils_tancats:      []
  },
  _escaletes: [],
  _memoriasComprimides: [],
  _snapshotsFinals: {},
  _traitsImmutablesInicialitzats: false,
  _registreEstil: { frequencies: {}, alertes: [], verbs_atribucio: {}, tancaments: [] },
  _controlLongitud: { objectiu: 3000, llindarMinim: 0.70, llindarExpansio: 0.85, historicLongituds: [], tendencia: 'estable' },
  _goldenPassage: null,
  _goldenPassageCapitol: -1,
  // NKG (Narrative Knowledge Graph) â€” v4
  _nkg: null,
  _resumCompacte: '',
  _escenes_generades: {},
  // Veu Semilla â€” v4 (fase 6)
  _veuSemilla: null,
  _manualEstil: null,
  // CapÃ­tols adaptatius (v5)
  _nombreCapitols: 12,
  _justificacioCapitols: '',
  // Models per rol (v5.1 â€” selector flexible)
  _modelDraft:      'claude-haiku-4-5-20251001',
  _modelGeneracio:  'claude-sonnet-4-6',
  _modelArquitecte: 'claude-sonnet-4-6',
  // Claus API per proveÃ¯dor (v5.1)
  _anthropicApiKey: '',
  _geminiApiKey:    '',
  _openaiApiKey:    '',
  _revisionsCodiSistema: [],
  _revisioFinalApp: null,
  _clausPromptSeguent: [],
  _alertaArquitecte: null,
  _accionsIrreversibles: [],
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIGURACIÃ“
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MODEL_DEFAULTS = {
  anthropic: { generacio: 'claude-sonnet-4-6', arquitectura: 'claude-opus-4-6' },
  openai:    { single: 'gpt-4o' },
  gemini:    { single: 'gemini-1.5-pro' }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  REGISTRE DE MODELS â€” v5.1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MODEL_REGISTRY = {
  'claude-haiku-4-5-20251001': {
    nom: 'Claude Haiku 4.5', nomCurt: 'Haiku 4.5',
    proveidor: 'anthropic',
    input_per_m: 1.00, output_per_m: 5.00,
    context_max: 200000, max_output: 4096,
    qualitat: { draft: 72, prosa: 62, arquitectura: 65, extraccio: 78 },
    velocitat: 'molt_rapida',
    notes: 'RÃ pid i barat. Bo per tasques mecÃ niques. Prosa plana.'
  },
  'claude-sonnet-4-6': {
    nom: 'Claude Sonnet 4.6', nomCurt: 'Sonnet 4.6',
    proveidor: 'anthropic',
    input_per_m: 3.00, output_per_m: 15.00,
    context_max: 1000000, max_output: 8192,
    qualitat: { draft: 82, prosa: 84, arquitectura: 86, extraccio: 88 },
    velocitat: 'rapida',
    notes: 'Millor rÃ tio qualitat/preu. Quasi Opus a 1/5 del preu. Prosa molt bona.'
  },
  'claude-opus-4-6': {
    nom: 'Claude Opus 4.6', nomCurt: 'Opus 4.6',
    proveidor: 'anthropic',
    input_per_m: 5.00, output_per_m: 25.00,
    context_max: 1000000, max_output: 8192,
    qualitat: { draft: 85, prosa: 88, arquitectura: 93, extraccio: 90 },
    velocitat: 'moderada',
    notes: 'MÃ xima intelÂ·ligÃ¨ncia. Millor per judicis literaris subtils i arquitectura complexa.'
  },
  'gemini-3-pro-preview': {
    nom: 'Gemini 3 Pro Preview', nomCurt: 'Gemini 3 Pro',
    proveidor: 'google',
    input_per_m: 2.00, output_per_m: 12.00,
    context_max: 1000000, max_output: 8192,
    qualitat: { draft: 78, prosa: 75, arquitectura: 80, extraccio: 82 },
    velocitat: 'rapida',
    notes: 'Bon raonament, context llarg. Prosa en catalÃ  menys natural que Claude.'
  },
  'gemini-3-flash-preview': {
    nom: 'Gemini 3 Flash Preview', nomCurt: 'Gemini 3 Flash',
    proveidor: 'google',
    input_per_m: 0.10, output_per_m: 0.40,
    context_max: 1000000, max_output: 8192,
    qualitat: { draft: 80, prosa: 75, arquitectura: 75, extraccio: 85 },
    velocitat: 'molt_rapida',
    notes: 'Model de nova generaciÃ³ extremadament barat i rÃ pid.'
  },
  'gpt-5.2': {
    nom: 'GPT-5.2', nomCurt: 'GPT-5.2',
    proveidor: 'openai',
    input_per_m: 1.75, output_per_m: 14.00,
    context_max: 400000, max_output: 4096,
    qualitat: { draft: 80, prosa: 78, arquitectura: 82, extraccio: 85 },
    velocitat: 'rapida',
    notes: 'Fort en raonament i codi. CatalÃ  acceptable perÃ² no natiu. Preu competitiu.'
  }
};

const ROLS_MODEL = {
  draft: {
    nom: 'Draft / ExtracciÃ³',
    descripcio: 'Esquelets narratius (Pas 1 dual-pass), extracciÃ³ fets NKG, correccions rÃ pides',
    clau_qualitat: 'draft',
    tokens_estimats: { input: 156000, output: 102000 }
  },
  generacio: {
    nom: 'GeneraciÃ³ LiterÃ ria',
    descripcio: 'ExpansiÃ³ literÃ ria (Pas 2 dual-pass), reescriptura de passatges, conte original',
    clau_qualitat: 'prosa',
    tokens_estimats: { input: 130000, output: 95000 }
  },
  arquitecte: {
    nom: 'Arquitecte / Revisor',
    descripcio: 'Estructura, escaleta, resum compacte, micro-reescriptura diagnÃ²stic, revisiÃ³ global, veu semilla',
    clau_qualitat: 'arquitectura',
    tokens_estimats: { input: 95000, output: 38000 }
  }
};

// Model hÃ­brid v5.1: llegeix de ESTAT._model* (selector flexible per rol)
function getModelConfig(userConfig) {
  // Prioritat: ESTAT._model* > userConfig.models.* > userConfig.model* > defaults
  const cfg = userConfig || {};
  const cfgModels = cfg.models || {};
  return {
    modelDraft:      ESTAT._modelDraft      || cfgModels.draft      || cfg.modelDraft      || cfg.modelHaiku      || 'claude-haiku-4-5-20251001',
    modelGeneracio:  ESTAT._modelGeneracio  || cfgModels.generacio  || cfg.modelGeneracio  || cfg.model           || 'claude-sonnet-4-6',
    modelArquitecte: ESTAT._modelArquitecte || cfgModels.arquitecte || cfg.modelArquitecte || cfg.modelArquitectura || cfg.model || 'claude-sonnet-4-6'
  };
}

// Retorna maxTokens capped al mÃ xim de sortida del model seleccionat
function capsMaxTokens(modelId, requested) {
  const reg = MODEL_REGISTRY[modelId];
  const maxOut = (reg && reg.max_output) ? reg.max_output : 4096;
  return Math.min(requested, maxOut);
}

function setModelPerRol(rol, modelId) {
  if (!MODEL_REGISTRY[modelId]) { console.warn(`Model desconegut: ${modelId}`); return; }
  switch (rol) {
    case 'draft':      ESTAT._modelDraft      = modelId; break;
    case 'generacio':  ESTAT._modelGeneracio  = modelId; break;
    case 'arquitecte': ESTAT._modelArquitecte = modelId; break;
  }
  sincronitzarCampsConfigModels();
  actualitzarEstimacio();
}

function aplicarPreset(preset) {
  const presets = {
    'economic':   { draft: 'claude-haiku-4-5-20251001', generacio: 'claude-sonnet-4-6', arquitecte: 'claude-sonnet-4-6' },
    'equilibrat': { draft: 'claude-sonnet-4-6',         generacio: 'claude-sonnet-4-6', arquitecte: 'claude-sonnet-4-6' },
    'premium':    { draft: 'claude-sonnet-4-6',         generacio: 'claude-sonnet-4-6', arquitecte: 'claude-opus-4-6'  },
    'maxim':      { draft: 'claude-sonnet-4-6',         generacio: 'claude-opus-4-6',   arquitecte: 'claude-opus-4-6'  },
    'barat_gpt':  { draft: 'gpt-5.2',                  generacio: 'gpt-5.2',           arquitecte: 'gpt-5.2'          },
    'gemini':     { draft: 'gemini-3-flash-preview',    generacio: 'gemini-3-flash-preview', arquitecte: 'gemini-3-pro-preview' }
  };
  const p = presets[preset];
  if (!p) return;
  ESTAT._modelDraft      = p.draft;
  ESTAT._modelGeneracio  = p.generacio;
  ESTAT._modelArquitecte = p.arquitecte;
  const selDraft = document.getElementById('selectModelDraft');
  const selGen   = document.getElementById('selectModelGen');
  const selArq   = document.getElementById('selectModelArq');
  if (selDraft) selDraft.value = p.draft;
  if (selGen)   selGen.value   = p.generacio;
  if (selArq)   selArq.value   = p.arquitecte;
  sincronitzarCampsConfigModels();
  actualitzarEstimacio();
}

function sincronitzarCampsConfigModels() {
  const genInput = document.getElementById('config-model-generacio');
  const arqInput = document.getElementById('config-model-arquitectura');
  if (genInput && ESTAT._modelGeneracio) genInput.value = ESTAT._modelGeneracio;
  if (arqInput && ESTAT._modelArquitecte) arqInput.value = ESTAT._modelArquitecte;
}

// Alias backward compatible
function aplicarPresetModels(preset) { aplicarPreset(preset); }

function actualitzarConfigProvider() {
  const provider = document.getElementById('config-provider').value;

  // Ara mostrem els camps de sistema dual per a TOTS els proveÃ¯dors
  document.getElementById('config-anthropic-fields').classList.remove('hidden');
  document.getElementById('config-single-model-field').classList.add('hidden');

  const genInput = document.getElementById('config-model-generacio');
  const arqInput = document.getElementById('config-model-arquitectura');
  const provGenSel = document.getElementById('config-provider-generacio');
  const provArqSel = document.getElementById('config-provider-arquitectura');

  if (provGenSel) provGenSel.value = provider;
  if (provArqSel) provArqSel.value = provider;

  const defaults = {
    anthropic: { draft: 'claude-haiku-4-5-20251001', generacio: 'claude-sonnet-4-6', arquitectura: 'claude-opus-4-6' },
    gemini:    { draft: 'gemini-3-flash-preview',    generacio: 'gemini-3-flash-preview', arquitectura: 'gemini-3-flash-preview' },
    openai:    { draft: 'gpt-5.2',                   generacio: 'gpt-4o-mini',            arquitectura: 'gpt-4o' }
  };
  const p = defaults[provider] || defaults.anthropic;

  // Quan canvia el proveÃ¯dor principal, apliquem models coherents amb aquest proveÃ¯dor.
  if (genInput) genInput.value = p.generacio;
  if (arqInput) arqInput.value = p.arquitectura;

  ESTAT._modelDraft = p.draft;
  ESTAT._modelGeneracio = p.generacio;
  ESTAT._modelArquitecte = p.arquitectura;

  const selDraft = document.getElementById('selectModelDraft');
  const selGen = document.getElementById('selectModelGen');
  const selArq = document.getElementById('selectModelArq');
  if (selDraft) selDraft.value = p.draft;
  if (selGen) selGen.value = p.generacio;
  if (selArq) selArq.value = p.arquitectura;

  sincronitzarCampsConfigModels();
  actualitzarEstimacio();
}

// MantÃ© compatibilitat si algÃº cridava l'antiga funciÃ³
function actualitzarModelDefault() { actualitzarConfigProvider(); }

function guardarIComencar() {
  try {
    const provider = document.getElementById('config-provider').value;
    if (!provider) { toast('Selecciona un proveÃ¯dor.'); return; }

    const providerGeneracio = (document.getElementById('config-provider-generacio')?.value || provider).trim();
    const providerArquitectura = (document.getElementById('config-provider-arquitectura')?.value || provider).trim();

    const anthropicKey = document.getElementById('anthropicApiKey')?.value?.trim() || '';
    const geminiKey    = document.getElementById('geminiApiKey')?.value?.trim() || '';
    const openaiKey    = document.getElementById('openaiApiKey')?.value?.trim() || '';

    const getKeyForProvider = (prov) => {
      if (prov === 'anthropic') return anthropicKey;
      if (prov === 'gemini' || prov === 'google') return geminiKey;
      if (prov === 'openai') return openaiKey;
      return '';
    };

    const providersNecessaris = Array.from(new Set([providerGeneracio, providerArquitectura]));
    const senseKey = providersNecessaris.find(p => !getKeyForProvider(p));
    if (senseKey) { toast(`Introdueix una API key per al proveÃ¯dor seleccionat (${senseKey}).`); return; }

    const apiKey = getKeyForProvider(providerGeneracio);

    if (anthropicKey) ESTAT._anthropicApiKey = anthropicKey;
    if (geminiKey)    ESTAT._geminiApiKey    = geminiKey;
    if (openaiKey)    ESTAT._openaiApiKey    = openaiKey;

    const modelGeneracioInput    = document.getElementById('config-model-generacio').value.trim();
    const modelArquitecturaInput = document.getElementById('config-model-arquitectura').value.trim();
    const fluxAutomatic     = document.getElementById('config-flux-automatic').checked;
    const targetQualitatEl  = document.getElementById('config-target-qualitat');
    const targetQualitatRaw = targetQualitatEl ? Number(targetQualitatEl.value) : 85;
    const targetQualitat    = Math.max(60, Math.min(98, Number.isFinite(targetQualitatRaw) ? targetQualitatRaw : 85));

    // Prioritzem el que l'usuari veu al panell en aquest moment (inputs/selectors),
    // per evitar arrossegar valors antics d'ESTAT d'un proveÃ¯dor diferent.
    const selectDraft = document.getElementById('selectModelDraft');
    const selectGen = document.getElementById('selectModelGen');
    const selectArq = document.getElementById('selectModelArq');

    const modelDraft = (selectDraft && selectDraft.value.trim()) || ESTAT._modelDraft || modelGeneracioInput;
    const modelGeneracio = modelGeneracioInput || (selectGen && selectGen.value.trim()) || ESTAT._modelGeneracio;
    const modelArquitectura = modelArquitecturaInput || (selectArq && selectArq.value.trim()) || ESTAT._modelArquitecte;

    if (!modelGeneracio)    { toast('Introdueix el model de generaciÃ³.'); return; }
    if (!modelArquitectura) { toast("Introdueix el model d'arquitectura."); return; }

    // Sobreescriure l'estat amb els valors finals del panell de configuraciÃ³.
    ESTAT._modelGeneracio  = modelGeneracio;
    ESTAT._modelArquitecte = modelArquitectura;
    ESTAT._modelDraft      = modelDraft;
    sincronitzarCampsConfigModels();

    const genere = document.getElementById('config-genere') ? document.getElementById('config-genere').value : '';
    const autor = document.getElementById('config-autor') ? document.getElementById('config-autor').value : '';
    const focusClimax = document.getElementById('config-focus-climax') ? document.getElementById('config-focus-climax').value : '';
    ESTAT.configProjecte = { genere, autor_referencia: autor, focus_climax: focusClimax };

    USER_CONFIG = {
      provider,
      providerGeneracio,
      providerArquitectura,
      apiKey,
      modelGeneracio,
      modelArquitectura,
      modelDraft,
      modelArquitecte: modelArquitectura,
      models: {
        draft: modelDraft,
        generacio: modelGeneracio,
        arquitecte: modelArquitectura
      },
      fluxAutomatic,
      targetQualitat
    };

    if (typeof poblarSelectorsModels === 'function') {
      poblarSelectorsModels();
    } else {
      console.warn("poblarSelectorsModels no definit; s'omet la inicialitzaciÃ³ del panell de models.");
    }

    if (typeof actualitzarModelsDisponibles === 'function') {
      actualitzarModelsDisponibles();
    }

    hideCard('card-config');
    document.getElementById('progress-wrap').classList.remove('hidden');
    showCard('fase-0');
    toast('ConfiguraciÃ³ guardada.');
  } catch (err) {
    console.error('Error guardant configuraciÃ³:', err);
    toast("No s'ha pogut guardar la configuraciÃ³. Mira la consola (F12).");
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 0 â†’ FASE 1: Premisses
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase1() {
  const sel = document.getElementById('sel-tematica').value;
  if (!sel) { toast('Selecciona primer un gÃ¨nere.'); return; }
  if (!USER_CONFIG) { toast('Primer configura el model.'); return; }

  ESTAT.tematica = sel;
  ESTAT.history  = [];
  ESTAT.fase     = 1;
  updateProgress(1);
  showCard('fase-1');
  showLoader(1);

  try {
    const res = await fase1_premisses(sel, [], USER_CONFIG);
    ESTAT.history = res.history;
    hideLoader(1);
    renderPremisses(res.response);
  } catch (err) {
    hideLoader(1);
    toast('Error: ' + err.message);
  }
}

// â”€â”€â”€ Render genÃ¨ric amb badge "Recomanat" (radio / single-select) â”€â”€â”€
function renderLlistaAmbRecomanat(text, wrapId, listaKey, idxKey, btnId) {
  const wrap  = document.getElementById(wrapId);
  const lines = text.split('\n').filter(l => /^\d+\./.test(l.trim()));
  if (lines.length === 0) {
    wrap.innerHTML = `<pre style="white-space:pre-wrap;font-size:.9rem;">${escHtml(text)}</pre>`;
    ESTAT[listaKey] = [];
    return;
  }
  const list = lines.map(l => l.replace(/^\d+\.\s*/, '').trim());
  // Guardar sense "(Recomanat)" per usar als prompts
  ESTAT[listaKey] = list.map(item => item.replace(/\s*\(Recomanat\)\s*/i, '').trim());
  ESTAT[idxKey]   = null;

  let autoIdx = null;
  wrap.innerHTML = list.map((item, i) => {
    const esRecomanat = /\(Recomanat\)/i.test(item);
    const textNet     = item.replace(/\s*\(Recomanat\)\s*/i, '').trim();
    if (esRecomanat) autoIdx = i;
    const badge = esRecomanat ? `<span class="badge-recomanat">Recomanat</span>` : '';
    return `<div class="premise-item" id="${wrapId}-item-${i}" onclick="triarItem('${wrapId}','${idxKey}',${i},this)">
      <input type="radio" name="${wrapId}-radio" id="${wrapId}-r-${i}">
      <label for="${wrapId}-r-${i}">${badge}${escHtml(textNet)}</label>
    </div>`;
  }).join('\n');

  // Auto-seleccionar el recomanat
  if (autoIdx !== null) {
    const el = document.getElementById(`${wrapId}-item-${autoIdx}`);
    if (el) {
      el.classList.add('chosen');
      el.querySelector('input').checked = true;
      ESTAT[idxKey] = autoIdx;
    }
  }
  showBtn(btnId);
}

function triarItem(wrapId, idxKey, idx, el) {
  document.querySelectorAll(`#${wrapId} .premise-item`).forEach(e => e.classList.remove('chosen'));
  el.classList.add('chosen');
  el.querySelector('input').checked = true;
  ESTAT[idxKey] = idx;
}

function renderPremisses(text) {
  renderLlistaAmbRecomanat(text, 'llista-premisses', '_premissaLista', '_premissaIdx', 'btn-fase1');
}

function triarPremissa(idx, el) { triarItem('llista-premisses', '_premissaIdx', idx, el); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 1 â†’ FASE 2: Estil (sense API)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function iniciarFase2() {
  const idx = ESTAT._premissaIdx;
  if (idx === undefined || idx === null) { toast('Tria una premissa primer.'); return; }
  ESTAT.premissaTriada = ESTAT._premissaLista[idx];
  ESTAT.fase = 2;
  updateProgress(2);
  showCard('fase-2');
}

// Pills de selecciÃ³ (estil)
function triarPill(el) {
  const group = el.dataset.group;
  document.querySelectorAll(`.opt-pill[data-group="${group}"]`).forEach(p => p.classList.remove('chosen'));
  el.classList.add('chosen');
  const val = el.dataset.val;
  if (group === 'perspectiva') ESTAT.estil.perspectiva = val;
  if (group === 'paraules')    ESTAT.estil.paraules    = parseInt(val);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 2 â†’ FASE 3: Protagonista
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase3() {
  const to          = document.getElementById('sel-to').value;
  const perspectiva = ESTAT.estil.perspectiva;
  const paraules    = ESTAT.estil.paraules;

  if (!to)          { toast('Tria el to del conte.'); return; }
  if (!perspectiva) { toast('Tria la perspectiva narrativa.'); return; }
  if (!paraules)    { toast('Tria la longitud del conte.'); return; }

  ESTAT.estil.to  = to;
  ESTAT.estil.desc = `to "${to}", ${perspectiva}, ${paraules} paraules aproximades`;

  ESTAT.fase = 3;
  updateProgress(3);
  showCard('fase-3');
  showLoader(3);

  try {
    const res = await fase3_personatges(ESTAT.premissaTriada, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    hideLoader(3);
    renderProtagonistes(res.response);
  } catch (err) {
    hideLoader(3);
    toast('Error: ' + err.message);
  }
}

function renderProtagonistes(text) {
  renderLlistaAmbRecomanat(text, 'llista-personatges', '_llistaProtagonistes', '_idxProtagonista', 'btn-fase3');
}

function triarProtagonista(idx, el) { triarItem('llista-personatges', '_idxProtagonista', idx, el); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 3 â†’ FASE 4: Localitzacions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase4() {
  const idx = ESTAT._idxProtagonista;
  if (idx === null || idx === undefined || !ESTAT._llistaProtagonistes[idx]) {
    toast('Tria un protagonista primer.');
    return;
  }
  ESTAT.protagonistaTriat = ESTAT._llistaProtagonistes[idx];
  ESTAT.fase = 4;
  updateProgress(4);
  showCard('fase-4');
  showLoader(4);

  try {
    const res = await fase_localitzacions(ESTAT.protagonistaTriat, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    hideLoader(4);
    renderLlistaAmbRecomanat(res.response, 'llista-localitzacions', '_llistaLocalitzacions', '_idxLocalitzacio', 'btn-fase4');
  } catch (err) {
    hideLoader(4);
    toast('Error: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 4 â†’ FASE 5: Finals
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase5() {
  const idx = ESTAT._idxLocalitzacio;
  if (idx === null || idx === undefined || !ESTAT._llistaLocalitzacions[idx]) {
    toast('Tria una localitzaciÃ³ primer.');
    return;
  }
  ESTAT.localitzacioTriada = ESTAT._llistaLocalitzacions[idx];
  ESTAT.fase = 5;
  updateProgress(5);
  showCard('fase-5');
  showLoader(5);

  try {
    const res = await fase4_finals(ESTAT.localitzacioTriada, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    hideLoader(5);
    renderLlistaAmbRecomanat(res.response, 'llista-finals', '_llistaFinals', '_idxFinal', 'btn-fase5');
  } catch (err) {
    hideLoader(5);
    toast('Error: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 5 â†’ FASE 6: Escriptura per parts
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function iniciarEscriptura() {
  const idx = ESTAT._idxFinal;
  if (idx === null || idx === undefined || !ESTAT._llistaFinals[idx]) {
    toast('Tria un final primer.');
    return;
  }
  ESTAT.finalTriat = ESTAT._llistaFinals[idx];

  const p = ESTAT.estil.paraules;
  ESTAT._totalParts  = p <= 600 ? 1 : p <= 1800 ? 2 : 4;
  ESTAT._partActual  = 1;
  ESTAT._partsTexts  = [];
  ESTAT._historyBeforeEscriptura = [...ESTAT.history];

  ESTAT.fase = 6;
  updateProgress(6);
  showCard('fase-6');
  hideCard('conte-wrap');
  document.getElementById('export-link-wrap').classList.add('hidden');

  escriureSeguentPart();
}

async function escriureSeguentPart() {
  const part      = ESTAT._partActual;
  const total     = ESTAT._totalParts;
  const perPart   = Math.round(ESTAT.estil.paraules / total);
  const loaderTxt = total === 1
    ? 'Escrivint el conteâ€¦'
    : `Escrivint part ${part} de ${total}â€¦`;

  showLoader(6);
  document.getElementById('loader-6-text').textContent = loaderTxt;

  try {
    const res = await escriureContePart(part, total, perPart, ESTAT.finalTriat, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    ESTAT._partsTexts.push(res.response);
    hideLoader(6);

    if (ESTAT._partActual < ESTAT._totalParts) {
      ESTAT._partActual++;
      await escriureSeguentPart();
    } else {
      const conteComplet = ESTAT._partsTexts.join('\n\n');
      ESTAT.conteText    = conteComplet;
      mostrarConte(conteComplet);
    }
  } catch (err) {
    hideLoader(6);
    toast('Error a la part ' + part + ': ' + err.message);
  }
}

function mostrarConte(text) {
  const cos  = document.getElementById('conte-cos');
  const pars = text.split(/\n\n+/).filter(p => p.trim().length > 0);
  const html = pars.map(p => `<p>${escHtml(p.trim())}</p>`).join('\n');

  const wc = compteParaules(text);
  document.getElementById('conte-wordcount').textContent = `${wc.toLocaleString('ca')} paraules`;

  showCard('conte-wrap');
  setTimeout(() => {
    document.getElementById('fase-6').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);

  // Executar efecte d'escriptura
  efecteEscripturaHTML('conte-cos', html, 5);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ACCIONS SOBRE EL CONTE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function regenerarConte() {
  if (!confirm('Vols regenerar el conte? El text actual es perdrÃ .')) return;
  ESTAT.history     = [...ESTAT._historyBeforeEscriptura];
  ESTAT._partActual = 1;
  ESTAT._partsTexts = [];
  hideCard('conte-wrap');
  escriureSeguentPart();
}

async function handleMillorarConte() {
  const instruccio = document.getElementById('millora-input').value.trim();
  if (!instruccio) { toast('Escriu una instrucciÃ³ de millora.'); return; }
  if (!ESTAT.conteText) { toast('Primer genera el conte.'); return; }

  hideCard('conte-wrap');
  showLoader(6);
  document.getElementById('loader-6-text').textContent = 'Aplicant la milloraâ€¦';

  try {
    const res = await millorarConte(instruccio, ESTAT.conteText, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history   = res.history;
    ESTAT.conteText = res.response;
    hideLoader(6);
    document.getElementById('millora-input').value = '';
    mostrarConte(res.response);
    toast('Millora aplicada.');
  } catch (err) {
    hideLoader(6);
    showCard('conte-wrap');
    toast('Error: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPORT LOCAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function exportarDoc() {
  if (!ESTAT.conteText) { toast('No hi ha cap conte per exportar.'); return; }
  const titol = ESTAT.premissaTriada
    ? ESTAT.premissaTriada.substring(0, 55) + (ESTAT.premissaTriada.length > 55 ? 'â€¦' : '')
    : 'Conte IA';

  const btn = document.querySelector('[onclick="exportarDoc()"]');
  const origText = btn ? btn.textContent : '';
  if (btn) { btn.disabled = true; btn.textContent = 'â³ Generant TXTâ€¦'; }
  try {
    await exportarADoc(titol, ESTAT.conteText);
  } catch (error) {
    toast("Error general exportant: " + error.message);
  } finally {
    if (btn) { btn.disabled = false; btn.textContent = origText; }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 6 â†’ FASE 7: Worldbuilding
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase7() {
  if (!ESTAT.conteText) { toast('Primer genera el conte.'); return; }

  ESTAT.fase = 7;
  updateProgress(7);
  showCard('fase-7');
  document.getElementById('world-selector').classList.add('hidden');
  document.getElementById('world-result-wrap').classList.add('hidden');
  showLoader(7);
  document.getElementById('loader-7-text').textContent = 'Analitzant el conte per proposar elements de mÃ³nâ€¦';

  try {
    const res = await fase7_worldbuilding(ESTAT.conteText, ESTAT.tematica, ESTAT.estil.desc, ESTAT.history, USER_CONFIG);
    ESTAT.history = res.history;
    hideLoader(7);
    renderLlistaWorldbuilding(res.response);
  } catch (err) {
    hideLoader(7);
    toast('Error: ' + err.message);
  }
}

function renderLlistaWorldbuilding(text) {
  const wrap  = document.getElementById('llista-world');
  const lines = text.split('\n').filter(l => /^\d+\./.test(l.trim()));

  if (lines.length === 0) {
    wrap.innerHTML = `<pre style="white-space:pre-wrap;font-size:.9rem;">${escHtml(text)}</pre>`;
    document.getElementById('world-selector').classList.remove('hidden');
    return;
  }

  const list = lines.map(l => l.replace(/^\d+\.\s*/, '').trim());

  wrap.innerHTML = list.map((item, i) => {
    const esRecomanat = /\(Recomanat\)/i.test(item);
    const textNet     = item.replace(/\s*\(Recomanat\)\s*/i, '').trim();
    const displayHtml = escHtml(textNet).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    const badge       = esRecomanat ? `<span class="badge-recomanat">Recomanat</span>` : '';
    const checkedAttr = esRecomanat ? 'checked' : '';
    const chosenClass = esRecomanat ? 'chosen' : '';
    return `<div class="world-item ${chosenClass}" id="world-item-${i}" data-text="${escHtml(textNet)}" onclick="toggleWorldItem(${i}, this)">
      <input type="checkbox" id="world-cb-${i}" ${checkedAttr} onclick="event.stopPropagation();" onchange="syncWorldItem(${i})">
      <label for="world-cb-${i}">${badge}${displayHtml}</label>
    </div>`;
  }).join('\n');

  document.getElementById('world-selector').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-7').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function toggleWorldItem(idx, el) {
  const cb = document.getElementById('world-cb-' + idx);
  cb.checked = !cb.checked;
  el.classList.toggle('chosen', cb.checked);
}

function syncWorldItem(idx) {
  const cb = document.getElementById('world-cb-' + idx);
  const el = document.getElementById('world-item-' + idx);
  el.classList.toggle('chosen', cb.checked);
}

async function expandirElementsSeleccionats() {
  const checkboxes = document.querySelectorAll('#llista-world input[type=checkbox]:checked');
  if (checkboxes.length === 0) { toast('Selecciona almenys un element per expandir.'); return; }

  const labels = Array.from(checkboxes).map(cb => {
    const item = document.getElementById(cb.id.replace('world-cb-', 'world-item-'));
    return item ? item.dataset.text : '';
  }).filter(t => t.length > 0);

  document.getElementById('world-selector').classList.add('hidden');
  document.getElementById('world-result-wrap').classList.add('hidden');
  showLoader(7);
  document.getElementById('loader-7-text').textContent = 'Generant la bÃ­blia de mÃ³nâ€¦';

  try {
    const res = await fase7_expandirElements(labels, ESTAT.conteText, ESTAT.tematica, ESTAT.history, USER_CONFIG);
    ESTAT.history       = res.history;
    ESTAT.worldbuilding = res.response;
    hideLoader(7);
    mostrarResultatWorldbuilding(res.response);
  } catch (err) {
    hideLoader(7);
    document.getElementById('world-selector').classList.remove('hidden');
    toast('Error: ' + err.message);
  }
}

function mostrarResultatWorldbuilding(text) {
  const cos = document.getElementById('world-result-cos');

  const blocs = text.split(/\n\n+/).filter(b => b.trim().length > 0);
  cos.innerHTML = blocs.map(bloc => {
    const linies = bloc.trim().split('\n');
    const primerLinia = linies[0] || '';
    const esTitol = /^\*\*.+\*\*/.test(primerLinia.trim());
    if (esTitol) {
      const titol = escHtml(primerLinia.trim()).replace(/\*\*(.+?)\*\*/g, '$1');
      const desc  = linies.slice(1).join('\n').trim();
      return `<div class="world-bloc">
        <div class="world-bloc-titol">${titol}</div>
        <div class="world-bloc-desc">${escHtml(desc)}</div>
      </div>`;
    }
    return `<div class="world-bloc"><div class="world-bloc-desc">${escHtml(bloc.trim())}</div></div>`;
  }).join('\n');

  document.getElementById('world-result-wrap').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-7').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function tornarASeleccioWorld() {
  document.getElementById('world-result-wrap').classList.add('hidden');
  document.getElementById('world-selector').classList.remove('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 7 â†’ FASE 8: Elenc de personatges
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase8() {
  ESTAT.fase = 8;
  updateProgress(8);
  showCard('fase-8');
  document.getElementById('elenc-selector').classList.add('hidden');
  showLoader(8);
  document.getElementById('loader-8-text').textContent = 'Proposant el cast de personatgesâ€¦';

  // Passa el worldbuilding com a context addicional si existeix
  const worldContext = ESTAT.worldbuilding
    ? '\n\nBÃ­blia de mÃ³n disponible:\n' + ESTAT.worldbuilding
    : '';

  try {
    const res = await fase8_elencPersonatges(
      ESTAT.conteText, ESTAT.protagonistaTriat, ESTAT.tematica,
      ESTAT.estil.desc, worldContext, ESTAT.history, USER_CONFIG
    );
    ESTAT.history = res.history;
    hideLoader(8);
    renderElencPersonatges(res.response);
  } catch (err) {
    hideLoader(8);
    toast('Error: ' + err.message);
  }
}

function renderElencPersonatges(text) {
  const wrap  = document.getElementById('llista-elenc');
  const lines = text
    .split('\n')
    .map(l => l.trim())
    .filter(Boolean)
    .filter(l => /^\d+[.)]\s+/.test(l) || /^[-*â€¢]\s+/.test(l) || /\bRol\s*:/i.test(l));

  if (lines.length === 0) {
    wrap.innerHTML = `<pre style="white-space:pre-wrap;font-size:.9rem;">${escHtml(text)}</pre>`;
    ESTAT._elencPersonatges = [];
    document.getElementById('elenc-selector').classList.remove('hidden');
    return;
  }

  const list = lines
    .map(l => l
      .replace(/^\d+[.)]\s*/, '')
      .replace(/^[-*â€¢]\s*/, '')
      .trim())
    .filter(Boolean)
    .slice(0, 8);
  ESTAT._elencPersonatges = list.map(item => item.replace(/\s*\(Recomanat\)\s*/i, '').trim());

  wrap.innerHTML = list.map((item, i) => {
    const esRecomanat = /\(Recomanat\)/i.test(item);
    const textNet     = item.replace(/\s*\(Recomanat\)\s*/i, '').trim();
    const displayHtml = escHtml(textNet).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    const badge       = esRecomanat ? `<span class="badge-recomanat">Recomanat</span>` : '';
    const checkedAttr = esRecomanat ? 'checked' : '';
    const chosenClass = esRecomanat ? 'chosen' : '';
    return `<div class="world-item ${chosenClass}" id="elenc-item-${i}" data-text="${escHtml(textNet)}" onclick="toggleElencItem(${i}, this)">
      <input type="checkbox" id="elenc-cb-${i}" ${checkedAttr} onclick="event.stopPropagation();" onchange="syncElencItem(${i})">
      <label for="elenc-cb-${i}">${badge}${displayHtml}</label>
    </div>`;
  }).join('\n');

  document.getElementById('elenc-selector').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-8').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function toggleElencItem(idx, el) {
  const cb = document.getElementById('elenc-cb-' + idx);
  cb.checked = !cb.checked;
  el.classList.toggle('chosen', cb.checked);
}

function syncElencItem(idx) {
  const cb = document.getElementById('elenc-cb-' + idx);
  const el = document.getElementById('elenc-item-' + idx);
  el.classList.toggle('chosen', cb.checked);
}

function extreureNomPersonatge(raw = '') {
  let txt = String(raw || '').trim();
  if (!txt) return '';
  txt = txt.replace(/^\d+[.)]\s*/, '').trim();
  txt = txt.replace(/\*\*/g, '').trim();
  const abansPipe = txt.split('|')[0] || txt;
  txt = abansPipe.trim();
  txt = txt.replace(/^[\[(]\s*/, '').replace(/[\])]\s*$/, '').trim();
  if (!txt) return '';
  return txt.split(',')[0].trim();
}

function normalitzarNomPersonatge(raw = '') {
  return String(raw || '')
    .toLowerCase()
    .normalize('NFD')
    .replace(/[Ì€-Í¯]/g, '')
    .replace(/[^a-z0-9\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function inferirEstatAnimicDesDeVeu(estilVeu = '', perfilText = '') {
  const txt = `${estilVeu || ''} ${perfilText || ''}`.toLowerCase();
  const estatsBase = ['SerÃ¨', 'NeguitÃ³s', 'Reservat', 'EsperanÃ§at', 'MelancÃ²lic', 'Irritat', 'Determinant', 'Vulnerable'];
  const seleccionarEstatDeterminista = (seed = '') => {
    const src = String(seed || '').trim();
    if (!src) return 'SerÃ¨';
    let hash = 0;
    for (let i = 0; i < src.length; i++) {
      hash = ((hash << 5) - hash + src.charCodeAt(i)) | 0;
    }
    const idx = Math.abs(hash) % estatsBase.length;
    return estatsBase[idx];
  };

  if (!txt.trim()) return seleccionarEstatDeterminista(estilVeu || perfilText || 'estat-base');
  if (/fur[iÃ­]|rabia|ira|hostil|agress|violent/.test(txt)) return 'Irritat';
  if (/por|ansi|anx|panic|p[Ã a]nic|nerv|inquiet/.test(txt)) return 'NeguitÃ³s';
  if (/trist|dol|abat|depr|melancol/.test(txt)) return 'MelancÃ²lic';
  if (/ironi|sarcas|fred|calculador|anal[iÃ­]tic/.test(txt)) return 'Reservat';
  if (/esperan[Ã§c]|optim|euf[oÃ²]r|entusias/.test(txt)) return 'EsperanÃ§at';
  if (/poetic|emocional|sensible|vulnerable/.test(txt)) return 'Sensibilitzat';
  if (/fermat|disciplina|voluntat|control|estrateg/.test(txt)) return 'Determinant';
  return seleccionarEstatDeterminista(txt);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 8 â†’ FASE 9: Estils de parla
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEstilsParla() {
  const checkboxes = document.querySelectorAll('#llista-elenc input[type=checkbox]:checked');
  if (checkboxes.length === 0) { toast('Selecciona almenys un personatge.'); return; }

  const seleccionats = Array.from(checkboxes).map(cb => {
    const item = document.getElementById(cb.id.replace('elenc-cb-', 'elenc-item-'));
    return item ? extreureNomPersonatge(item.dataset.text) : '';
  }).filter(t => t.length > 0);

  ESTAT._personatgesSeleccionats = seleccionats;
  ESTAT._perfilsPersonatges = ESTAT._perfilsPersonatges || {};
  seleccionats.forEach(nom => {
    const prev = ESTAT._perfilsPersonatges[nom] || {};
    ESTAT._perfilsPersonatges[nom] = Object.assign({}, prev, {
      nom,
      estil_veu: prev.estil_veu || '',
      perfil_psicologic: prev.perfil_psicologic || '',
      estat_animic_actual: prev.estat_animic_actual || inferirEstatAnimicDesDeVeu(prev.estil_veu, prev.perfil_psicologic)
    });
  });
  ESTAT.fase = 9;
  updateProgress(9);
  showCard('fase-9');
  document.getElementById('estils-result').classList.add('hidden');
  showLoader(9);

  try {
    const res = await fase9_estilParla(
      ESTAT.protagonistaTriat, seleccionats, ESTAT.conteText,
      ESTAT.tematica, ESTAT.estil.desc, ESTAT.history, USER_CONFIG
    );
    ESTAT.history    = res.history;
    ESTAT.estilsParla = res.response;
    hideLoader(9);
    mostrarEstilsParla(res.response);
  } catch (err) {
    hideLoader(9);
    toast('Error: ' + err.message);
  }
}


function extreureEstilsPerPersonatge(text) {
  const mapa = {};
  const src = String(text || '');
  const blocs = src.split(/\n\n+/).map(b => b.trim()).filter(Boolean);
  blocs.forEach(bloc => {
    const m = bloc.match(/^\*\*(.+?)\*\*/m);
    if (!m) return;
    const nom = m[1].trim();
    mapa[nom] = bloc;
  });
  return mapa;
}

function construirContextPsicologicPersonatges(limit = 8) {
  const perfils = ESTAT._perfilsPersonatges || {};
  const noms = ESTAT._personatgesSeleccionats || [];
  const seleccionats = noms.slice(0, limit).map(nom => {
    const p = perfils[nom] || {};
    return `- Nom: ${nom}
  Estil_veu: ${(p.estil_veu || '').substring(0, 220) || '(pendent)'}
  Perfil_psicologic: ${(p.perfil_psicologic || '').substring(0, 260) || '(pendent)'}
  Ferida_nuclear: ${(p.ferida_nuclear || '').substring(0, 180) || '(pendent)'}
  Mascara_social: ${(p.mascara_social || '').substring(0, 160) || '(pendent)'}
  Etapa_arc_intern: ${etiquetaEtapaArcIntern(p.etapa_arc_intern)}
  Estat_animic_actual: ${p.estat_animic_actual || 'Tranquil'}`;
  });
  return seleccionats.length > 0 ? seleccionats.join('\n') : '';
}

async function generarPerfilsPsicologics(userConfig) {
  const noms = (ESTAT._personatgesSeleccionats || []).filter(Boolean);
  if (noms.length === 0 || !ESTAT.estilsParla) return { personatges: [] };

  const estils = extreureEstilsPerPersonatge(ESTAT.estilsParla);
  const mapaEstilsNormalitzat = {};
  Object.keys(estils).forEach(nom => {
    const key = normalitzarNomPersonatge(extreureNomPersonatge(nom) || nom);
    if (!key || mapaEstilsNormalitzat[key]) return;
    mapaEstilsNormalitzat[key] = estils[nom];
  });

  const obtenirEstilPerNom = (nom) => {
    if (estils[nom]) return estils[nom];
    const nomNet = extreureNomPersonatge(nom);
    if (nomNet && estils[nomNet]) return estils[nomNet];
    const key = normalitzarNomPersonatge(nomNet || nom);
    return key ? (mapaEstilsNormalitzat[key] || '') : '';
  };

  const limitarParaules = (txt = '', maxParaules = 50) => {
    const net = String(txt || '').replace(/\s+/g, ' ').trim();
    if (!net) return '';
    const parts = net.split(' ');
    let out = parts.length <= maxParaules ? net : parts.slice(0, maxParaules).join(' ');
    out = out.replace(/[,:;\-â€“â€”]+$/g, '').trim();
    if (out && !/[.!?â€¦]$/.test(out)) out += '.';
    return out;
  };

  const completarAprox50Paraules = (txt = '', context = '') => {
    const base = limitarParaules(txt, 50);
    if (!base) {
      return limitarParaules(`Personatge marcat per contradiccions internes. Vol ser estimat perÃ² tem mostrar fragilitat; oscilÂ·la entre control i impuls, i converteix cada relaciÃ³ en un camp de prova emocional. Necessita reparar una pÃ¨rdua antiga per triar amb honestedat i assumir conseqÃ¼Ã¨ncies sense fugir.`, 50);
    }
    const parts = base.split(/\s+/).filter(Boolean);
    if (parts.length >= 42) return base;
    const cua = limitarParaules(`Aquesta tensiÃ³, alimentada per ${context || 'el passat no resolt'}, condiciona les seves decisions i el porta a protegir-se amb conductes defensives que, paradoxalment, agreugen el conflicte que mÃ©s vol evitar.`, Math.max(6, 50 - parts.length));
    return limitarParaules(`${base} ${cua}`, 50);
  };

  const generarEtapaPerNom = (nom = '') => {
    const etapes = ['negacio', 'resistencia', 'fractura', 'insight'];
    const net = normalitzarNomPersonatge(nom);
    if (!net) return 'resistencia';
    let hash = 0;
    for (let i = 0; i < net.length; i++) hash = ((hash << 5) - hash + net.charCodeAt(i)) | 0;
    return etapes[Math.abs(hash) % etapes.length];
  };

  const llista = noms.map((nom, i) => `${i + 1}. ${nom}
Estil de veu:
${(obtenirEstilPerNom(nom) || '(no trobat)').substring(0, 900)}`).join('\n');

  const msgs = [{
    role: 'user',
    content: `Analitza aquests personatges i genera un perfil psicolÃ²gic breu (trets de personalitat, pors, motivacions) per a cadascun.
IMPORTANT:
- "perfil_psicologic", "ferida_nuclear" i "mascara_social" han de tenir APROXIMADAMENT 50 paraules cadascun (entre 40 i 55).
- "estat_animic_actual" ha de ser variat i coherent (evita repetir "Tranquil" per defecte).
- "etapa_arc_intern" ha de reflectir la situaciÃ³ prÃ²pia de cada personatge (no posis "negacio" a tothom).
Afegeix: "ferida_nuclear", "mascara_social", "estat_animic_actual" i "etapa_arc_intern" (una de: negacio, resistencia, fractura, insight, integracio).
Retorna un JSON on cada personatge tingui aquests camps.
Es requereix l'anÃ lisi de EXACTAMENT ${noms.length} personatges.

PERSONATGES:
${llista}

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "personatges": [
    {"nom": "Nom", "perfil_psicologic": "...", "ferida_nuclear":"...", "mascara_social":"...", "estat_animic_actual":"...", "etapa_arc_intern":"negacio"}
  ]
}`
  }];

  const models = getModelConfig(userConfig || USER_CONFIG || {});
  const perfilMap = {};
  noms.forEach(n => { perfilMap[n] = { nom: n, perfil_psicologic: '', ferida_nuclear: '', mascara_social: '', etapa_arc_intern: generarEtapaPerNom(n), estat_animic_actual: inferirEstatAnimicDesDeVeu(obtenirEstilPerNom(n), '') }; });

  try {
    const systemPsico = 'Ets un psicÃ²leg narratiu. Retorna nomÃ©s JSON vÃ lid en catalÃ .';

    const aplicarPerfils = (items = [], llistaObjectiu = noms) => {
      if (!Array.isArray(items)) return;
      items.forEach(p => {
        const nom = p && p.nom ? String(p.nom).trim() : '';
        const key = normalitzarNomPersonatge(extreureNomPersonatge(nom) || nom);
        const nomOriginal = llistaObjectiu.find(n => normalitzarNomPersonatge(extreureNomPersonatge(n) || n) === key);
        if (!nomOriginal) return;
        perfilMap[nomOriginal] = {
          nom: nomOriginal,
          perfil_psicologic: completarAprox50Paraules(String(p.perfil_psicologic || '').trim(), 'la por de no ser suficient'),
          ferida_nuclear: completarAprox50Paraules(String(p.ferida_nuclear || '').trim(), 'una ferida antiga de rebuig'),
          mascara_social: completarAprox50Paraules(String(p.mascara_social || '').trim(), 'la necessitat de semblar invulnerable'),
          etapa_arc_intern: normalitzarEtapaArcIntern(p.etapa_arc_intern || generarEtapaPerNom(nomOriginal)),
          estat_animic_actual: String(p.estat_animic_actual || '').trim() || (ESTAT._perfilsPersonatges && ESTAT._perfilsPersonatges[nomOriginal] && ESTAT._perfilsPersonatges[nomOriginal].estat_animic_actual) || inferirEstatAnimicDesDeVeu(obtenirEstilPerNom(nomOriginal), String(p.perfil_psicologic || ''))
        };
      });
    };

    const generarBlocPerfils = async (blocNoms, maxTokens = 1400) => {
      if (!Array.isArray(blocNoms) || blocNoms.length === 0) return;
      const llistaBloc = blocNoms.map((nom, i) => `${i + 1}. ${nom}
Estil de veu:
${(obtenirEstilPerNom(nom) || '(no trobat)').substring(0, 900)}`).join('\n');
      const msgsBloc = [{
        role: 'user',
        content: `Analitza aquests personatges i genera un perfil psicolÃ²gic breu (trets de personalitat, pors, motivacions) per a cadascun.
IMPORTANT:
- "perfil_psicologic", "ferida_nuclear" i "mascara_social" han de tenir APROXIMADAMENT 50 paraules cadascun (entre 40 i 55).
- "estat_animic_actual" ha de ser variat i coherent (evita repetir "Tranquil" per defecte).
- "etapa_arc_intern" ha de reflectir la situaciÃ³ prÃ²pia de cada personatge (no posis "negacio" a tothom).
Afegeix tambÃ©: "ferida_nuclear", "mascara_social", "estat_animic_actual" i "etapa_arc_intern" (una de: negacio, resistencia, fractura, insight, integracio).
Retorna un JSON on cada personatge tingui aquests camps.
Es requereix l'anÃ lisi de EXACTAMENT ${blocNoms.length} personatges.

PERSONATGES:
${llistaBloc}

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "personatges": [
    {"nom": "Nom", "perfil_psicologic": "...", "ferida_nuclear":"...", "mascara_social":"...", "estat_animic_actual":"...", "etapa_arc_intern":"negacio"}
  ]
}`
      }];

      const rawBloc = await callLLMMulti(
        msgsBloc,
        systemPsico,
        Object.assign({}, userConfig || USER_CONFIG || {}, { maxTokens, model: models.modelArquitecte }),
        'arquitectura'
      );
      const dataBloc = parseJsonRobust(rawBloc);
      if (dataBloc && Array.isArray(dataBloc.personatges)) {
        aplicarPerfils(dataBloc.personatges, blocNoms);
      }
    };

    const CHUNK_PSICO = 4;
    for (let i = 0; i < noms.length; i += CHUNK_PSICO) {
      const bloc = noms.slice(i, i + CHUNK_PSICO);
      await generarBlocPerfils(bloc, 1300);
    }

    let faltants = noms.filter(nom => !(perfilMap[nom] && perfilMap[nom].perfil_psicologic));
    if (faltants.length > 0) {
      for (const nomFaltant of faltants) {
        const retryMsgs = [{
          role: 'user',
          content: `Genera el perfil psicolÃ²gic d'aquest Ãºnic personatge.
"perfil_psicologic", "ferida_nuclear" i "mascara_social" han de tenir aproximadament 50 paraules (40-55).
Proposa tambÃ© "estat_animic_actual" variat i "etapa_arc_intern" no genÃ¨rica.

PERSONATGE:
- ${nomFaltant}
Estil de veu:
${(obtenirEstilPerNom(nomFaltant) || '(no trobat)').substring(0, 900)}

Retorna EXCLUSIVAMENT JSON:
{
  "personatges": [
    {"nom": "${nomFaltant}", "perfil_psicologic": "...", "ferida_nuclear":"...", "mascara_social":"...", "estat_animic_actual":"...", "etapa_arc_intern":"negacio"}
  ]
}`
        }];

        const rawRetry = await callLLMMulti(
          retryMsgs,
          systemPsico,
          Object.assign({}, userConfig || USER_CONFIG || {}, { maxTokens: 700, model: models.modelArquitecte }),
          'arquitectura'
        );
        const retryData = parseJsonRobust(rawRetry);
        if (retryData && Array.isArray(retryData.personatges)) {
          aplicarPerfils(retryData.personatges, [nomFaltant]);
        }
      }
    }
  } catch (err) {
    console.warn('Perfils psicolÃ²gics: no bloquejant:', err.message);
  }

  ESTAT._perfilsPersonatges = ESTAT._perfilsPersonatges || {};
  const etapesDisponibles = ['negacio', 'resistencia', 'fractura', 'insight', 'integracio'];
  const etapesActuals = noms.map(n => normalitzarEtapaArcIntern((perfilMap[n] || {}).etapa_arc_intern));
  const totNegacio = etapesActuals.every(e => e === 'negacio');

  noms.forEach(nom => {
    const prev = ESTAT._perfilsPersonatges[nom] || {};
    const nou = perfilMap[nom] || { nom, perfil_psicologic: '', ferida_nuclear: '', mascara_social: '', etapa_arc_intern: 'negacio', estat_animic_actual: '' };
    const etapaDiversa = totNegacio ? etapesDisponibles[Math.abs(nom.length) % etapesDisponibles.length] : normalitzarEtapaArcIntern(nou.etapa_arc_intern || prev.etapa_arc_intern || generarEtapaPerNom(nom));
    ESTAT._perfilsPersonatges[nom] = Object.assign({}, prev, {
      nom,
      estil_veu: prev.estil_veu || (estils[nom] || ''),
      perfil_psicologic: completarAprox50Paraules(
        nou.perfil_psicologic || prev.perfil_psicologic || `Personatge amb conflicte intern marcat; combina desig de control amb por a la pÃ¨rdua, i pren decisions defensives que tensionen les relacions.`,
        'la contradicciÃ³ entre desig i autoprotecciÃ³'
      ),
      ferida_nuclear: completarAprox50Paraules(nou.ferida_nuclear || prev.ferida_nuclear || '', 'una humiliaciÃ³ o pÃ¨rdua fundacional'),
      mascara_social: completarAprox50Paraules(nou.mascara_social || prev.mascara_social || '', 'l intenciÃ³ d aparentar fortalesa'),
      etapa_arc_intern: etapaDiversa,
      estat_animic_actual: String(nou.estat_animic_actual || '').trim() || prev.estat_animic_actual || inferirEstatAnimicDesDeVeu(prev.estil_veu || obtenirEstilPerNom(nom), nou.perfil_psicologic || prev.perfil_psicologic)
    });
  });

  return { personatges: noms.map(n => ESTAT._perfilsPersonatges[n]) };
}

async function actualitzarEstatsAnimics(textCapitol, idx, userConfig) {
  const cap = ESTAT._estructuraCapitols && ESTAT._estructuraCapitols[idx] ? ESTAT._estructuraCapitols[idx] : null;
  const presents = cap && Array.isArray(cap.personatges) ? cap.personatges.filter(Boolean) : [];
  if (presents.length === 0) return;

  ESTAT._perfilsPersonatges = ESTAT._perfilsPersonatges || {};
  const estatAnterior = presents.map(nom => {
    const p = ESTAT._perfilsPersonatges[nom] || {};
    return `- ${nom}: ${p.estat_animic_actual || 'Tranquil'}`;
  }).join('\n');

  const resum = resumAutomaticCapitol(textCapitol || '').substring(0, 900);
  const resumPerArc = resumAutomaticCapitol(textCapitol || '').substring(0, 1200);
  const msgs = [{
    role: 'user',
    content: `Llegeix el resum d'aquest capÃ­tol i l'estat anÃ­mic anterior dels personatges. Com han afectat els esdeveniments d'aquest capÃ­tol a la psicologia de cadascun? Retorna un JSON amb l'"estat_animic_actual" actualitzat (ex: "Enfurismat", "Deprimit", "Ple d'esperanÃ§a") per a cada personatge que hagi aparegut.

RESUM CAPÃTOL ${idx + 1}:
${resum}

ESTAT ANÃMIC ANTERIOR:
${estatAnterior}

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "personatges": [
    {"nom": "Nom", "estat_animic_actual": "..."}
  ]
}`
  }];

  try {
    const models = getModelConfig(userConfig || USER_CONFIG || {});
    const raw = await callLLMMulti(
      msgs,
      'Ets un analista de continuÃ¯tat emocional narrativa. Retorna nomÃ©s JSON vÃ lid en catalÃ .',
      Object.assign({}, userConfig || USER_CONFIG || {}, { maxTokens: 900, model: models.modelDraft, _esDraft: true }),
      'generacio'
    );
    const data = parseJsonRobust(raw);
    if (!data || !Array.isArray(data.personatges)) return;

    data.personatges.forEach(p => {
      if (!p || !p.nom) return;
      const nom = String(p.nom).trim();
      const prev = ESTAT._perfilsPersonatges[nom] || { nom, estil_veu: '', perfil_psicologic: '', estat_animic_actual: 'Tranquil' };
      const etapaInferida = inferirEtapaArcDesDeResum(resumPerArc, prev.etapa_arc_intern || 'negacio');
      const etapaValidada = validarIRegistrarTransicioArc(nom, prev.etapa_arc_intern || 'negacio', etapaInferida, `Cap.${idx + 1}`);
      ESTAT._perfilsPersonatges[nom] = Object.assign({}, prev, {
        estat_animic_actual: String(p.estat_animic_actual || '').trim() || prev.estat_animic_actual || 'Tranquil',
        etapa_arc_intern: etapaValidada
      });
    });
  } catch (err) {
    console.warn('Estats anÃ­mics: no bloquejant:', err.message);
  }

  if (Array.isArray(ESTAT._matriuRelacional) && ESTAT._matriuRelacional.length > 0) {
    ESTAT._matriuRelacional = actualitzarMatriuRelacionalDesDeRegistre(ESTAT._matriuRelacional);
  }
}

async function iniciarFasePsicologia() {
  ESTAT.fase = 9.2;
  updateProgress(9.2);
  hideCard('fase-9');
  showCard('fase-9-2');
  document.getElementById('psicologia-result').classList.add('hidden');
  showLoader('9-2');

  try {
    const dades = await generarPerfilsPsicologics(USER_CONFIG);
    hideLoader('9-2');
    mostrarPerfilsPsicologics(dades);
  } catch (err) {
    hideLoader('9-2');
    toast("Error en l'anÃ lisi psicolÃ²gica: " + err.message);
  }
}

function mostrarPerfilsPsicologics(dades) {
  const cos = document.getElementById('psicologia-cos');
  const perfils = dades && Array.isArray(dades.personatges)
    ? dades.personatges
    : Object.values(ESTAT._perfilsPersonatges || {});

  cos.innerHTML = perfils.map(p => {
    const nom = escHtml(String(p.nom || 'Personatge').trim());
    const perfil = escHtml(String(p.perfil_psicologic || '(pendent)').trim());
    const anim = escHtml(String(p.estat_animic_actual || 'Tranquil').trim());
    return `<div class="veu-card">
      <div class="veu-card-nom">ğŸ‘¤ ${nom}</div>
      <div class="veu-card-camps">
        <div><div class="veu-camp-label">Perfil psicolÃ²gic</div><div class="veu-camp-val">${perfil}</div></div>
        <div><div class="veu-camp-label">Estat anÃ­mic actual</div><div class="veu-camp-val">${anim}</div></div>
      </div>
    </div>`;
  }).join('\n');

  document.getElementById('psicologia-result').classList.remove('hidden');
  setTimeout(() => document.getElementById('fase-9-2').scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
}

function normalitzarEtapaArcIntern(v) {
  const raw = String(v || '').toLowerCase().trim();
  const map = {
    'negacio': 'negacio',
    'negaciÃ³': 'negacio',
    'resistencia': 'resistencia',
    'resistÃ¨ncia': 'resistencia',
    'fractura': 'fractura',
    'insight': 'insight',
    'integracio': 'integracio',
    'integraciÃ³': 'integracio'
  };
  return map[raw] || 'negacio';
}

function etiquetaEtapaArcIntern(v) {
  const k = normalitzarEtapaArcIntern(v);
  const labels = {
    negacio: 'NegaciÃ³',
    resistencia: 'ResistÃ¨ncia',
    fractura: 'Fractura',
    insight: 'Insight',
    integracio: 'IntegraciÃ³'
  };
  return labels[k] || 'NegaciÃ³';
}


function potTransicioArcIntern(etapaAnterior, etapaNova) {
  const a = normalitzarEtapaArcIntern(etapaAnterior);
  const b = normalitzarEtapaArcIntern(etapaNova);
  const allowed = {
    negacio: ['negacio', 'resistencia'],
    resistencia: ['resistencia', 'fractura', 'negacio'],
    fractura: ['fractura', 'insight', 'resistencia'],
    insight: ['insight', 'integracio', 'fractura'],
    integracio: ['integracio', 'insight']
  };
  return !!(allowed[a] && allowed[a].includes(b));
}

function validarIRegistrarTransicioArc(nom, etapaAnterior, etapaNova, contextCapitol = '') {
  const a = normalitzarEtapaArcIntern(etapaAnterior);
  const b = normalitzarEtapaArcIntern(etapaNova);
  if (potTransicioArcIntern(a, b)) return b;
  const fallback = a;
  ESTAT._arcTransitionWarnings = ESTAT._arcTransitionWarnings || [];
  ESTAT._arcTransitionWarnings.push({
    nom,
    etapa_anterior: a,
    etapa_proposada: b,
    etapa_aplicada: fallback,
    context: String(contextCapitol || '').slice(0, 220)
  });
  return fallback;
}

function inferirEtapaArcDesDeResum(resum = '', etapaActual = 'negacio') {
  const txt = String(resum || '').toLowerCase();
  const actual = normalitzarEtapaArcIntern(etapaActual);
  if (/accepta|integra|reconcilia|perdona|fa\s+les\s+pau/.test(txt)) return 'integracio';
  if (/admet|ent[eÃ©]n|compr[eÃ¨]n|insight|revela\s+la\s+veritat/.test(txt)) return 'insight';
  if (/trenca|col.lapse|colÂ·lapse|crisi|desbord|p[Ã a]nic/.test(txt)) return 'fractura';
  if (/resisteix|evita|nega|fug|bloqueja|es\s+tanca/.test(txt)) return actual === 'negacio' ? 'resistencia' : actual;
  return actual;
}

function mostrarFeridaArc(dades) {
  const cos = document.getElementById('ferida-arc-cos');
  const perfils = dades && Array.isArray(dades.personatges)
    ? dades.personatges
    : Object.values(ESTAT._perfilsPersonatges || {});

  cos.innerHTML = perfils.map(p => {
    const nom = escHtml(String(p.nom || 'Personatge').trim());
    const ferida = escHtml(String(p.ferida_nuclear || '(pendent)').trim());
    const mascara = escHtml(String(p.mascara_social || '(pendent)').trim());
    const etapa = escHtml(etiquetaEtapaArcIntern(p.etapa_arc_intern));
    return `<div class="veu-card">
      <div class="veu-card-nom">ğŸ‘¤ ${nom}</div>
      <div class="veu-card-camps">
        <div><div class="veu-camp-label">Ferida nuclear</div><div class="veu-camp-val">${ferida}</div></div>
        <div><div class="veu-camp-label">MÃ scara social</div><div class="veu-camp-val">${mascara}</div></div>
        <div><div class="veu-camp-label">Etapa arc intern</div><div class="veu-camp-val">${etapa}</div></div>
      </div>
    </div>`;
  }).join('\n');

  document.getElementById('ferida-arc-result').classList.remove('hidden');
}

async function iniciarFaseFeridaArc() {
  ESTAT.fase = 9.3;
  updateProgress(9.3);
  hideCard('fase-9-2');
  showCard('fase-9-3');
  document.getElementById('ferida-arc-result').classList.add('hidden');
  showLoader('9-3');
  try {
    const dades = await generarPerfilsPsicologics(USER_CONFIG);
    hideLoader('9-3');
    mostrarFeridaArc(dades);
  } catch (err) {
    hideLoader('9-3');
    toast('Error en definir ferida/arc: ' + err.message);
  }
}

function hashDeterminista(txt = '') {
  const src = String(txt || '');
  let hash = 0;
  for (let i = 0; i < src.length; i++) hash = ((hash << 5) - hash + src.charCodeAt(i)) | 0;
  return Math.abs(hash);
}

function scoreRelacioPerEtiqueta(textBase = '', seed = '') {
  const txt = String(textBase || '').toLowerCase();
  let score = 50;
  if (/estima|cura|admir|lleial|confia|protegeix/.test(txt)) score += 18;
  if (/por|desconf|rival|gelos|odi|ressent|venjan[Ã§c]a/.test(txt)) score -= 22;
  if (/culpa|vergonya|depend[eÃ¨]ncia|obsessi[oÃ³]/.test(txt)) score -= 8;
  const variacio = (hashDeterminista(seed || txt) % 17) - 8;
  return Math.max(5, Math.min(95, score + variacio));
}

function estimarTipusRelacio(score, seed = '') {
  const taula = score >= 66
    ? ['vincle protector', 'complicitat intensa', 'alianÃ§a frÃ gil', 'lleialtat incÃ²moda']
    : (score <= 38
      ? ['rivalitat oberta', 'tensiÃ³ soterrada', 'hostilitat continguda', 'dependÃ¨ncia conflictiva']
      : ['ambivalÃ¨ncia magnÃ¨tica', 'interdependÃ¨ncia inestable', 'equilibri tens', 'proximitat desconfiada']);
  return taula[hashDeterminista(`${seed}|${score}`) % taula.length];
}

function actualitzarMatriuRelacionalDesDeRegistre(matriuBase = []) {
  const map = new Map((matriuBase || []).map(r => [r.parella, Object.assign({}, r)]));
  const caps = (ESTAT.llibreRegistre && Array.isArray(ESTAT.llibreRegistre.capitols)) ? ESTAT.llibreRegistre.capitols : [];

  caps.forEach(cap => {
    if (!cap) return;
    const text = String((cap.resum_capitol || cap.resum || '')).toLowerCase();
    const noms = Array.isArray(cap.personatges_presents) ? cap.personatges_presents.filter(Boolean) : [];
    for (let i = 0; i < noms.length; i++) {
      for (let j = i + 1; j < noms.length; j++) {
        const parella = `${noms[i]} â†” ${noms[j]}`;
        const actual = map.get(parella) || { parella, tipus: 'ambivalencia', intensitat: 50, tendencia: 'estable', nota: '' };
        const delta = /discuteix|enfront|tra[iÃ¯]ci[oÃ³]|amena[Ã§c]|trenca/.test(text)
          ? -8
          : (/ajuda|salva|confessa|repara|abra[Ã§c]a/.test(text) ? 7 : 0);
        const nova = Math.max(5, Math.min(95, (Number(actual.intensitat) || 50) + delta));
        actual.intensitat = nova;
        actual.tipus = estimarTipusRelacio(nova, `${parella}|${text}`);
        actual.tendencia = delta > 0 ? 'millorant' : (delta < 0 ? 'empitjorant' : (actual.tendencia || 'inestable'));
        if (delta !== 0) actual.nota = `Ajustat pel registre de capÃ­tols (${delta > 0 ? '+' : ''}${delta}).`;
        map.set(parella, actual);
      }
    }
  });

  const resultat = Array.from(map.values()).sort((a, b) => (b.intensitat || 0) - (a.intensitat || 0));
  ESTAT._matriuRelacionalHistorial = ESTAT._matriuRelacionalHistorial || [];
  ESTAT._matriuRelacionalHistorial.push({ t: Date.now(), total: resultat.length });
  return resultat;
}

function generarMatriuRelacionalLocal() {
  const noms = (ESTAT._personatgesSeleccionats || []).filter(Boolean);
  const perf = ESTAT._perfilsPersonatges || {};
  const matriu = [];
  for (let i = 0; i < noms.length; i++) {
    for (let j = i + 1; j < noms.length; j++) {
      const a = noms[i], b = noms[j];
      const pa = perf[a] || {}, pb = perf[b] || {};
      const textBase = `${pa.perfil_psicologic || ''} ${pb.perfil_psicologic || ''} ${pa.ferida_nuclear || ''} ${pb.ferida_nuclear || ''}`;
      const seedRelacio = `${a}|${b}|${pa.etapa_arc_intern || ''}|${pb.etapa_arc_intern || ''}|${pa.estat_animic_actual || ''}|${pb.estat_animic_actual || ''}`;
      const intensitat = scoreRelacioPerEtiqueta(textBase, seedRelacio);
      const tipus = estimarTipusRelacio(intensitat, seedRelacio);
      const tendenciaBase = (hashDeterminista(seedRelacio) % 3 === 0) ? 'inestable' : ((hashDeterminista(seedRelacio) % 2 === 0) ? 'millorant' : 'empitjorant');
      matriu.push({
        parella: `${a} â†” ${b}`,
        tipus,
        intensitat,
        tendencia: tendenciaBase,
        nota: `${a} projecta "${(pa.mascara_social || 'reserva')}", mentre ${b} respon des de "${(pb.mascara_social || 'control')}"; la fricciÃ³ entre ${(pa.estat_animic_actual || 'contenciÃ³')} i ${(pb.estat_animic_actual || 'alerta')} modula la dinÃ mica.`
      });
    }
  }
  return actualitzarMatriuRelacionalDesDeRegistre(matriu);
}

function mostrarMatriuRelacional(matriu) {
  const cos = document.getElementById('relacions-cos');
  const files = Array.isArray(matriu) ? matriu : [];
  cos.innerHTML = files.map(r => `<div class="veu-card">
    <div class="veu-card-nom">ğŸ”— ${escHtml(r.parella || 'Parella')}</div>
    <div class="veu-card-camps">
      <div><div class="veu-camp-label">DinÃ mica</div><div class="veu-camp-val">${escHtml(r.tipus || 'ambivalencia')}</div></div>
      <div><div class="veu-camp-label">Intensitat</div><div class="veu-camp-val">${escHtml(String(r.intensitat || 0))}/100 (${escHtml(r.tendencia || 'estable')})</div></div>
      <div><div class="veu-camp-label">Subtext relacional</div><div class="veu-camp-val">${escHtml(r.nota || '')}</div></div>
    </div>
  </div>`).join('\n');
  document.getElementById('relacions-result').classList.remove('hidden');
}

async function iniciarFaseRelacions() {
  ESTAT.fase = 9.4;
  updateProgress(9.4);
  hideCard('fase-9-3');
  showCard('fase-9-4');
  document.getElementById('relacions-result').classList.add('hidden');
  showLoader('9-4');
  try {
    ESTAT._matriuRelacional = generarMatriuRelacionalLocal();
    hideLoader('9-4');
    mostrarMatriuRelacional(ESTAT._matriuRelacional);
    toast('Matriu relacional actualitzada amb memÃ²ria de capÃ­tols.');
  } catch (err) {
    hideLoader('9-4');
    toast('Error en matriu relacional: ' + err.message);
  }
}

function mostrarEstilsParla(text) {
  const cos = document.getElementById('estils-cos');

  // Partir el text en blocs per personatge (cada bloc comenÃ§a amb **Nom**)
  const lines  = text.split('\n');
  const cards  = [];
  let current  = [];

  for (const line of lines) {
    if (/^\*\*.+\*\*\s*$/.test(line.trim()) && current.length > 0) {
      cards.push(current);
      current = [line];
    } else {
      current.push(line);
    }
  }
  if (current.length > 0) cards.push(current);

  cos.innerHTML = cards.map(cardLines => {
    const nomLine = cardLines[0] || '';
    const nom     = escHtml(nomLine.trim().replace(/\*\*/g, ''));

    const campsHtml = cardLines.slice(1).map(line => {
      const l = line.trim();
      if (!l) return '';

      const match = l.match(/^([^:]+):\s*(.+)$/);
      if (match) {
        const label = escHtml(match[1].trim());
        const val   = escHtml(match[2].trim());
        if (/exemple/i.test(label)) {
          return `<div>
            <div class="veu-camp-label">${label}</div>
            <div class="veu-exemple">${val}</div>
          </div>`;
        }
        return `<div>
          <div class="veu-camp-label">${label}</div>
          <div class="veu-camp-val">${val}</div>
        </div>`;
      }
      return `<div class="veu-camp-val">${escHtml(l)}</div>`;
    }).filter(h => h).join('\n');

    return `<div class="veu-card">
      <div class="veu-card-nom">ğŸ‘¤ ${nom}</div>
      <div class="veu-card-camps">${campsHtml}</div>
    </div>`;
  }).join('\n');

  document.getElementById('estils-result').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-9').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function tornarAElenc() {
  document.getElementById('estils-result').classList.add('hidden');
  hideLoader(9);
  document.getElementById('fase-8').scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10: Estructura de la novelÂ·la (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase10() {
  ESTAT.fase = 10;
  updateProgress(10);
  showCard('fase-10');
  document.getElementById('estructura-wrap').classList.add('hidden');
  showLoader(10);
  document.getElementById('loader-10-text').textContent = 'ğŸ”µ Opus creant la bÃ­blia narrativaâ€¦';

  try {
    // Primer: crear la bÃ­blia narrativa inicial
    await inicialitzarBiblia(USER_CONFIG);

    // Validar que la bÃ­blia tÃ© fitxes per a tots els personatges
    const persEsperats = (ESTAT._personatgesSeleccionats || []).length;
    const persRebuts = (ESTAT.bibliaNarrativa.fitxes_personatges || []).length;
    if (persEsperats > 0 && persRebuts < persEsperats) {
      console.warn(`BÃ­blia incompleta: ${persRebuts}/${persEsperats} personatges. Completant...`);
      document.getElementById('loader-10-text').textContent = 'ğŸ”µ Completant fitxes de personatgesâ€¦';
      try {
        await completarBibliaPersonatges(USER_CONFIG);
      } catch (retryErr) {
        console.warn('Retry bÃ­blia personatges: ' + retryErr.message);
      }
    }

    // DesprÃ©s: generar l'estructura
    document.getElementById('loader-10-text').textContent = 'ğŸ”µ Opus dissenyant l\'estructuraâ€¦';
    const res = await generarEstructuraNovella(USER_CONFIG);
    ESTAT.estructuraNovella   = res.response;
    ESTAT._estructuraCapitols = parseEstructura(res.response);

    // Retry: si falten capÃ­tols, completar-los amb una segona crida
    const capsEsperats = ESTAT._nombreCapitols || 12;
    if (ESTAT._estructuraCapitols.length > 0 && ESTAT._estructuraCapitols.length < capsEsperats) {
      console.warn(`Estructura incompleta: ${ESTAT._estructuraCapitols.length}/${capsEsperats} capÃ­tols. Completant...`);
      document.getElementById('loader-10-text').textContent = `ğŸ”µ Completant capÃ­tols ${ESTAT._estructuraCapitols.length + 1}-${capsEsperats}â€¦`;
      try {
        const completRes = await completarEstructuraCapitols(ESTAT._estructuraCapitols, capsEsperats, USER_CONFIG);
        const completDades = parseJsonRobust(completRes.response);
        if (completDades && Array.isArray(completDades.capitols) && completDades.capitols.length > 0) {
          const nousCapitols = completDades.capitols.map(cap => ({
            numero:                 cap.numero,
            titol:                  cap.titol,
            text:                   JSON.stringify(cap),
            personatges:            cap.personatges || [],
            fil:                    cap.fil_principal || '',
            toRitme:                cap.to_ritme || '',
            prefiguracionsPlantar:  cap.prefiguracions_a_plantar || [],
            prefiguracionsRecollir: cap.prefiguracions_a_recollir || [],
            resum:                  cap.resum || '',
            connexioAnterior:       cap.connexio_anterior || '',
            connexioSeguent:        cap.connexio_seguent || ''
          }));
          ESTAT._estructuraCapitols = ESTAT._estructuraCapitols.concat(nousCapitols);
          ESTAT._nombreCapitols = ESTAT._estructuraCapitols.length;
          console.log(`Estructura completada: ${ESTAT._estructuraCapitols.length} capÃ­tols`);
        }
      } catch (retryErr) {
        console.warn('Retry estructura: ' + retryErr.message);
      }
    }

    hideLoader(10);
    mostrarEstructura(res.response);
    // Mostrar estimaciÃ³ de cost a la consola i al toast
    try {
      const estimacio = mostrarEstimacioCost();
      console.log('ğŸ“Š ESTIMACIÃ“ DE COST:\n' + estimacio);
      const costEl = document.getElementById('estimacio-cost');
      if (costEl) costEl.textContent = estimacio;
    } catch (e) { /* no bloquejant */ }
  } catch (err) {
    hideLoader(10);
    toast('Error Opus: ' + err.message);
  }
}

// Fallback: parser antic basat en regex (per si la resposta no Ã©s JSON)
function parseEstructuraLegacy(text) {
  if (!text) return [];
  const chapters = [];
  const capPattern = /(?:\*\*|#{1,3}\s*)(?:[Cc]apÃ­tol|[Cc]apitol|[Cc]ap\.?)\s+(\d+)(?::\s*(.+?))?\*{0,2}\s*\n([\s\S]*?)(?=(?:\*\*|#{1,3}\s*)(?:[Cc]apÃ­tol|[Cc]apitol|[Cc]ap\.?)\s+\d+|$)/g;
  let match;
  while ((match = capPattern.exec(text)) !== null) {
    const numero = parseInt(match[1]);
    const titol  = (match[2] || 'CapÃ­tol ' + numero).trim().replace(/\*+$/, '');
    const cos    = (match[3] || '').trim();
    chapters.push({ numero, titol, text: `**CapÃ­tol ${numero}: ${titol}**\n${cos}` });
  }
  if (chapters.length === 0) {
    const parts = text.split(/(?=(?:[Cc]apÃ­tol|[Cc]apitol)\s+\d+)/);
    parts.forEach(part => {
      const m = part.match(/(?:[Cc]apÃ­tol|[Cc]apitol)\s+(\d+)(?::\s*(.+))?/);
      if (m) chapters.push({ numero: parseInt(m[1]), titol: (m[2] || 'CapÃ­tol ' + m[1]).trim(), text: part.trim() });
    });
  }
  chapters.sort((a, b) => a.numero - b.numero);
  return chapters;
}

function parseEstructura(text) {
  if (!text) return [];

  // Intent 1: JSON robust
  const data = parseJsonRobust(text);
  if (data && Array.isArray(data.capitols)) {
    // Desar dades globals a ESTAT
    ESTAT._arcGlobal      = data.arc_global || '';
    ESTAT._temesCentrals  = data.temes_centrals || [];
    ESTAT._prefiguracions = data.prefiguracions || [];
    ESTAT._corbaTensio    = data.corba_tensio || [];
    ESTAT._arcMoral       = data.arc_moral || null;

    // ValidaciÃ³ de lÃ­mits 12-22 capÃ­tols
    if (data.capitols.length > 22) {
      console.warn(`Estructura amb ${data.capitols.length} capÃ­tols â€” retallant a 22`);
      while (data.capitols.length > 22) {
        const ultim = data.capitols.pop();
        const penultim = data.capitols[data.capitols.length - 1];
        penultim.resum = (penultim.resum || '') + ' ' + (ultim.resum || '');
        penultim.personatges = [...new Set([...(penultim.personatges || []), ...(ultim.personatges || [])])];
        penultim.numero = data.capitols.length;
      }
    }
    if (data.capitols.length < 12) {
      console.warn(`Estructura amb ${data.capitols.length} capÃ­tols â€” massa pocs, perÃ² continuem`);
    }

    // Guardar el nombre real de capÃ­tols i la justificaciÃ³
    ESTAT._nombreCapitols = data.capitols.length;
    ESTAT._justificacioCapitols = data.justificacio_capitols || '';

    return data.capitols.map(cap => ({
      numero:                cap.numero,
      titol:                 cap.titol,
      text:                  JSON.stringify(cap),
      personatges:           cap.personatges || [],
      fil:                   cap.fil_principal || '',
      toRitme:               cap.to_ritme || '',
      prefiguracionsPlantar: cap.prefiguracions_a_plantar || [],
      prefiguracionsRecollir:cap.prefiguracions_a_recollir || [],
      resum:                 cap.resum || '',
      connexioAnterior:      cap.connexio_anterior || '',
      connexioSeguent:       cap.connexio_seguent || ''
    }));
  }

  // Fallback: parser basat en regex
  return parseEstructuraLegacy(text);
}

function mostrarEstructura(text) {
  const cos = document.getElementById('estructura-cos');

  // Si tenim dades JSON estructurades, renderitzem de forma rica
  if (ESTAT._arcGlobal || ESTAT._corbaTensio.length > 0) {
    let html = '';

    // Arc global
    if (ESTAT._arcGlobal) {
      html += `<div class="world-bloc">
        <div class="world-bloc-titol">ğŸŒ Arc Global</div>
        <div class="world-bloc-desc">${escHtml(ESTAT._arcGlobal)}</div>
      </div>`;
    }

    // Corba de tensiÃ³ visual
    if (ESTAT._corbaTensio.length > 0) {
      const barres = ['â–','â–‚','â–ƒ','â–„','â–…','â–†','â–‡','â–ˆ'];
      const visualCorba = ESTAT._corbaTensio.map(t => {
        const nivell = Math.min(10, Math.max(1, t.nivell || 1));
        const bar    = barres[Math.floor((nivell - 1) / 10 * barres.length)] || 'â–„';
        return `<span title="Cap.${t.capitol}: ${t.tipus || ''} (${nivell}/10)">${bar}</span>`;
      }).join('\n');
      html += `<div class="world-bloc">
        <div class="world-bloc-titol">ğŸ“ˆ Corba de TensiÃ³</div>
        <div style="font-size:1.4rem;letter-spacing:2px;color:var(--accent2);margin:6px 0;">${visualCorba}</div>
        <div style="font-size:.75rem;color:var(--text2);">${ESTAT._corbaTensio.map(t => `C${t.capitol}:${t.nivell}`).join(' Â· ')}</div>
      </div>`;
    }

    // Prefiguracions
    if (ESTAT._prefiguracions.length > 0) {
      html += `<div class="world-bloc">
        <div class="world-bloc-titol">ğŸŒ± Prefiguracions planificades</div>
        <div class="world-bloc-desc">
          ${ESTAT._prefiguracions.map(p =>
            `<div style="padding:4px 0;border-bottom:1px solid var(--border);font-size:.85rem;">
              <span style="color:var(--accent2);">Cap.${p.plantada_capitol}â†’${p.resolucio_capitol}:</span> ${escHtml(p.element || '')}
            </div>`
          ).join('\n')}
        </div>
      </div>`;
    }

    // CapÃ­tols
    if (ESTAT._estructuraCapitols.length > 0) {
      html += `<div class="world-bloc"><div class="world-bloc-titol">ğŸ“š CapÃ­tols</div></div>`;
      html += ESTAT._estructuraCapitols.map(cap => {
        let detall = '';
        if (cap.resum)    detall += `<div style="margin-bottom:4px;">${escHtml(cap.resum)}</div>`;
        if (cap.fil)      detall += `<div style="font-size:.8rem;color:var(--text2);">Fil: ${escHtml(cap.fil)}</div>`;
        if (cap.toRitme)  detall += `<div style="font-size:.8rem;color:var(--text2);">To: ${escHtml(cap.toRitme)}</div>`;
        if (cap.personatges && cap.personatges.length > 0)
          detall += `<div style="font-size:.8rem;color:var(--text2);">Personatges: ${escHtml(cap.personatges.join(', '))}</div>`;
        return `<div class="world-bloc" style="border-left:3px solid var(--accent);padding-left:12px;">
          <div class="world-bloc-titol">CapÃ­tol ${cap.numero}: ${escHtml(cap.titol || '')}</div>
          <div class="world-bloc-desc">${detall}</div>
        </div>`;
      }).join('\n');
    }

    cos.innerHTML = html;
  } else {
    // RenderitzaciÃ³ text pla (legacy)
    const blocs = text.split(/\n\n+/).filter(b => b.trim().length > 0);
    cos.innerHTML = blocs.map(bloc => {
      const linies  = bloc.trim().split('\n');
      const primera = linies[0] || '';
      const esTitol = /^\*\*.+\*\*|^#{1,3}\s/.test(primera.trim());
      if (esTitol) {
        const titol = escHtml(primera.trim()).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/^#+\s/, '');
        const desc  = linies.slice(1).join('\n').trim();
        return `<div class="world-bloc">
          <div class="world-bloc-titol">${titol}</div>
          <div class="world-bloc-desc">${escHtml(desc)}</div>
        </div>`;
      }
      return `<div class="world-bloc"><div class="world-bloc-desc">${escHtml(bloc.trim())}</div></div>`;
    }).join('\n');
  }

  document.getElementById('estructura-wrap').classList.remove('hidden');
  const total = ESTAT._estructuraCapitols.length;
  if (total > 0) {
    const btn = document.getElementById('estructura-wrap').querySelector('.btn-primary');
    if (btn) btn.textContent = `ğŸ“– Escriure ${total} capÃ­tols`;
  }
  // Inicialitzar NKG amb les dades de l'estructura
  nkgInicialitzar();
  setTimeout(() => document.getElementById('fase-10').scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10.5: Escaleta per Escenes (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFaseEscaleta() {
  showCard('fase-10-5');
  showLoader('10-5');
  document.getElementById('loader-10-5-text').textContent = 'Opus generant escaleta per escenesâ€¦';
  try {
    const caps = ESTAT._estructuraCapitols;
    const BLOC = 4; // ReduÃ¯t de 5 a 4 per donar mÃ©s marge
    let totsResultats = [];
    for (let offset = 0; offset < caps.length; offset += BLOC) {
      const bloc = caps.slice(offset, offset + BLOC);
      document.getElementById('loader-10-5-text').textContent =
        `Generant escaleta: capÃ­tols ${offset + 1}-${Math.min(offset + BLOC, caps.length)} de ${caps.length}â€¦`;

      const res = await generarEscaletaBloc(bloc, offset, USER_CONFIG);
      const parsed = parseJsonRobust(res.response);

      if (parsed && parsed.escaletes) {
        totsResultats = totsResultats.concat(parsed.escaletes);

        // Retry: si falten escaletes d'aquest bloc
        const esperats = bloc.length;
        const rebuts = parsed.escaletes.length;
        if (rebuts < esperats) {
          console.warn(`Escaleta bloc incomplet: ${rebuts}/${esperats}. Completant capÃ­tols que falten...`);
          const capsFaltants = bloc.slice(rebuts);
          try {
            const retryRes = await generarEscaletaBloc(capsFaltants, offset + rebuts, USER_CONFIG);
            const retryParsed = parseJsonRobust(retryRes.response);
            if (retryParsed && retryParsed.escaletes) {
              totsResultats = totsResultats.concat(retryParsed.escaletes);
            }
          } catch (retryErr) {
            console.warn('Retry escaleta: ' + retryErr.message);
          }
        }
      } else {
        console.warn(`Escaleta: bloc ${offset + 1}-${offset + bloc.length} no parsejat. Retry sencer...`);
        try {
          const retryRes = await generarEscaletaBloc(bloc, offset, USER_CONFIG);
          const retryParsed = parseJsonRobust(retryRes.response);
          if (retryParsed && retryParsed.escaletes) {
            totsResultats = totsResultats.concat(retryParsed.escaletes);
          }
        } catch (retryErr) {
          console.warn('Retry escaleta sencer: ' + retryErr.message);
        }
      }
    }
    ESTAT._escaletes = totsResultats;
    hideLoader('10-5');
    mostrarEscaleta(totsResultats);
    document.getElementById('btn-fase11').classList.remove('hidden');

    if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
      document.getElementById('btn-fase11').classList.add('hidden');
      showLoader('10-5');
      document.getElementById('loader-10-5-text').textContent = 'ğŸ”µ Escaleta completada. Iniciant escriptura autÃ²noma en 3 segons...';
      setTimeout(() => {
        hideLoader('10-5');
        iniciarFase11();
      }, 3000);
    }
  } catch (e) {
    hideLoader('10-5');
    toast('Error generant escaleta: ' + e.message);
  }
}

function mostrarEscaleta(escaletes) {
  const div = document.getElementById('escaleta-result');
  if (!escaletes || escaletes.length === 0) { div.innerHTML = '<p>No s\'ha pogut generar l\'escaleta.</p>'; return; }
  let html = '<div style="max-height:400px;overflow-y:auto;">';
  escaletes.forEach(e => {
    html += `<details style="margin-bottom:8px;"><summary><strong>CapÃ­tol ${e.capitol}</strong>: ${escHtml(e.titol || '')}</summary><ol>`;
    (e.escenes || []).forEach(sc => {
      html += `<li><strong>${escHtml(sc.nom || '')}</strong> (${sc.paraules_objectiu || '?'} par.)<br>${escHtml(sc.funcio_narrativa || '')}</li>`;
    });
    html += '</ol></details>';
  });
  html += '</div>';
  div.innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 11: Escriptura de capÃ­tols (Sonnet + Registre)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase11() {
  if (ESTAT._estructuraCapitols.length === 0) {
    toast('No hi ha capÃ­tols a l\'estructura. Torna a generar-la.');
    return;
  }
  ESTAT.fase                = 11;
  ESTAT._capitolActual      = 0;
  ESTAT._capitols_generats  = [];
  ESTAT._revisioInstruccions= {};
  ESTAT._metaCapitols       = {};
  ESTAT._revisionsOpus      = {};
  ESTAT._revisionsOpusFinals= {};
  ESTAT.llibreRegistre      = { capitols: [], estat_personatges: [], fils_oberts: [], fils_tancats: [] };
  ESTAT._traitsImmutablesInicialitzats = false;
  ESTAT._controlLongitud = {
    objectiu: Number((ESTAT.estil && ESTAT.estil.paraules) || 3000),
    llindarMinim: 0.70,
    llindarExpansio: 0.85,
    historicLongituds: [],
    tendencia: 'estable',
    promptForcat: ''
  };

  updateProgress(11);
  showCard('fase-11');

  if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
    document.getElementById('btn-pausa-flux').classList.remove('hidden');
  } else {
    document.getElementById('btn-pausa-flux').classList.add('hidden');
  }
  actualitzarBotoModeManualCapitols();
  amagarBotoSeguentCapitolManual();

  renderLlistaCapitols();
  try {
    await inicialitzarTraitsImmutables(USER_CONFIG);
  } catch (err) {
    console.warn('InicialitzaciÃ³ trets immutables:', err.message);
  }
  generarCapitol(0);
}

function renderLlistaCapitols() {
  const wrap  = document.getElementById('capitol-llista');
  const total = ESTAT._estructuraCapitols.length;
  document.getElementById('capitol-progress-text').textContent = `${total} capÃ­tols planificats`;

  wrap.innerHTML = ESTAT._estructuraCapitols.map((cap, i) => {
    const completat = i < ESTAT._capitolActual;
    const actiu     = i === ESTAT._capitolActual;
    const cls  = completat ? 'fet' : actiu ? 'actiu' : '';
    const ico  = completat ? 'âœ“'  : actiu  ? 'âœï¸'   : 'â—‹';
    const teText = !!(ESTAT._capitols_generats && ESTAT._capitols_generats[i]);
    const btnCopia = teText ? `<button class="capitol-copy" onclick="event.stopPropagation();copiarCapitol(${i})" title="Copiar capÃ­tol final">â˜</button>` : '';
    const onClick = teText ? `onclick="obrirDetallCapitol(${i})"` : '';
    return `<div class="capitol-item ${cls}" id="cap-item-${i}" ${onClick}>
      <span class="capitol-num">${ico}</span>
      <span class="capitol-titol">${escHtml(cap.titol || 'CapÃ­tol ' + (i + 1))}</span>
      ${teText ? `<button class="capitol-delete" onclick="event.stopPropagation();esborrarIRegenerarCapitol(${i})" title="Esborrar i regenerar capÃ­tol">ğŸ—‘ï¸</button>` : ''}${btnCopia}
    </div>`;
  }).join('\n');
}

async function esborrarIRegenerarCapitol(idx) {
  const titol = (ESTAT._estructuraCapitols[idx] && ESTAT._estructuraCapitols[idx].titol) || `CapÃ­tol ${idx + 1}`;
  const ok = confirm(`Vols esborrar totes les dades de "${titol}" i regenerar el capÃ­tol?`);
  if (!ok) return;

  if (ESTAT._capitols_generats) ESTAT._capitols_generats[idx] = '';
  if (ESTAT._metaCapitols) delete ESTAT._metaCapitols[idx];
  if (ESTAT._revisionsOpus) delete ESTAT._revisionsOpus[idx];
  if (ESTAT._revisionsOpusFinals) delete ESTAT._revisionsOpusFinals[idx];
  if (ESTAT._revisioInstruccions) delete ESTAT._revisioInstruccions[idx];
  amagarBotoSeguentCapitolManual();
  renderLlistaCapitols();

  document.getElementById('capitol-detall-wrap').classList.add('hidden');
  await generarCapitol(idx);
}

function copiarCapitol(idx) {
  const text = ESTAT._capitols_generats && ESTAT._capitols_generats[idx];
  if (!text) return;
  if (navigator.clipboard) {
    navigator.clipboard.writeText(netejarTabulacionsInicials(text)).then(() => toast(`CapÃ­tol ${idx + 1} copiat.`)).catch(() => {});
  } else {
    const ta = document.createElement('textarea');
    ta.value = netejarTabulacionsInicials(text); document.body.appendChild(ta); ta.select();
    document.execCommand('copy'); document.body.removeChild(ta);
    toast(`CapÃ­tol ${idx + 1} copiat.`);
  }
}


function copiarTextIndependent(text, etiqueta = 'Text') {
  const net = netejarTabulacionsInicials(String(text || ''));
  if (!net.trim()) { toast(`${etiqueta}: no hi ha contingut per copiar.`); return; }
  if (navigator.clipboard) {
    navigator.clipboard.writeText(net).then(() => toast(`${etiqueta} copiat.`)).catch(() => {});
  } else {
    const ta = document.createElement('textarea');
    ta.value = net; document.body.appendChild(ta); ta.select();
    document.execCommand('copy'); document.body.removeChild(ta);
    toast(`${etiqueta} copiat.`);
  }
}

function obrirDetallCapitol(idx) {
  const textFinal = (ESTAT._capitols_generats && ESTAT._capitols_generats[idx]) || '';
  if (!textFinal) return;

  ESTAT._capitolDetallIdx = idx;
  const meta  = (ESTAT._metaCapitols && ESTAT._metaCapitols[idx]) || {};
  const titol = (ESTAT._estructuraCapitols[idx] && ESTAT._estructuraCapitols[idx].titol) || `CapÃ­tol ${idx + 1}`;

  // RevisiÃ³ de coherÃ¨ncia de l'Arquitecte per a aquest capÃ­tol
  const revArq = (ESTAT._revisionsCodiSistema || []).find(r => r.capitol === idx + 1);
  let revArqTxt = '(Cap revisiÃ³ de coherÃ¨ncia per a aquest capÃ­tol â€” es genera cada 3 capÃ­tols)';
  if (revArq) {
    try {
      const r = JSON.parse(revArq.revisio);
      const linies = [];
      if (r.qualitat_coherencia) linies.push(`CoherÃ¨ncia: ${r.qualitat_coherencia.puntuacio ?? '?'}/10 â€” ${r.qualitat_coherencia.diagnostic || ''}`);
      const inconsis = (r.inconsistencies_cronologiques || []).filter(s => s && s !== 'Cap detectada');
      if (inconsis.length) linies.push(`InconsistÃ¨ncies: ${inconsis.join(' | ')}`);
      const puntsFebles = r.qualitat_coherencia && r.qualitat_coherencia.punts_febles || [];
      if (puntsFebles.length) linies.push(`Punts febles: ${puntsFebles.join(' | ')}`);
      const millores = (r.millores_proposades || []).map(m => `[${m.prioritat}] ${m.proposta || m.problema}`).join('\n');
      if (millores) linies.push(`Millores proposades:\n${millores}`);
      if (r.alerta_critica) linies.push(`âš ï¸ ${r.alerta_critica}`);
      revArqTxt = linies.join('\n') || '(sense dades)';
    } catch { revArqTxt = revArq.revisio; }
  }

  const sections = [
    { id:'inject-ctx', label:'Context injectat al Generador', text: meta.infoInjectadaEsbos || '(no disponible)' },
    { id:'cap-final',  label:'CapÃ­tol final',                 text: textFinal },
    { id:'rev-arq',    label:'RevisiÃ³ de coherÃ¨ncia (Arquitecte)', text: revArqTxt }
  ];

  const html = `<div style="font-weight:700;color:var(--accent2);margin-bottom:10px;">${escHtml(titol)}</div>` +
    sections.map(s => `<div class="capitol-detall-box">
      <button class="capitol-detall-copy" data-copy-id="det-${s.id}" data-copy-label="${escHtml(s.label)}" title="Copiar secciÃ³">â˜</button>
      <h4>${s.label}</h4>
      <div id="det-${s.id}" style="white-space:pre-wrap;font-size:.86rem;line-height:1.6;">${escHtml(s.text)}</div>
    </div>`).join('');

  const wrap = document.getElementById('capitol-detall-wrap');
  const content = document.getElementById('capitol-detall-content');
  content.innerHTML = html;
  content.querySelectorAll('.capitol-detall-copy').forEach(btn => {
    btn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      const id = btn.getAttribute('data-copy-id');
      const label = btn.getAttribute('data-copy-label') || 'SecciÃ³';
      const target = document.getElementById(id);
      copiarTextIndependent(target ? target.innerText : '', label);
    });
  });

  wrap.classList.remove('hidden');
  wrap.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

async function executarSegonaRevisioOpusCapitol() {
  const idx = ESTAT._capitolDetallIdx;
  if (idx === undefined || idx === null) { toast('Obre un capÃ­tol primer.'); return; }
  const meta = (ESTAT._metaCapitols && ESTAT._metaCapitols[idx]) || {};
  const revisio = (ESTAT._revisionsOpus && ESTAT._revisionsOpus[idx]) || {};
  const capFinal = (ESTAT._capitols_generats && ESTAT._capitols_generats[idx]) || '';
  if (!capFinal) { toast('No hi ha capÃ­tol final per revisar.'); return; }

  try {
    showLoader(11);
    document.getElementById('loader-11-text').textContent = 'ğŸ”µ Opus fent segona revisiÃ³ de reescriptura...';
    const msgs = [{ role: 'user', content: `Avalua la reescriptura final del capÃ­tol amb tota la informaciÃ³ disponible.

INFORMACIÃ“ INJECTADA PER ESBÃ’S:
${meta.infoInjectadaEsbos || ''}

ESBÃ’S:
${meta.esbos || ''}

INFORMACIÃ“ INJECTADA PER REVISIÃ“ OPUS:
${meta.infoInjectadaRevisioOpus || ''}

REVISIÃ“ OPUS INICIAL:
Nota: ${revisio.puntuacio ?? '?'}
Problemes: ${Array.isArray(revisio.problemes) ? revisio.problemes.join(' | ') : ''}
Instruccions: ${revisio.instruccions_correccio || ''}

CAPÃTOL FINAL:
${capFinal}

Retorna NOMÃ‰S JSON:
{"puntuacio":8,"observacions":"MÃ xim 100 paraules. Digues si sÃ³n bones, regulars o dolentes i per quÃ¨."}` }];
    const models = getModelConfig(USER_CONFIG);
    const raw = await callLLMMulti(msgs, "Ets l'Arquitecta Opus. Retorna nomÃ©s JSON.", Object.assign({}, USER_CONFIG, { maxTokens: 500, model: models.modelArquitecte }), 'arquitectura');
    const dades = parseJsonRobust(raw) || {};
    ESTAT._revisionsOpusFinals = ESTAT._revisionsOpusFinals || {};
    ESTAT._revisionsOpusFinals[idx] = { puntuacio: dades.puntuacio ?? '?', observacions: String(dades.observacions || '').slice(0, 650) };
    toast('âœ… Segona revisiÃ³ Opus completada.');
    obrirDetallCapitol(idx);
  } catch (err) {
    toast('Error segona revisiÃ³ Opus: ' + err.message);
  } finally {
    hideLoader(11);
  }
}

function exportarDetallCapitolActualTxt() {
  const idx = ESTAT._capitolDetallIdx;
  if (idx === undefined || idx === null) { toast('Obre un capÃ­tol primer.'); return; }
  const cap = ESTAT._estructuraCapitols[idx] || {};
  const meta = (ESTAT._metaCapitols && ESTAT._metaCapitols[idx]) || {};
  const rev = (ESTAT._revisionsOpus && ESTAT._revisionsOpus[idx]) || {};
  const revFinal = (ESTAT._revisionsOpusFinals && ESTAT._revisionsOpusFinals[idx]) || {};
  const textFinal = (ESTAT._capitols_generats && ESTAT._capitols_generats[idx]) || '';
  const txt = [
    `Nom del capÃ­tol: ${cap.titol || ('CapÃ­tol ' + (idx + 1))}`,
    '',
    '=== InformaciÃ³ injectada per generar esbÃ²s ===',
    meta.infoInjectadaEsbos || '(no disponible)',
    '',
    '=== EsbÃ²s ===',
    meta.esbos || '(no disponible)',
    '',
    "=== Canvis suggerits per l'arquitecta ===",
    meta.correccionsArquitecta || '(no disponible)',
    '',
    '=== InformaciÃ³ injectada per generar revisiÃ³ opÃºs ===',
    meta.infoInjectadaRevisioOpus || '(no disponible)',
    '',
    '=== RevisiÃ³ opus amb indicacions de millora text i nota ===',
    `Nota: ${rev.puntuacio ?? '?'}/10`,
    `Observacions: ${Array.isArray(rev.problemes) ? rev.problemes.join(' | ') : ''}`,
    `Indicacions: ${rev.instruccions_correccio || ''}`,
    '',
    '=== CapÃ­tol final ===',
    textFinal,
    '',
    '=== RevisiÃ³ final opus indicant nota i observacions ===',
    `Nota final: ${revFinal.puntuacio ?? '?'}/10`,
    `Observacions: ${revFinal.observacions || '(pendent de segona revisiÃ³)'}`
  ].join('\n');

  const blob = new Blob([txt], { type: 'text/plain;charset=utf-8' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `capitol-${idx + 1}-revisions.txt`;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
}

function actualitzarEstatCapitol(idx, estat) {
  const el = document.getElementById('cap-item-' + idx);
  if (!el) return;
  el.className = 'capitol-item ' + estat;
  el.querySelector('.capitol-num').textContent = estat === 'fet' ? 'âœ“' : estat === 'actiu' ? 'âœï¸' : 'â—‹';
}


// â”€â”€â”€ CORRECCIÃ“ 7: Neteja NKG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function netejarNKGSincronitzacions() {
  if (!ESTAT._nkg) return;
  const termesBrossa = ['sincronitzaciÃ³ inventari', '(sense dades)', 'sense dades'];
  const esBrossa = (e) => termesBrossa.some(t => String(typeof e === 'string' ? e : JSON.stringify(e)).toLowerCase().includes(t));
  if (Array.isArray(ESTAT._nkg.timeline_objectes)) {
    const vists = new Set();
    ESTAT._nkg.timeline_objectes = ESTAT._nkg.timeline_objectes.filter(e => {
      const k = JSON.stringify(e);
      if (vists.has(k) || esBrossa(e)) return false;
      vists.add(k); return true;
    });
  }
  if (Array.isArray(ESTAT._nkg.timeline_personatges)) {
    const vists = new Set();
    ESTAT._nkg.timeline_personatges = ESTAT._nkg.timeline_personatges.filter(e => {
      const k = JSON.stringify(e);
      if (vists.has(k) || esBrossa(e)) return false;
      vists.add(k); return true;
    });
  }
}

// â”€â”€â”€ CORRECCIÃ“ 6: SecciÃ³ prohibicions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function construirSeccioProhibicions(idx) {
  const lines = [];
  const beatsGastats = Array.isArray(ESTAT._nkg && ESTAT._nkg.beats_gastats) ? ESTAT._nkg.beats_gastats.slice(-15) : [];
  if (beatsGastats.length > 0) {
    lines.push('BEATS NARRATIUS JA CONSUMITS (NO repetir cap d\'aquests patrons dramÃ tics):');
    beatsGastats.forEach(b => lines.push(`- ${b}`));
  }
  const filsTancats = Array.isArray(ESTAT.llibreRegistre && ESTAT.llibreRegistre.fils_tancats) ? ESTAT.llibreRegistre.fils_tancats.slice(-10) : [];
  if (filsTancats.length > 0) {
    lines.push('FILS NARRATIUS TANCATS (NO reobrir ni referenciar com a pendents):');
    filsTancats.forEach(f => lines.push(`- ${f}`));
  }
  const accionsIrrev = Array.isArray(ESTAT._accionsIrreversibles) ? ESTAT._accionsIrreversibles.slice(-10) : [];
  if (accionsIrrev.length > 0) {
    lines.push('ACCIONS IRREVERSIBLES (NO contradir; assumeix que han passat i no es desfan):');
    accionsIrrev.forEach(a => lines.push(`- [Cap.${a.capitol}] ${a.accio}`));
  }
  if (lines.length === 0) return '';
  return '\n\nâ›” PROHIBICIONS ABSOLUTES â€” El model NO pot ignorar cap d\'aquests punts:\n' + lines.join('\n');
}

// â”€â”€â”€ CORRECCIÃ“ 5: RevisiÃ³ de continuÃ¯tat i reescriptura â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function revisioArquitectaAmbContinuitat(idx, textCapitol, userConfig) {
  const reg = ESTAT.llibreRegistre || {};
  const snapshotAnterior = idx > 0 ? (ESTAT._snapshotsFinals || {})[idx - 1] : null;
  const accionsIrrev = (ESTAT._accionsIrreversibles || []).slice(-8).map(a => `- [Cap.${a.capitol}] ${a.accio}`).join('\n') || '(cap)';
  const filsOberts   = (reg.fils_oberts || []).slice(-8).map(f => `- ${f}`).join('\n') || '(cap)';

  const msgs = [{
    role: 'user',
    content: `Ets l'Arquitecta de continuÃ¯tat. Revisa EXCLUSIVAMENT errors de continuÃ¯tat factual al capÃ­tol ${idx + 1}.

SNAPSHOT FINAL DEL CAPÃTOL ANTERIOR:
${snapshotAnterior ? `UbicaciÃ³: ${snapshotAnterior.ubicacio}\nEstat: ${snapshotAnterior.estat_emocional}\nSituaciÃ³: ${snapshotAnterior.situacio_immediata}` : '(primer capÃ­tol)'}

FILS OBERTS PENDENTS:
${filsOberts}

ACCIONS IRREVERSIBLES QUE NO ES PODEN CONTRADIR:
${accionsIrrev}

CAPÃTOL A REVISAR (primers 6000 carÃ cters):
${textCapitol.substring(0, 6000)}

Busca EXCLUSIVAMENT:
1. Events que ja van passar i es tornen a narrar com a nous.
2. Fils narratius tancats que es reobren sense justificaciÃ³.
3. Objectes "fantasma" (apareixen sense haver estat introduÃ¯ts).
4. UbicaciÃ³ impossible al principi del capÃ­tol.
5. Accions irreversibles contradites.

Si no n'hi ha, retorna veredicte APROVAT. Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "errors_continuitat": ["descripciÃ³ breu de cada error"],
  "veredicte": "APROVAT",
  "resum_correccions": ""
}`
  }];

  const models = getModelConfig(userConfig || USER_CONFIG);
  const raw = await callLLMMulti(
    msgs,
    'Ets una revisora de continuÃ¯tat narrativa estricta. Respon EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig || USER_CONFIG, { maxTokens: 800, model: models.modelArquitecte }),
    'arquitectura'
  );
  return parseJsonRobust(raw) || { errors_continuitat: [], veredicte: 'APROVAT', resum_correccions: '' };
}

async function reescriureAmbCorreccions(textCapitol, resumCorreccions, idx, userConfig) {
  const msgs = [{
    role: 'user',
    content: `Corregeix els errors de continuÃ¯tat del capÃ­tol ${idx + 1} sense afegir escenes noves ni canviar l'estructura narrativa.

CORRECCIONS A APLICAR:
${resumCorreccions}

CAPÃTOL A CORREGIR:
${textCapitol}

Retorna el capÃ­tol corregit en text pla. PROHIBIT afegir escenes, personatges nous o canviar el fil principal.`
  }];

  const models = getModelConfig(userConfig || USER_CONFIG);
  const systemPrompt = buildSystemPromptCapitol();
  const raw = await callLLMOneShotPlusCompletion(
    msgs,
    systemPrompt,
    Object.assign({}, userConfig || USER_CONFIG, { maxTokens: 14000, model: models.modelGeneracio }),
    'generacio'
  );
  return raw || textCapitol; // fallback: retorna original si falla
}

function refrescarPlaPsicologicPerSeguentCapitol() {
  try {
    const t = calcularTermometreVeritatEmocional();
    return generarPlaReescripturaPsicologica(t);
  } catch (err) {
    console.warn("Pla psicolÃ²gic: no s'ha pogut refrescar:", err.message);
    return ESTAT._plaReescripturaPsicologica || [];
  }
}

function construirBlocPlaPsicologicPerPrompt(capitol, escenaIdx) {
  const pla = Array.isArray(ESTAT._plaReescripturaPsicologica)
    ? ESTAT._plaReescripturaPsicologica.filter(Boolean)
    : [];
  if (pla.length === 0) return '';
  const top = pla.slice(0, 4).map((p, i) => `${i + 1}. ${p}`).join('\n');
  return `
PLA PSICOLÃ’GIC PRIORITARI (aplica-ho en aquest capÃ­tol ${capitol}, escena ${escenaIdx + 1}):
${top}
`;
}

async function generarCapitol(idx, intents = 0) {
  // Fi: revisiÃ³ final
  if (idx >= ESTAT._estructuraCapitols.length) {
    document.getElementById('btn-control-arcs-wrap').classList.remove('hidden');
    await executarLoopCoherenciaFinal(USER_CONFIG);
    try { await generarRevisioFinalApp(USER_CONFIG); } catch (err) { console.warn('RevisiÃ³ final app:', err.message); }
    iniciarRevisioGlobal();
    return;
  }

  // Setup UI
  ESTAT._capitolActual = idx;
  amagarBotoSeguentCapitolManual();
  renderLlistaCapitols();
  actualitzarEstatCapitol(idx, 'actiu');
  const cap = ESTAT._estructuraCapitols[idx];
  const titol = cap.titol || 'CapÃ­tol ' + (idx + 1);
  document.getElementById('capitol-actual-wrap').classList.add('hidden');
  document.getElementById('revisio-panel').classList.add('hidden');
  document.getElementById('checkpoint-intermedi-panel').classList.add('hidden');
  document.getElementById('btn-control-arcs-wrap').classList.add('hidden');
  showLoader(11);
  document.getElementById('loader-11-text').textContent = `ğŸŸ£ Sonnet escrivint el CapÃ­tol ${idx + 1} â€” "${titol}"â€¦`;

  try {
    // PreparaciÃ³ (trets immutables personatges)
    if (idx > 0) refrescarPlaPsicologicPerSeguentCapitol();
    const capPersonatges = (cap && Array.isArray(cap.personatges)) ? cap.personatges : [];
    for (const nomPers of capPersonatges) {
      await garantirTretsImmutablesPersonatge(nomPers, USER_CONFIG);
    }

    // PAS 1: Netejar NKG de duplicats i entrades brossa
    netejarNKGSincronitzacions();

    // PAS 2: Comprimir memÃ²ria preventiva si cal
    if (idx > 0 && (idx % 3 === 0 || ESTAT._memoriasComprimides.length === 0)) {
      try { await comprimirMemoria(idx, USER_CONFIG); } catch (e) { console.warn('CompressiÃ³ preventiva:', e.message); }
    }

    // PAS 3: Validar i reomplir escaleta si tÃ© escenes buides
    try { await validarIReomplirEscaleta(idx, USER_CONFIG); } catch (e) { console.warn('Escaleta validaciÃ³:', e.message); }

    // PASSOS 4+5: Generar text (prohibicions injectades via buildContextCapitol â†’ construirSeccioProhibicions)
    document.getElementById('loader-11-text').textContent = `ğŸŸ£ Sonnet escrivint el CapÃ­tol ${idx + 1} â€” "${titol}"â€¦`;
    let res = await generarCapitolNKG(idx, USER_CONFIG);
    let textNet = netejarTabulacionsInicials(res.response);

    // Control de longitud unificat
    const ajust = await ajustarLongitud(idx, textNet, USER_CONFIG);
    textNet = ajust.text;

    // PAS 6: Bucle de revisiÃ³ de continuÃ¯tat (mÃ xim 2 intents)
    for (let intent = 0; intent < 2; intent++) {
      try {
        document.getElementById('loader-11-text').textContent = `ğŸ” RevisiÃ³ continuÃ¯tat cap. ${idx + 1} (intent ${intent + 1}/2)â€¦`;
        const revisio = await revisioArquitectaAmbContinuitat(idx, textNet, USER_CONFIG);
        if (revisio && revisio.veredicte === 'REESCRIURE' && revisio.resum_correccions) {
          document.getElementById('loader-11-text').textContent = `ğŸ”§ Corregint continuÃ¯tat cap. ${idx + 1} (intent ${intent + 1}/2)â€¦`;
          const corregit = await reescriureAmbCorreccions(textNet, revisio.resum_correccions, idx, USER_CONFIG);
          textNet = netejarTabulacionsInicials(corregit || textNet);
        } else {
          break; // APROVAT
        }
      } catch (e) { console.warn('RevisiÃ³ continuÃ¯tat:', e.message); break; }
    }

    // Guardar capÃ­tol definitiu
    ESTAT._capitols_generats[idx] = textNet;
    ESTAT._metaCapitols = ESTAT._metaCapitols || {};
    ESTAT._metaCapitols[idx] = {
      textFinal: textNet,
      controlLongitud: ajust.decisio,
      esbos: res.esborrany || '',
      correccionsArquitecta: res.correccionsArquitecta || '',
      infoInjectadaEsbos: res.infoInjectadaEsbos || '',
      infoInjectadaRevisioOpus: res.infoInjectadaRevisioOpus || ''
    };

    // UI
    renderLlistaCapitols();
    hideLoader(11);
    mostrarCapitol(idx, textNet);

    // PAS 7: Snapshot validat
    try { await generarSnapshotValidat(idx, textNet, USER_CONFIG); } catch (e) { console.warn('Snapshot:', e.message); }

    // PAS 8: Fils narratius (nous/tancats, beats, accions irreversibles)
    try { await actualitzarFilsNarratius(idx, textNet, USER_CONFIG); } catch (e) { console.warn('Fils narratius:', e.message); }

    // PAS 9: Actualitzar NKG amb el text definitiu post-correccions
    if (ESTAT._nkg) {
      try {
        document.getElementById('loader-11-text').textContent = 'ğŸ”µ Actualitzant NKGâ€¦';
        await nkgActualitzarPostEscena(textNet, idx + 1, 1, USER_CONFIG);
      } catch (e) { console.warn('NKG post-capÃ­tol:', e.message); }
    }

    // Post-processing: BÃ­blia, Registre, Beats, Estil, Checkpoint, CompressiÃ³
    await arxitectePostCapitol(idx, textNet, USER_CONFIG);

    // RecursiÃ³ al capÃ­tol segÃ¼ent
    generarCapitol(idx + 1);

  } catch (err) {
    if (USER_CONFIG && USER_CONFIG.fluxAutomatic && intents < 3) {
      document.getElementById('loader-11-text').textContent = `âš ï¸ Error detectat. Reintentant capÃ­tol en 5 segons (Intent ${intents + 1}/3)...`;
      setTimeout(() => generarCapitol(idx, intents + 1), 5000);
      return;
    }
    hideLoader(11);
    console.error(`Error en capÃ­tol ${idx + 1}:`, err.message);
    toast(`Error capÃ­tol ${idx + 1}: ${err.message}`);
  }
}

async function arxitectePostCapitol(idx, textCapitol, userConfig) {
  const esRevisioSistema = idx > 0 && idx % 3 === 2; // cada 3 capÃ­tols (cap 3, 6, 9, 12...)

  // 1. BÃ­blia narrativa
  try { await actualitzarBiblia(textCapitol, idx, userConfig); } catch (e) { console.warn('BÃ­blia:', e.message); }

  // 2. Llibre de registre (+ revisiÃ³ de codi JS cada 3 capÃ­tols)
  try { await actualitzarLlibreRegistreBackground(textCapitol, idx, esRevisioSistema, userConfig); } catch (e) { console.warn('Registre:', e.message); }

  // (Snapshot i fils narratius es criden explÃ­citament a generarCapitol, passos 7 i 8)

  // 4. Beats narratius gastats
  try { await actualitzarBeatsNarratiusGastats(textCapitol, idx + 1, userConfig); } catch (e) { console.warn('Beats:', e.message); }

  // 5. Registre d'estil (sincrÃ², sense crida LLM)
  try { actualitzarRegistreEstil(idx, textCapitol); generarAlertesEstil(); } catch (e) { console.warn('Estil:', e.message); }

  // Checkpoint de coherÃ¨ncia narrativa cada 3 capÃ­tols
  const esCheckpoint = (idx + 1) % 3 === 0 && idx + 1 < ESTAT._estructuraCapitols.length;
  if (esCheckpoint) {
    try { await executarCheckpoint(idx, userConfig); } catch (e) { console.warn('Checkpoint:', e.message); }
  }

  // CompressiÃ³ de memÃ²ria cada 5 capÃ­tols
  const esCompressio = (idx + 1) % 5 === 0 && idx + 1 < ESTAT._estructuraCapitols.length;
  if (esCompressio) {
    const loaderEl = document.getElementById('loader-11-text');
    if (loaderEl) loaderEl.textContent = 'ğŸ”µ Opus comprimint memÃ²ria narrativaâ€¦';
    try { await comprimirMemoria(idx + 1, userConfig); } catch (e) { console.warn('CompressiÃ³:', e.message); }
  }

  // Mostra panel de revisiÃ³ de codi si escau
  if (esRevisioSistema) mostrarCheckpointIntermedi(idx);

  const isLast = idx >= ESTAT._estructuraCapitols.length - 1;
  mostrarAccionsCapitolSimple(idx, isLast);
}

function mostrarCapitol(idx, text) {
  text = netejarTabulacionsInicials(text);
  const cap   = ESTAT._estructuraCapitols[idx];
  const titol = cap ? cap.titol || 'CapÃ­tol ' + (idx + 1) : 'CapÃ­tol ' + (idx + 1);

  document.getElementById('capitol-actual-titol').textContent = `CapÃ­tol ${idx + 1}: ${titol}`;
  const cos  = document.getElementById('capitol-actual-cos');
  const pars = text.split(/\n\n+/).filter(p => p.trim().length > 0);
  const html = pars.map(p => `<p>${escHtml(p.trim())}</p>`).join('\n');

  const wc = compteParaules(text);
  document.getElementById('capitol-actual-wordcount').textContent = `${wc.toLocaleString('ca')} paraules`;
  document.getElementById('capitol-actual-wrap').classList.remove('hidden');

  setTimeout(() => document.getElementById('fase-11').scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);

  // Executar efecte d'escriptura
  efecteEscripturaHTML('capitol-actual-cos', html, 3);
}

function mostrarAccionsCapitol(idx, text) {
  const accions = document.getElementById('capitol-accions');
  const isLast  = idx >= ESTAT._estructuraCapitols.length - 1;

  if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
    accions.innerHTML = `<span style="color:var(--text2);font-size:.85rem;">ğŸ”µ Opus revisant el capÃ­tolâ€¦</span>`;
    revisarCapitolAmbOpus(text, idx, isLast);
  } else {
    // Si Ã©s l'Ãºltim capÃ­tol, no mostrem "Control d'Arcs" â€” ho gestiona la revisiÃ³ global
    if (isLast) {
      accions.innerHTML = `
        <button class="btn btn-secondary" onclick="iniciarRevisioManual(${idx})">ğŸ” Revisar amb Opus</button>
      `;
      actualitzarEstatCapitol(idx, 'fet');
    } else {
      accions.innerHTML = `
        <button class="btn btn-secondary" onclick="iniciarRevisioManual(${idx})">ğŸ” Revisar amb Opus</button>
        <button class="btn btn-primary" onclick="generarCapitol(${idx + 1})">â¡ï¸ CapÃ­tol ${idx + 2}</button>
      `;
      actualitzarEstatCapitol(idx, 'fet');
    }
  }
}

function iniciarRevisioManual(idx) {
  const text = ESTAT._capitols_generats[idx];
  if (!text) return;
  const isLast = idx >= ESTAT._estructuraCapitols.length - 1;
  document.getElementById('capitol-accions').innerHTML =
    `<span style="color:var(--text2);font-size:.85rem;">ğŸ”µ Opus revisant el capÃ­tolâ€¦</span>`;
  revisarCapitolAmbOpus(text, idx, isLast);
}

async function revisarCapitolAmbOpus(textCapitol, idx, isLast) {
  try {
    const res    = await revisarCapitol(textCapitol, idx, USER_CONFIG);
    const revisat = parseJsonRobust(res.response);
    mostrarRevisioCapitol(revisat, idx, isLast);
  } catch (err) {
    mostrarAccionsCapitolSimple(idx, isLast);
    toast('RevisiÃ³ Opus: ' + err.message);
  }
}

function mostrarRevisioCapitol(revisat, idx, isLast) {
  const panel   = document.getElementById('revisio-panel');
  const accions = document.getElementById('capitol-accions');

  if (!revisat) { mostrarAccionsCapitolSimple(idx, isLast); return; }

  const puntuacio   = revisat.puntuacio !== undefined ? revisat.puntuacio : '?';
  const ok          = revisat.ok_per_continuar !== false;
  const problemes   = Array.isArray(revisat.problemes) ? revisat.problemes : [];
  const instruccions= revisat.instruccions_correccio || '';
  const color = typeof puntuacio === 'number'
    ? (puntuacio >= 8 ? 'var(--success)' : puntuacio >= 6 ? 'var(--warning)' : '#f87171')
    : 'var(--text2)';

  const comentariFinal = revisat.comentari_editor_final || revisat.valoracio_general || revisat.veredicte || '';

  ESTAT._revisionsOpus = ESTAT._revisionsOpus || {};
  ESTAT._revisionsOpus[idx] = revisat;

  panel.innerHTML = `
    <div style="display:flex;align-items:center;gap:16px;margin-bottom:12px;">
      <div style="font-size:1.8rem;font-weight:700;color:${color};">${puntuacio}<span style="font-size:1rem;color:var(--text2);">/10</span></div>
      <div>
        <div style="font-weight:600;color:var(--text);">RevisiÃ³ Opus</div>
        <div style="font-size:.78rem;color:var(--text2);">${ok ? 'âœ“ Adequat per continuar' : 'âš  Recomana correcciÃ³'}</div>
      </div>
    </div>
    ${problemes.length > 0 ? `<div style="font-size:.83rem;margin-bottom:10px;">
      <strong style="color:var(--text2);">Observacions:</strong>
      <ul style="margin:6px 0 0 16px;color:var(--text);line-height:1.7;">
        ${problemes.map(p => `<li>${escHtml(String(p))}</li>`).join('\n')}
      </ul></div>` : ''}
    ${instruccions && !ok ? `<div style="font-size:.8rem;color:var(--text2);margin-top:8px;padding:10px 14px;background:var(--surface);border-radius:6px;border-left:2px solid var(--warning);">
      <strong>Instruccions:</strong> ${escHtml(instruccions)}</div>` : ''}
    ${comentariFinal ? `<div style="font-size:.8rem;color:var(--text2);margin-top:8px;padding:10px 14px;background:var(--surface2);border-radius:6px;border-left:2px solid var(--accent);">
      <strong>Comentari final de l'editor:</strong> ${escHtml(comentariFinal)}</div>` : ''}`;

  // Hook Review
  const hook = revisat.hook_review || {
    obertura_puntuacio: revisat.obertura_puntuacio,
    obertura_comentari: revisat.obertura_comentari,
    cliffhanger_puntuacio: revisat.cliffhanger_puntuacio,
    cliffhanger_comentari: revisat.cliffhanger_comentari,
    ritme_intern_puntuacio: revisat.ritme_intern_puntuacio ?? revisat.ritme_puntuacio,
    ritme_comentari: revisat.ritme_comentari,
    promesa_puntuacio: revisat.promesa_puntuacio,
    promesa_narrativa: revisat.promesa_narrativa || revisat.promesa_comentari
  };
  if (hook) {
    const cHook = (p) => p >= 7 ? 'var(--success)' : p >= 5 ? 'var(--warning)' : '#f87171';
    panel.innerHTML += `
      <div style="margin-top:14px;padding-top:14px;border-top:1px solid var(--border);">
        <div style="font-weight:600;font-size:.85rem;color:var(--accent2);margin-bottom:8px;">ğŸ“ Enganxament</div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:.8rem;">
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Obertura:</span> <strong style="color:${cHook(hook.obertura_puntuacio)};">${hook.obertura_puntuacio || '?'}/10</strong>
          </div>
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Cliffhanger:</span> <strong style="color:${cHook(hook.cliffhanger_puntuacio)};">${hook.cliffhanger_puntuacio || '?'}/10</strong>
          </div>
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Ritme:</span> <strong style="color:${cHook(hook.ritme_intern_puntuacio)};">${hook.ritme_intern_puntuacio || '?'}/10</strong>
          </div>
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Promesa:</span> <span style="font-size:.75rem;">${escHtml(hook.promesa_narrativa || 'N/A')}</span>
          </div>
        </div>
      </div>`;
  }

  panel.classList.remove('hidden');

  // Golden passage
  if (revisat.golden_passage && revisat.puntuacio >= 7) {
    if (!ESTAT._goldenPassage || revisat.puntuacio > 7) {
      ESTAT._goldenPassage = revisat.golden_passage;
      ESTAT._goldenPassageCapitol = idx;
    }
  }

  const nextLabel  = isLast ? '' : `â¡ï¸ CapÃ­tol ${idx + 2}`;
  const nextAction = isLast ? '' : `generarCapitol(${idx + 1})`;

  // ğŸ”´ CORRECCIÃ“: GestiÃ³ automatitzada real del flux
  if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
    if (!ok && instruccions) {
      accions.innerHTML = `<span style="color:var(--text2);font-size:.85rem;">ğŸ”´ Opus demana correccions. Entrant a la cua per reescriure...</span>`;
      GestorFlux.afegirTasca(`Reescriure Cap. ${idx + 1}`, () => reescriureCapitol(idx), 15000);
    } else {
      if (!isLast && esModeManualEntreCapitols()) {
        accions.innerHTML = `<span style="color:var(--success);font-size:.85rem;">âœ… CapÃ­tol aprovat. Esperant inici manual del segÃ¼ent.</span>`;
        mostrarBotoSeguentCapitolManual(idx + 1);
      } else {
        amagarBotoSeguentCapitolManual();
        accions.innerHTML = `<span style="color:var(--success);font-size:.85rem;">âœ… CapÃ­tol aprovat. Entrant a la cua pel segÃ¼ent...</span>`;
        if (!isLast) {
          GestorFlux.afegirTasca(`Generar Cap. ${idx + 2}`, () => generarCapitol(idx + 1), 15000);
        } else {
          GestorFlux.afegirTasca('RevisiÃ³/EpÃ­leg Final', () => generarCapitol(ESTAT._estructuraCapitols.length), 2000);
        }
      }
    }
  } else {
    // Mode Manual
    if (!ok && instruccions) {
      accions.innerHTML = `
        <button class="btn btn-secondary" onclick="reescriureCapitol(${idx})">âœï¸ Reescriure (Sonnet)</button>
        ${isLast ? '' : `<button class="btn btn-primary" onclick="${nextAction}">${nextLabel}</button>`}`;
    } else {
      accions.innerHTML = isLast ? '' : `<button class="btn btn-primary" onclick="${nextAction}">${nextLabel}</button>`;
    }
    if (isLast) generarCapitol(ESTAT._estructuraCapitols.length);

    if (hook && hook.cliffhanger_puntuacio < 6 && revisat.instruccions_cliffhanger) {
      const btnCH = document.createElement('button');
      btnCH.className = 'btn btn-secondary';
      btnCH.textContent = 'ğŸ£ Millorar cliffhanger';
      btnCH.onclick = () => millorarCliffhanger(idx, revisat.instruccions_cliffhanger);
      accions.appendChild(btnCH);
    }
  }

  actualitzarEstatCapitol(idx, 'fet');
}

function mostrarCheckpointIntermedi(idx) {
  const panel = document.getElementById('checkpoint-intermedi-panel');
  if (!panel) return;

  const capitol = idx + 1;
  const revArq = (ESTAT._revisionsCodiSistema || []).find(r => r.capitol === capitol);
  if (!revArq) { panel.classList.add('hidden'); return; }

  let r = {};
  try { r = JSON.parse(revArq.revisio); } catch { /* dades crues */ }

  const qualitat = r.qualitat_coherencia || {};
  const punts = qualitat.puntuacio ?? '?';
  const colorPunts = typeof punts === 'number'
    ? (punts >= 8 ? 'var(--success)' : punts >= 6 ? 'var(--warning)' : '#f87171')
    : 'var(--text2)';

  const inconsis = (r.inconsistencies_cronologiques || []).filter(s => s && s !== 'Cap detectada');
  const inconsHtml = inconsis.length
    ? `<div style="margin-top:10px;"><div style="font-size:.8rem;font-weight:600;color:#f87171;margin-bottom:4px;">â± InconsistÃ¨ncies cronolÃ²giques</div><ul style="margin:0 0 0 14px;padding:0;font-size:.8rem;color:var(--text);">${inconsis.map(s => `<li style="margin-bottom:3px;">${escHtml(s)}</li>`).join('')}</ul></div>`
    : `<div style="margin-top:8px;font-size:.8rem;color:var(--success);">âœ“ Sense inconsistÃ¨ncies cronolÃ²giques detectades</div>`;

  const puntsFebles = (qualitat.punts_febles || []);
  const puntsFeblesHtml = puntsFebles.length
    ? `<div style="margin-top:10px;"><div style="font-size:.8rem;font-weight:600;color:var(--text2);margin-bottom:4px;">Punts febles</div><ul style="margin:0 0 0 14px;padding:0;font-size:.8rem;color:var(--text);">${puntsFebles.map(s => `<li style="margin-bottom:3px;">${escHtml(s)}</li>`).join('')}</ul></div>`
    : '';

  const millores = (r.millores_proposades || []);
  const milloresHtml = millores.length
    ? `<div style="margin-top:10px;"><div style="font-size:.8rem;font-weight:600;color:var(--accent2);margin-bottom:4px;">Millores proposades</div>${millores.map(m => {
        const color = m.prioritat === 'alta' ? '#f87171' : m.prioritat === 'mitja' ? 'var(--warning)' : 'var(--text2)';
        return `<div style="font-size:.78rem;padding:5px 10px;margin-bottom:4px;background:var(--surface);border-radius:5px;border-left:2px solid ${color};"><span style="color:${color};font-weight:600;">[${escHtml(m.prioritat || '?')}]</span> ${escHtml(m.proposta || m.problema || '')}</div>`;
      }).join('')}</div>`
    : '';

  const alertaHtml = r.alerta_critica
    ? `<div style="margin-top:10px;padding:8px 12px;background:#fef2f2;border-radius:6px;border-left:3px solid #f87171;font-size:.8rem;color:#b91c1c;"><strong>âš ï¸ Alerta crÃ­tica:</strong> ${escHtml(r.alerta_critica)}</div>`
    : '';

  panel.innerHTML = `
    <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;">
      <div style="font-size:1.6rem;font-weight:700;color:${colorPunts};">${punts}<span style="font-size:.9rem;color:var(--text2);">/10</span></div>
      <div>
        <div style="font-weight:700;color:var(--accent2);font-size:.95rem;">RevisiÃ³ de coherÃ¨ncia â€” CapÃ­tol ${capitol}</div>
        <div style="font-size:.77rem;color:var(--text2);">${escHtml(qualitat.diagnostic || '')}</div>
      </div>
    </div>
    ${alertaHtml}${inconsHtml}${puntsFeblesHtml}${milloresHtml}`;

  panel.classList.remove('hidden');
  panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function mostrarAccionsCapitolSimple(idx, isLast) {
  if (isLast) {
    amagarBotoSeguentCapitolManual();
    document.getElementById('capitol-accions').innerHTML = '';
    if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
      GestorFlux.afegirTasca('RevisiÃ³/EpÃ­leg Final', () => generarCapitol(ESTAT._estructuraCapitols.length), 2000);
    } else {
      generarCapitol(ESTAT._estructuraCapitols.length);
    }
  } else {
    // Si Ã©s automÃ tic, usem la cua de tasques
    if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
      if (esModeManualEntreCapitols()) {
        document.getElementById('capitol-accions').innerHTML = `<span style="color:var(--text2);font-size:.85rem;">CapÃ­tol llest. Inicia manualment el segÃ¼ent des del botÃ³ inferior.</span>`;
        mostrarBotoSeguentCapitolManual(idx + 1);
      } else {
        document.getElementById('capitol-accions').innerHTML = `<span style="color:var(--text2);font-size:.85rem;">AvanÃ§ant automÃ ticament al segÃ¼ent capÃ­tol...</span>`;
        GestorFlux.afegirTasca(`Generar Cap. ${idx + 2}`, () => generarCapitol(idx + 1), 15000);
      }
    } else {
      document.getElementById('capitol-accions').innerHTML =
        `<button class="btn btn-primary" onclick="generarCapitol(${idx + 1})">â¡ï¸ CapÃ­tol ${idx + 2}</button>`;
    }
  }
  actualitzarEstatCapitol(idx, 'fet');
}

async function reescriureCapitol(idx, intents = 0) {
  const instruccions = ESTAT._revisioInstruccions[idx] || '';
  document.getElementById('capitol-actual-wrap').classList.add('hidden');
  document.getElementById('revisio-panel').classList.add('hidden');
  showLoader(11);
  document.getElementById('loader-11-text').textContent = 'ğŸŸ£ Sonnet aplicant les correccionsâ€¦';

  try {
    const res = await reescriureCapitolAmbInstruccions(idx, instruccions, USER_CONFIG);
    const textNet = netejarTabulacionsInicials(res.response);
    ESTAT._capitols_generats[idx] = textNet;
    ESTAT._metaCapitols = ESTAT._metaCapitols || {};
    ESTAT._metaCapitols[idx] = Object.assign({}, ESTAT._metaCapitols[idx] || {}, { textFinal: textNet });
    renderLlistaCapitols();
    hideLoader(11);
    mostrarCapitol(idx, textNet);
    const isLast = idx >= ESTAT._estructuraCapitols.length - 1;
    mostrarAccionsCapitolSimple(idx, isLast);
    toast('CapÃ­tol reescrit.');
  } catch (err) {
    if (USER_CONFIG && USER_CONFIG.fluxAutomatic && intents < 3) {
      document.getElementById('loader-11-text').textContent = `âš ï¸ Error detectat. Reintentant capÃ­tol en 5 segons (Intent ${intents + 1}/3)...`;
      setTimeout(() => reescriureCapitol(idx, intents + 1), 5000);
      return;
    }

    hideLoader(11);
    document.getElementById('capitol-actual-wrap').classList.remove('hidden');

    if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
      const isLast = idx >= ESTAT._estructuraCapitols.length - 1;
      mostrarAccionsCapitolSimple(idx, isLast);
      toast("Error Sonnet (reescriptura): s'han exhaurit els reintents. Continuant flux automÃ tic.");
      return;
    }

    toast('Error Sonnet: ' + err.message);
  }
}


function resumAutomaticCapitol(textCapitol) {
  const net = String(textCapitol || '').replace(/\s+/g, ' ').trim();
  if (!net) return '(sense resum)';
  const frases = net.match(/[^.!?â€¦]+[.!?â€¦]+/g) || [];
  if (frases.length >= 2) return (frases[0] + ' ' + frases[1]).trim().slice(0, 420);
  return net.slice(0, 420) + (net.length > 420 ? 'â€¦' : '');
}

function normalitzarEntradaRegistre(dades, textCapitol, idx) {
  const base = (dades && typeof dades === 'object') ? dades : {};
  const resum = String(base.resum_capitol || '').trim() || resumAutomaticCapitol(textCapitol);
  const estatPersonatges = Array.isArray(base.estat_personatges) ? base.estat_personatges.map(p => ({
    nom: p && p.nom ? p.nom : '',
    ubicacio: p && p.ubicacio ? p.ubicacio : '',
    estat_actual: p && p.estat_actual ? p.estat_actual : '',
    perfil_psicologic: p && p.perfil_psicologic ? p.perfil_psicologic : '',
    estat_animic_actual: p && p.estat_animic_actual ? p.estat_animic_actual : 'Tranquil'
  })) : [];
  return {
    resum_capitol: resum,
    estat_personatges: estatPersonatges,
    fils_oberts: Array.isArray(base.fils_oberts) ? base.fils_oberts : [],
    fils_tancats: Array.isArray(base.fils_tancats) ? base.fils_tancats : [],
    fils_nous_detectats: Array.isArray(base.fils_nous_detectats) ? base.fils_nous_detectats : [],
    fils_resolts_detectats: Array.isArray(base.fils_resolts_detectats) ? base.fils_resolts_detectats : [],
    prefiguracions_detectades: Array.isArray(base.prefiguracions_detectades) ? base.prefiguracions_detectades : [],
    _fallback: !dades,
    _capitol_idx: idx
  };
}


function reconciliarFilsRegistre(dades) {
  const reg = ESTAT.llibreRegistre || {};
  const obertsActuals = new Set(Array.isArray(reg.fils_oberts) ? reg.fils_oberts : []);
  const tancatsActuals = new Set(Array.isArray(reg.fils_tancats) ? reg.fils_tancats : []);

  const obertsDeclarats = new Set(Array.isArray(dades.fils_oberts) ? dades.fils_oberts : []);
  const tancatsDeclarats = new Set(Array.isArray(dades.fils_tancats) ? dades.fils_tancats : []);
  const filsNous = new Set(Array.isArray(dades.fils_nous_detectats) ? dades.fils_nous_detectats : []);
  const filsResolts = new Set(Array.isArray(dades.fils_resolts_detectats) ? dades.fils_resolts_detectats : []);

  [...obertsDeclarats, ...filsNous].forEach(f => { if (f) obertsActuals.add(f); });
  [...tancatsDeclarats, ...filsResolts].forEach(f => {
    if (!f) return;
    tancatsActuals.add(f);
    obertsActuals.delete(f);
  });

  ESTAT.llibreRegistre.fils_oberts = [...obertsActuals];
  ESTAT.llibreRegistre.fils_tancats = [...tancatsActuals];
}

async function actualitzarFilsNarratius(idx, textCapitol, userConfig) {
  const nkg = ESTAT._nkg || {};
  const reg = ESTAT.llibreRegistre || {};
  const filsOberts   = Array.isArray(reg.fils_oberts)      ? reg.fils_oberts      : [];
  const filsTancats  = Array.isArray(reg.fils_tancats)     ? reg.fils_tancats     : [];
  const beatsGastats = Array.isArray(nkg.beats_gastats)    ? nkg.beats_gastats    : [];

  const msgs = [{
    role: 'user',
    content: `Analitza aquest capÃ­tol de novelÂ·la des del punt de vista dels fils narratius.

FILS OBERTS ACUMULATS FINS ARA:
${filsOberts.slice(-10).map(f => `- ${f}`).join('\n') || '(cap)'}

FILS TANCATS ACUMULATS FINS ARA:
${filsTancats.slice(-5).map(f => `- ${f}`).join('\n') || '(cap)'}

BEATS NARRATIUS JA GASTATS:
${beatsGastats.slice(-8).map(b => `- ${b}`).join('\n') || '(cap)'}

INICI DEL CAPÃTOL ${idx + 1} (primers 4000 carÃ cters):
${textCapitol.substring(0, 4000)}

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "nous_fils_oberts": ["nou fil o pregunta oberta introduÃ¯da en aquest capÃ­tol"],
  "fils_tancats_en_aquest_capitol": ["fil de la llista anterior que s'ha resolt explÃ­citament"],
  "nous_beats_gastats": ["beat narratiu consumit en aquest capÃ­tol que NO es pot repetir"],
  "accions_irreversibles": ["acciÃ³ o canvi d'estat permanent que no tÃ© marxa enrere"]
}`
  }];

  const models = getModelConfig(userConfig || USER_CONFIG);
  const raw = await callLLMMulti(
    msgs,
    'Ets un analista narratiu. Respon EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig || USER_CONFIG, { maxTokens: 600, model: models.modelArquitecte }),
    'arquitectura'
  );

  const dades = parseJsonRobust(raw);
  if (!dades) return;

  // Actualitzar fils oberts/tancats
  const obertsSet  = new Set(filsOberts);
  const tancatsSet = new Set(filsTancats);
  (dades.nous_fils_oberts || []).forEach(f => { if (f && f.trim()) obertsSet.add(f.trim()); });
  (dades.fils_tancats_en_aquest_capitol || []).forEach(f => {
    if (!f || !f.trim()) return;
    const ft = f.trim();
    tancatsSet.add(ft);
    obertsSet.delete(ft);
    // eliminaciÃ³ per inclusiÃ³ parcial (variants de redacciÃ³)
    for (const obert of [...obertsSet]) {
      if (obert.toLowerCase().includes(ft.toLowerCase()) || ft.toLowerCase().includes(obert.toLowerCase())) {
        tancatsSet.add(obert);
        obertsSet.delete(obert);
      }
    }
  });
  ESTAT.llibreRegistre.fils_oberts  = [...obertsSet];
  ESTAT.llibreRegistre.fils_tancats = [...tancatsSet];

  // Actualitzar beats_gastats al NKG
  if (!Array.isArray(ESTAT._nkg.beats_gastats)) ESTAT._nkg.beats_gastats = [];
  (dades.nous_beats_gastats || []).forEach(b => {
    if (b && b.trim() && !ESTAT._nkg.beats_gastats.includes(b.trim()))
      ESTAT._nkg.beats_gastats.push(b.trim());
  });

  // Actualitzar accions irreversibles
  if (!Array.isArray(ESTAT._accionsIrreversibles)) ESTAT._accionsIrreversibles = [];
  (dades.accions_irreversibles || []).forEach(a => {
    if (a && a.trim()) ESTAT._accionsIrreversibles.push({ capitol: idx + 1, accio: a.trim() });
  });
}

// FASE 8: registre sÃ­ncron amb retry â€” s'awaita des de generarCapitol
async function actualitzarLlibreRegistreBackground(textCapitol, idx, esRevisioSistema = false, userConfig) {
  const cfg = userConfig || USER_CONFIG;
  const dades = await extreureDadesRegistreIAvaluarSistema(idx, textCapitol, esRevisioSistema, cfg);
  if (dades && dades.actualitzacio_nkg) {
    const entrada = dades.actualitzacio_nkg;
    if (!ESTAT.llibreRegistre.capitols) ESTAT.llibreRegistre.capitols = [];
    ESTAT.llibreRegistre.capitols[idx] = normalitzarEntradaRegistre(entrada, textCapitol, idx);
    if (Array.isArray(entrada.personatges) && entrada.personatges.length > 0)
      ESTAT.llibreRegistre.estat_personatges = entrada.personatges;
    reconciliarFilsRegistre(ESTAT.llibreRegistre.capitols[idx]);
    // Claus per al capÃ­tol segÃ¼ent (Fix 2)
    if (Array.isArray(entrada.claus_prompt_seguent) && entrada.claus_prompt_seguent.length > 0)
      ESTAT._clausPromptSeguent = entrada.claus_prompt_seguent;
  } else {
    if (!ESTAT.llibreRegistre.capitols) ESTAT.llibreRegistre.capitols = [];
    ESTAT.llibreRegistre.capitols[idx] = normalitzarEntradaRegistre(null, textCapitol, idx);
    console.warn('Registre: fallback local aplicat (entrada mÃ­nima) per al capÃ­tol', idx + 1);
  }
  // Alerta de l'Arquitecte per al capÃ­tol segÃ¼ent (Fix 3)
  if (esRevisioSistema && dades && dades.revisio_sistema) {
    const rev = dades.revisio_sistema;
    const millores = (rev.millores_proposades || []).filter(m => m.prioritat === 'alta').slice(0, 3);
    const alerta = rev.alerta_critica || '';
    if (millores.length > 0 || alerta)
      ESTAT._alertaArquitecte = { millores, alerta, capitol: idx + 1 };
  }
  await actualitzarEstatsAnimics(textCapitol, idx, cfg);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 12: Control d'Arcs (Opus) + EpÃ­leg (Sonnet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function extreureEvidenciesTermometre(capitols = []) {
  const senyals = [
    { regex: /plora|tremola|confessa|culpa|vergonya|por/i, tipus: 'vulnerabilitat' },
    { regex: /silenci|evita|amaga|insinua|contradiu/i, tipus: 'subtext' },
    { regex: /decideix|admet|renuncia|accepta|cedeix/i, tipus: 'canvi_intern' }
  ];
  const evid = [];
  capitols.forEach((cap, idx) => {
    const txt = String(cap || '').replace(/\s+/g, ' ').trim();
    if (!txt) return;
    const tall = txt.substring(0, 700);
    senyals.forEach(s => {
      const m = tall.match(s.regex);
      if (m && evid.length < 6) {
        evid.push({
          capitol: idx + 1,
          tipus: s.tipus,
          fragment: tall.substring(Math.max(0, m.index - 45), Math.min(tall.length, (m.index || 0) + 90)).trim()
        });
      }
    });
  });
  return evid;
}

function generarPlaReescripturaPsicologica(termometre) {
  const pla = [];
  if ((termometre.total || 0) < 65) {
    pla.push('Afegir una escena de vulnerabilitat explÃ­cita per al protagonista en el proper capÃ­tol.');
  }
  if ((termometre.subtext || 0) < 45) {
    pla.push('Reescriure 1-2 diÃ legs clau substituint exposiciÃ³ directa per subtext i contradicciÃ³.');
  }
  if ((termometre.canviIntern || 0) < 45) {
    pla.push('ForÃ§ar una decisiÃ³ amb cost intern irreversible abans del clÃ­max.');
  }
  if ((ESTAT._arcTransitionWarnings || []).length > 0) {
    pla.push('Revisar salts d\'arc intern no plausibles detectats i inserir transiciÃ³ emocional intermÃ¨dia.');
  }
  ESTAT._plaReescripturaPsicologica = pla;
  return pla;
}

function calcularTermometreVeritatEmocional() {
  const caps = ESTAT._capitols_generats || [];
  const text = caps.join('\n').toLowerCase();
  const perfilCount = Object.values(ESTAT._perfilsPersonatges || {}).filter(p => p && p.ferida_nuclear && p.mascara_social).length;
  const base = Math.min(40, perfilCount * 7);
  const subtext = Math.min(20, (text.match(/silenci|evita|amaga|insinua|contradiu/g) || []).length);
  const vulnerabilitat = Math.min(20, (text.match(/plora|tremola|confessa|culpa|vergonya|por/g) || []).length);
  const canviIntern = Math.min(20, (text.match(/decideix|admet|renuncia|accepta|cedeix/g) || []).length);
  const total = Math.min(100, base + subtext + vulnerabilitat + canviIntern);
  const evidencies = extreureEvidenciesTermometre(caps);
  return {
    total,
    autenticitat: Math.min(100, base + vulnerabilitat + 20),
    vulnerabilitat: Math.min(100, vulnerabilitat * 5),
    subtext: Math.min(100, subtext * 5),
    canviIntern: Math.min(100, canviIntern * 5),
    evidencies
  };
}

function renderTermometreVeritatEmocional() {
  const t = calcularTermometreVeritatEmocional();
  const el = document.getElementById('termometre-veritat');
  if (!el) return;
  const pla = generarPlaReescripturaPsicologica(t);
  const evidHtml = (t.evidencies || []).length > 0
    ? `<ul style="margin:8px 0 0 16px;padding:0;">${t.evidencies.map(e => `<li style="margin-bottom:6px;"><strong>Cap. ${e.capitol}</strong> Â· ${escHtml(e.tipus)} â€” <span style="color:var(--text2)">${escHtml(e.fragment)}...</span></li>`).join('\n')}</ul>`
    : "<p style=\"margin:8px 0 0;color:var(--text2);\">No s'han detectat evidÃ¨ncies textuals clares. Recomanat reforÃ§ar escenes emocionals.</p>";
  const plaHtml = pla.length > 0
    ? `<ul style="margin:8px 0 0 16px;padding:0;">${pla.map(p => `<li style="margin-bottom:6px;">${escHtml(p)}</li>`).join('\n')}</ul>`
    : '<p style="margin:8px 0 0;color:var(--success);">Cap pla de reescriptura necessari: veritat emocional en bon nivell.</p>';
  const warns = ESTAT._arcTransitionWarnings || [];

  el.innerHTML = `<div class="worldbuilding-result">
    <div class="world-bloc">
      <div class="world-bloc-titol">ğŸ§ª TermÃ²metre de veritat emocional</div>
      <div class="world-bloc-desc">
        Global: <strong>${t.total}/100</strong><br>
        Autenticitat emocional: ${t.autenticitat}/100 Â· Vulnerabilitat: ${t.vulnerabilitat}/100 Â· Subtext: ${t.subtext}/100 Â· Canvi intern: ${t.canviIntern}/100
      </div>
    </div>
    <div class="world-bloc">
      <div class="world-bloc-titol">ğŸ” EvidÃ¨ncia traÃ§able</div>
      <div class="world-bloc-desc">${evidHtml}</div>
    </div>
    <div class="world-bloc">
      <div class="world-bloc-titol">ğŸ› ï¸ Pla de reescriptura psicolÃ²gica</div>
      <div class="world-bloc-desc">${plaHtml}</div>
    </div>
    ${warns.length > 0 ? `<div class="world-bloc"><div class="world-bloc-titol">âš ï¸ Transicions d'arc bloquejades</div><div class="world-bloc-desc">${escHtml(String(warns.length))} salts no plausibles s'han mantingut en l'etapa anterior per preservar coherÃ¨ncia.</div></div>` : ''}
  </div>`;
}


async function iniciarFase12() {
  ESTAT.fase = 12;
  updateProgress(12);
  showCard('fase-12');
  document.getElementById('arcs-result').classList.add('hidden');
  document.getElementById('epileg-loader-wrap').classList.add('hidden');
  document.getElementById('epileg-cos').classList.add('hidden');
  showLoader(12);

  try {
    const res = await controlArcsNovella(USER_CONFIG);
    ESTAT._controlArcs = res.response;
    hideLoader(12);

    const arcosCos = document.getElementById('arcs-cos');
    const blocs = res.response.split(/\n\n+/).filter(b => b.trim().length > 0);
    arcosCos.innerHTML = `<div class="worldbuilding-result">` + blocs.map(bloc => {
      const linies  = bloc.trim().split('\n');
      const primera = linies[0] || '';
      const esTitol = /^\*\*.+\*\*|^#{1,3}\s/.test(primera.trim());
      if (esTitol) {
        const titol = escHtml(primera.trim()).replace(/\*\*(.+?)\*\*/g, '$1').replace(/^#+\s/, '');
        const desc  = linies.slice(1).join('\n').trim();
        return `<div class="world-bloc">
          <div class="world-bloc-titol">${titol}</div>
          <div class="world-bloc-desc">${escHtml(desc)}</div>
        </div>`;
      }
      return `<div class="world-bloc"><div class="world-bloc-desc">${escHtml(bloc.trim())}</div></div>`;
    }).join('\n') + `</div>`;

    // Si Opus menciona epÃ­leg, mostra el botÃ³
    if (/epÃ­leg|epilog/i.test(res.response)) {
      document.getElementById('btn-epileg').classList.remove('hidden');
    }
    renderTermometreVeritatEmocional();
    document.getElementById('arcs-result').classList.remove('hidden');
    setTimeout(() => document.getElementById('fase-12').scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
  } catch (err) {
    hideLoader(12);
    toast('Error Opus: ' + err.message);
  }
}

async function escriureEpileg() {
  document.getElementById('btn-epileg').disabled = true;
  document.getElementById('epileg-loader-wrap').classList.remove('hidden');

  try {
    const res = await generarEpileg(ESTAT._controlArcs, USER_CONFIG);
    const epilegNet = netejarTabulacionsInicials(res.response);
    ESTAT.epileg = epilegNet;
    ESTAT._epileg_generat = epilegNet;
    document.getElementById('epileg-loader-wrap').classList.add('hidden');

    const epilegText = document.getElementById('epileg-text');
    const pars = epilegNet.split(/\n\n+/).filter(p => p.trim().length > 0);
    const html = pars.map(p => `<p>${escHtml(p.trim())}</p>`).join('\n');
    document.getElementById('epileg-cos').classList.remove('hidden');
    toast('EpÃ­leg escrit per Sonnet.');

    // Executar efecte d'escriptura
    efecteEscripturaHTML('epileg-text', html, 5);
  } catch (err) {
    document.getElementById('epileg-loader-wrap').classList.add('hidden');
    document.getElementById('btn-epileg').disabled = false;
    toast('Error Sonnet: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MODAL: Llibre de Registre
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function obrirLlibreRegistre() {
  const cos = document.getElementById('registre-cos');
  const reg = ESTAT.llibreRegistre;
  const capsFets = (reg.capitols || []).filter(c => c);

  if (capsFets.length === 0) {
    cos.innerHTML = `<p style="color:var(--text2);font-size:.9rem;padding:20px 0;">El registre s'actualitzarÃ  automÃ ticament quan es generin capÃ­tols.</p>`;
  } else {
    const pers       = reg.estat_personatges || [];
    const filsOberts = reg.fils_oberts       || [];
    const filsTancat = reg.fils_tancats      || [];
    cos.innerHTML = `
      <div style="margin-bottom:22px;">
        <div class="world-bloc-titol" style="margin-bottom:10px;">Personatges actuals</div>
        ${pers.length === 0
          ? `<p style="color:var(--text2);font-size:.85rem;">Pendent de procesar.</p>`
          : pers.map(p => `<div style="padding:8px 14px;background:var(--surface2);border-radius:8px;margin-bottom:6px;font-size:.86rem;">
              <strong>${escHtml(p.nom || '')}</strong>
              <span style="color:var(--text2);"> â€” ${escHtml(p.ubicacio || '')} Â· ${escHtml(p.estat_actual || '')}</span>
            </div>`).join('\n')}
      </div>
      ${filsOberts.length > 0 ? `<div style="margin-bottom:18px;">
        <div class="world-bloc-titol" style="margin-bottom:8px;">Fils oberts</div>
        ${filsOberts.map(f => `<div style="padding:5px 12px;border-left:2px solid var(--warning);margin-bottom:5px;font-size:.84rem;">${escHtml(f)}</div>`).join('\n')}
      </div>` : ''}
      ${filsTancat.length > 0 ? `<div style="margin-bottom:18px;">
        <div class="world-bloc-titol" style="margin-bottom:8px;">Fils tancats</div>
        ${filsTancat.map(f => `<div style="padding:5px 12px;border-left:2px solid var(--success);margin-bottom:5px;font-size:.84rem;">${escHtml(f)}</div>`).join('\n')}
      </div>` : ''}
      <div>
        <div class="world-bloc-titol" style="margin-bottom:10px;">Resums per capÃ­tol</div>
        ${(reg.capitols || []).map((c, i) => c ? `
          <div style="padding:10px 14px;background:var(--surface2);border-radius:8px;margin-bottom:8px;">
            <div style="font-weight:600;font-size:.82rem;color:var(--accent2);margin-bottom:4px;">CapÃ­tol ${i + 1}</div>
            <div style="font-size:.84rem;color:var(--text);line-height:1.6;">${escHtml(c.resum_capitol || '(sense resum)')}</div>
          </div>` : '').join('\n')}
      </div>`;
  }
  document.getElementById('modal-registre').classList.remove('hidden');
}

function tancarModalRegistre() {
  document.getElementById('modal-registre').classList.add('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 6: RevisiÃ³ Final App (Arquitecte) + RevisiÃ³ Global (Opus) â€” UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarRevisioFinalApp(userConfig) {
  const revisionsAcumulades = (ESTAT._revisionsCodiSistema || [])
    .map(r => {
      const parsed = (() => { try { return JSON.parse(r.revisio); } catch { return null; } })();
      if (!parsed) return `=== CHECKPOINT cap ${r.capitol} ===\n${r.revisio}`;
      const inconsistencies = (parsed.inconsistencies_cronologiques || []).join('; ') || 'Cap';
      const punts_febles = (parsed.qualitat_coherencia && parsed.qualitat_coherencia.punts_febles || []).join('; ') || 'â€”';
      const puntuacio = parsed.qualitat_coherencia ? parsed.qualitat_coherencia.puntuacio : '?';
      const alerta = parsed.alerta_critica ? `âš ï¸ ${parsed.alerta_critica}` : '';
      return `=== CHECKPOINT cap ${r.capitol} (coherÃ¨ncia: ${puntuacio}/10) ===\nInconsistÃ¨ncies: ${inconsistencies}\nPunts febles: ${punts_febles}${alerta ? '\n' + alerta : ''}`;
    })
    .join('\n\n');

  const msgs = [{
    role: 'user',
    content: `Ets l'Arquitecte de la novelÂ·la. Acabes de supervisar la generaciÃ³ completa capÃ­tol a capÃ­tol.

REVISIONS DE CONSISTÃˆNCIA ACUMULADES (una cada 3 capÃ­tols):
${revisionsAcumulades || '(cap revisiÃ³ intermÃ¨dia disponible)'}

TASCA: Fes una DIAGNOSI FINAL i CONSOLIDADA de la novelÂ·la des del punt de vista de la coherÃ¨ncia i la consistÃ¨ncia:
1. Quines inconsistÃ¨ncies cronolÃ²giques o de continuÃ¯tat han persistit al llarg de la generaciÃ³?
2. Quins arcs de personatge o trames han mostrat debilitats estructurals repetides?
3. Quines millores concretes recomanaries implementar als capÃ­tols per a la prÃ²xima generaciÃ³?

Retorna JSON:
{
  "diagnÃ²stic_global": "AvaluaciÃ³ consolidada de la coherÃ¨ncia i consistÃ¨ncia de tota la novelÂ·la...",
  "inconsistencies_persistents": ["inconsistÃ¨ncia que ha aparegut en mÃºltiples checkpoints"],
  "millores_prioritzades": [{"area": "cronologia|arc_personatge|trama|continuitat", "proposta": "...", "impacte": "alt|mitjÃ |baix"}],
  "patrons_debilitat": ["patrÃ³ de debilitat narrativa recurrent detectat"],
  "recomanacions_seguent_generacio": ["recomanaciÃ³ per millorar la propera novelÂ·la generada"]
}`
  }];

  const models = getModelConfig(userConfig);
  const res = await callLLMOneShotPlusCompletion(msgs, "Ets l'Arquitecte de la novelÂ·la. Analitza la coherÃ¨ncia i consistÃ¨ncia de tota l'obra.", Object.assign({}, userConfig, { model: models.modelArquitecte, maxTokens: 4000 }), 'revisio');
  const dades = parseJsonRobust(res);
  ESTAT._revisioFinalApp = dades;
}

async function iniciarRevisioGlobal() {
  const loaderEl  = document.getElementById('revisio-global-loader');
  const resultEl  = document.getElementById('revisio-global-result');
  const reescrEl  = document.getElementById('revisio-global-reescriptures');
  const btnControl= document.getElementById('btn-control-arcs');

  loaderEl.classList.remove('hidden');
  resultEl.classList.add('hidden');
  reescrEl.innerHTML = '';
  btnControl.classList.add('hidden');

  try {
    const res     = await revisioGlobalOpusAPI(USER_CONFIG);
    const dades   = parseJsonRobust(res.response);
    ESTAT._revisioGlobal = dades;
    loaderEl.classList.add('hidden');
    const repeticions = detectarRepeticions();
    if (repeticions) mostrarRepeticions(repeticions);
    mostrarResultatRevisioGlobal(dades);
  } catch (err) {
    loaderEl.classList.add('hidden');
    resultEl.innerHTML = `<div style="padding:12px;background:var(--surface2);border-radius:8px;color:var(--text2);font-size:.85rem;">RevisiÃ³ global no disponible: ${escHtml(err.message)}</div>`;
    resultEl.classList.remove('hidden');
    btnControl.classList.remove('hidden');
    toast('RevisiÃ³ global: ' + err.message);
  }
}

function mostrarResultatRevisioGlobal(dades) {
  const resultEl = document.getElementById('revisio-global-result');
  const reescrEl = document.getElementById('revisio-global-reescriptures');
  const btnControl= document.getElementById('btn-control-arcs');

  if (!dades) {
    btnControl.classList.remove('hidden');
    return;
  }

  const puntuacio = dades.puntuacio_global !== undefined ? dades.puntuacio_global : '?';
  const color = typeof puntuacio === 'number'
    ? (puntuacio >= 8 ? 'var(--success)' : puntuacio >= 6 ? 'var(--warning)' : '#f87171')
    : 'var(--text2)';

  const problemes = Array.isArray(dades.problemes) ? dades.problemes : [];
  const capitolsReescriure = Array.isArray(dades.capitols_a_reescriure) ? dades.capitols_a_reescriure : [];
  const prefsPendents = Array.isArray(dades.prefiguracions_pendents) ? dades.prefiguracions_pendents : [];

  const problemesHtml = problemes.length > 0
    ? `<div style="margin-top:10px;">
        <div style="font-size:.78rem;font-weight:700;text-transform:uppercase;letter-spacing:.06em;color:var(--text2);margin-bottom:6px;">Problemes detectats:</div>
        ${problemes.map(p => {
          const grav = p.gravetat === 'alta' ? '#f87171' : p.gravetat === 'mitja' ? 'var(--warning)' : 'var(--text2)';
          return `<div style="padding:7px 12px;border-left:2px solid ${grav};margin-bottom:5px;font-size:.83rem;">
            <strong style="color:var(--text);">Cap. ${p.capitol || '?'} [${escHtml(p.tipus || '')}]:</strong> ${escHtml(p.descripcio || '')}
          </div>`;
        }).join('\n')}
      </div>` : '';

  const prefsHtml = prefsPendents.length > 0
    ? `<div style="margin-top:10px;">
        <div style="font-size:.78rem;font-weight:700;text-transform:uppercase;letter-spacing:.06em;color:var(--text2);margin-bottom:6px;">Prefiguracions pendents:</div>
        ${prefsPendents.map(p => `<div style="padding:5px 12px;border-left:2px solid var(--warning);margin-bottom:4px;font-size:.82rem;">${escHtml(p)}</div>`).join('\n')}
      </div>` : '';

  resultEl.innerHTML = `
    <div style="background:var(--surface2);border:1px solid var(--border);border-radius:10px;padding:18px 22px;">
      <div style="display:flex;align-items:center;gap:16px;margin-bottom:12px;">
        <div style="font-size:1.8rem;font-weight:700;color:${color};">${puntuacio}<span style="font-size:1rem;color:var(--text2);">/10</span></div>
        <div>
          <div style="font-weight:600;color:var(--text);">RevisiÃ³ Global Opus</div>
          <div style="font-size:.78rem;color:var(--text2);">${dades.veu_consistent ? 'âœ“ Veu consistent' : 'âš  InconsistÃ¨ncies de veu detectades'}</div>
        </div>
      </div>
      ${dades.veredicte ? `<div style="font-size:.88rem;color:var(--text);line-height:1.65;padding:10px 14px;background:var(--surface);border-radius:6px;margin-bottom:8px;">${escHtml(dades.veredicte)}</div>` : ''}
      ${problemesHtml}
      ${prefsHtml}
    </div>`;
  resultEl.classList.remove('hidden');

  // Botons de reescriptura per als capÃ­tols problemÃ tics
  if (capitolsReescriure.length > 0) {
    // Guardem les instruccions a ESTAT per evitar passar JSON complex via onclick
    ESTAT._instruccionsReescripturaGlobal = dades.instruccions_reescriptura || {};
    reescrEl.innerHTML = `
      <div style="width:100%;font-size:.82rem;color:var(--text2);margin-bottom:6px;">Opus suggereix reescriure els capÃ­tols:</div>
      ${capitolsReescriure.map(numCap => {
        const idx = numCap - 1;
        return `<button class="btn btn-secondary" data-cap-idx="${idx}" onclick="reescriureCapitolGlobal(${idx})">
          âœï¸ Reeditar Cap. ${numCap}
        </button>`;
      }).join('\n')}`;
  }

  // --- INICI BOTÃ“ META-ENGINYERIA ---
  const divMeta = document.createElement('div');
  divMeta.style.marginTop = "20px";
  divMeta.innerHTML = `
    <button class="btn btn-ghost" style="width:100%; border:1px dashed var(--accent2); color:var(--accent2); font-weight:600;" onclick="generarPromptMetaCodi()">
      âš™ï¸ L'app falla? Genera un prompt d'Arquitectura per millorar el codi font
    </button>
    <div id="meta-codi-resultat" class="hidden" style="margin-top:14px;"></div>
  `;
  resultEl.appendChild(divMeta);
  // --- FI BOTÃ“ META-ENGINYERIA ---

  btnControl.classList.remove('hidden');
}

async function generarPromptMetaCodi() {
  const resultDiv = document.getElementById('meta-codi-resultat');
  resultDiv.classList.remove('hidden');
  resultDiv.innerHTML = `<div style="color:var(--text2);font-size:.9rem; display:flex; align-items:center; gap:8px;">
    <div class="spinner" style="width:16px; height:16px; border-width:2px;"></div>
    L'app estÃ  llegint la seva prÃ²pia lÃ²gica JS i dissenyant una millora d'arquitectura...
  </div>`;

  try {
    // 1. OPTIMITZACIÃ“: Extraiem nomÃ©s la lÃ²gica JavaScript (estalvi brutal de tokens)
    const codiJS = Array.from(document.scripts)
      .map(script => script.innerText)
      .filter(text => text.trim().length > 0)
      .join('\n\n// --- SEGÃœENT BLOC DE SCRIPT ---\n\n');

    // 2. RECUPEREM ELS PROBLEMES NARRATIUS DETECTATS
    const problemes = ESTAT._revisioGlobal ? ESTAT._revisioGlobal.problemes : [];
    const textProblemes = problemes.length > 0
      ? JSON.stringify(problemes, null, 2)
      : "IncoherÃ¨ncies generals de continuÃ¯tat i ritme detectades al text.";

    // 3. PROMPT PER A L'IA (Actuant com a Arquitecte de Sistemes)
    const promptEnginyer = `Ets un Arquitecte de Software de Sistemes IA (Agentic Workflows).

Aquesta Ã©s la lÃ²gica JavaScript de la meva aplicaciÃ³ (Booki):
<codi_app_js>
${codiJS}
</codi_app_js>

En executar aquesta app per escriure una novelÂ·la, l'editor intern ha detectat aquests errors recurrents:
<errors_narratius>
${textProblemes}
</errors_narratius>

LA TEVA TASCA:
Dissenya una MILLORA ARQUITECTÃ’NICA GENÃˆRICA al codi JS que solucioni aquest tipus d'errors d'arrel per sempre. No solucionis nomÃ©s el sÃ­mptoma actual (ex: si el personatge oblida que estÃ  ferit, no demanis un camp "ferides", demana un mÃ²dul de persistÃ¨ncia d'estats fÃ­sics al NKG).

Genera un PROMPT MESTRE que jo pugui copiar i enganxar al meu assistent de codi (Cursor/Codex) per implementar la teva soluciÃ³.
El prompt ha de:
1. Explicar breument el problema sistÃ¨mic detectat al codi.
2. Definir la nova arquitectura proposada.
3. Donar instruccions tÃ¨cniques clares sobre quines funcions JavaScript exactes s'han de modificar i com.

Retorna EXCLUSIVAMENT el text del prompt llest per copiar i enganxar, escrit en catalÃ .`;

    // 4. CRIDA AL MODEL (Opus)
    const msgs = [{ role: 'user', content: promptEnginyer }];
    const models = getModelConfig(USER_CONFIG);

    const respostaLLM = await callLLMMulti(
      msgs,
      "Ets un Enginyer de Software Meta-AnalÃ­tic.",
      Object.assign({}, USER_CONFIG, { maxTokens: 4000, model: models.modelArquitecte }),
      'arquitectura'
    );

    // 5. MOSTRAR EL RESULTAT PER COPIAR
    resultDiv.innerHTML = `
      <div style="background:var(--surface); border:1px solid var(--border); border-radius:8px; padding:16px; margin-top:14px;">
        <div style="font-weight:600; color:var(--success); margin-bottom:10px; display:flex; justify-content:space-between;">
          <span>âœ… Prompt d'Arquitectura generat</span>
          <span style="font-size:.8rem; font-weight:normal; color:var(--text2);">Copia'l i enganxa'l al teu editor</span>
        </div>
        <textarea style="width:100%; height:280px; background:var(--surface2); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:12px; font-family:monospace; font-size:.85rem; resize:vertical; line-height:1.5;" readonly onclick="this.select()">${escHtml(respostaLLM)}</textarea>
      </div>
    `;

  } catch (err) {
    resultDiv.innerHTML = `<div style="color:#f87171; background:rgba(248,113,113,0.1); padding:10px; border-radius:6px; margin-top:10px; font-size:.9rem;">âš ï¸ Error generant el prompt: ${err.message}</div>`;
  }
}

async function reescriureCapitolGlobal(idx) {
  if (!ESTAT._capitols_generats[idx]) { toast('CapÃ­tol no disponible.'); return; }

  // Llegim les instruccions del mapa guardat per Opus (pot ser buit si Opus no les va donar)
  const instruccions = (ESTAT._instruccionsReescripturaGlobal && ESTAT._instruccionsReescripturaGlobal[String(idx + 1)]) || '';

  // Deshabilitem el botÃ³ que s'ha premut
  const reescrEl = document.getElementById('revisio-global-reescriptures');
  const btn = reescrEl && reescrEl.querySelector(`[data-cap-idx="${idx}"]`);
  if (btn) { btn.disabled = true; btn.textContent = `â³ Reescrivint Cap. ${idx + 1}â€¦`; }

  // Amagatem el panell de revisiÃ³ global i mostrem el loader
  document.getElementById('btn-control-arcs-wrap').classList.add('hidden');
  document.getElementById('capitol-actual-wrap').classList.add('hidden');
  document.getElementById('revisio-panel').classList.add('hidden');
  showLoader(11);
  document.getElementById('loader-11-text').textContent = `ğŸŸ£ Sonnet reescrivint el CapÃ­tol ${idx + 1}â€¦`;

  try {
    const res = await reescriureCapitolAmbInstruccions(idx, instruccions, USER_CONFIG);
    const textNet = netejarTabulacionsInicials(res.response);
    ESTAT._capitols_generats[idx] = textNet;
    renderLlistaCapitols();
    hideLoader(11);
    mostrarCapitol(idx, textNet);

    // Tornem a mostrar el panell de revisiÃ³ global amb el capÃ­tol reescrit marcat i botÃ³ per re-avaluar
    document.getElementById('btn-control-arcs-wrap').classList.remove('hidden');
    if (reescrEl) {
      if (btn) {
        btn.disabled = true;
        btn.textContent = `âœ“ Cap. ${idx + 1} reescrit`;
        btn.classList.remove('btn-secondary');
        btn.classList.add('btn-ghost');
      }
      // Afegim/actualitzem el botÃ³ de nova revisiÃ³ global
      let reavBtn = document.getElementById('btn-nova-revisio-global');
      if (!reavBtn) {
        reavBtn = document.createElement('button');
        reavBtn.id = 'btn-nova-revisio-global';
        reavBtn.className = 'btn btn-primary';
        reavBtn.style.cssText = 'width:100%;margin-top:12px;';
        reavBtn.onclick = iniciarRevisioGlobal;
        reescrEl.appendChild(reavBtn);
      }
      reavBtn.textContent = 'ğŸ”„ Nova RevisiÃ³ Global del Llibre';
    }
    toast(`âœ“ CapÃ­tol ${idx + 1} reescrit amb millores literÃ ries.`);
  } catch (err) {
    hideLoader(11);
    document.getElementById('btn-control-arcs-wrap').classList.remove('hidden');
    document.getElementById('capitol-actual-wrap').classList.remove('hidden');
    if (btn) { btn.disabled = false; btn.textContent = `âœï¸ Reeditar Cap. ${idx + 1}`; }
    toast('Error en reeditar: ' + err.message);
  }
}

// â”€â”€â”€ SISTEMA 1: BÃ­blia Narrativa â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function obrirBiblia() {
  const modal = document.getElementById('modal-biblia');
  const cos   = document.getElementById('biblia-cos');
  const b     = ESTAT.bibliaNarrativa;

  let html = '';
  if (b.regles_mon && b.regles_mon.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸŒ Regles del MÃ³n</h4><ul style="padding-left:18px">${b.regles_mon.map(r => `<li style="margin-bottom:4px">${r}</li>`).join('\n')}</ul>`;
  }
  if (b.llocs_importants && b.llocs_importants.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ“ Llocs Importants</h4><ul style="padding-left:18px">${b.llocs_importants.map(l => `<li style="margin-bottom:4px"><strong>${l.nom}</strong>: ${l.descripcio}</li>`).join('\n')}</ul>`;
  }
  if (b.objectes_clau && b.objectes_clau.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ”‘ Objectes Clau</h4><ul style="padding-left:18px">${b.objectes_clau.map(o => `<li style="margin-bottom:4px"><strong>${o.nom}</strong>: ${o.significat}</li>`).join('\n')}</ul>`;
  }
  if (b.fitxes_personatges && b.fitxes_personatges.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ‘¤ Personatges</h4>`;
    b.fitxes_personatges.forEach(p => {
      html += `<div style="background:var(--surface2);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:10px">
        <strong style="color:var(--accent)">${p.nom}</strong>
        ${p.estat_actual  ? `<div style="font-size:.85rem;color:var(--text2);margin-top:4px">Estat: ${p.estat_actual}</div>` : ''}
        ${p.motivacions   ? `<div style="font-size:.85rem;margin-top:4px">Motivacions: ${p.motivacions}</div>` : ''}
        ${p.secrets       ? `<div style="font-size:.85rem;color:var(--warning);margin-top:4px">Secrets: ${p.secrets}</div>` : ''}
      </div>`;
    });
  }
  if (b.fets_canonics && b.fets_canonics.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ“œ Fets CanÃ²nics</h4><ul style="padding-left:18px">${b.fets_canonics.slice(-10).map(f => `<li style="margin-bottom:4px">${f}</li>`).join('\n')}</ul>`;
  }
  if (!html) {
    html = '<p style="color:var(--text2);text-align:center;padding:24px">La bÃ­blia narrativa encara no s\'ha inicialitzat.</p>';
  }
  cos.innerHTML = html;
  modal.classList.remove('hidden');
}

function tancarModalBiblia() {
  document.getElementById('modal-biblia').classList.add('hidden');
}

async function regenerarBibliaNarrativa() {
  const btn = document.getElementById('btn-regenerar-biblia');
  if (btn) { btn.disabled = true; btn.textContent = 'â³ Regenerantâ€¦'; }
  try {
    await inicialitzarBiblia(USER_CONFIG);
    await completarBibliaPersonatges(USER_CONFIG);
    obrirBiblia();
    toast('âœ“ BÃ­blia Narrativa regenerada.');
  } catch (err) {
    toast('Error regenerant la bÃ­blia: ' + err.message);
  } finally {
    if (btn) { btn.disabled = false; btn.textContent = 'ğŸ”„ Regenerar'; }
  }
}

function normalitzarFetsCanonics(fets) {
  if (!Array.isArray(fets)) return [];
  return [...new Set(
    fets
      .map(f => typeof f === 'string' ? f : (f && typeof f.descripcio === 'string' ? f.descripcio : ''))
      .map(f => String(f || '').trim())
      .filter(Boolean)
  )];
}

function aplicarCanvisBiblia(canvis) {
  if (!canvis) return;
  const b = ESTAT.bibliaNarrativa;
  const fetsNous = normalitzarFetsCanonics([...(canvis.nous_fets_canonics || []), ...(canvis.fets_canonics || [])]);
  if (fetsNous.length > 0) {
    b.fets_canonics = normalitzarFetsCanonics([...(b.fets_canonics || []), ...fetsNous]);
  }
  if (canvis.actualitzar_personatges && canvis.actualitzar_personatges.length > 0) {
    canvis.actualitzar_personatges.forEach(upd => {
      const fitxa = (b.fitxes_personatges || []).find(f => f.nom === upd.nom);
      if (fitxa) {
        if (upd.nou_estat)    fitxa.estat_actual = upd.nou_estat;
        if (upd.nous_secrets) fitxa.secrets      = upd.nous_secrets;
        if (upd.motivacions)  fitxa.motivacions  = upd.motivacions;
      } else if (upd.nom) {
        b.fitxes_personatges = b.fitxes_personatges || [];
        b.fitxes_personatges.push({ nom: upd.nom, estat_actual: upd.nou_estat, motivacions: upd.motivacions, secrets: upd.nous_secrets });
      }
    });
  }
  if (canvis.nous_llocs && canvis.nous_llocs.length > 0) {
    b.llocs_importants = (b.llocs_importants || []).concat(canvis.nous_llocs);
  }
  if (canvis.nous_objectes && canvis.nous_objectes.length > 0) {
    b.objectes_clau = (b.objectes_clau || []).concat(canvis.nous_objectes);
  }
}

// â”€â”€â”€ SISTEMA 2: Fase de Trames â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function iniciarFaseTrames() {
  showCard('fase-9-5');
  updateProgress(9.5);
  showLoader('9-5');
  document.getElementById('trames-result').classList.add('hidden');
  try {
    const res   = await generarTrames(USER_CONFIG);
    const dades = parseJsonRobust(res.response);
    if (dades) {
      ESTAT.trames.trama_principal  = dades.trama_principal  || null;
      ESTAT.trames.subtrames        = dades.subtrames        || [];
      ESTAT.trames.mapa_entrellacat = dades.mapa_entrellacat || [];

      // Retry: si el mapa estÃ  incomplet, completar-lo per separat
      const capsEsperats = ESTAT._nombreCapitols || 12;
      if (!dades.mapa_entrellacat || dades.mapa_entrellacat.length < capsEsperats) {
        console.warn(`Mapa entrellaÃ§at incomplet: ${(dades.mapa_entrellacat||[]).length}/${capsEsperats}. Regenerant...`);
        document.getElementById('loader-9-5-text').textContent = 'ğŸ”µ Completant mapa de tramesâ€¦';
        try {
          const mapaRes = await completarMapaTrames(dades, capsEsperats, USER_CONFIG);
          const mapaDades = parseJsonRobust(mapaRes.response);
          if (mapaDades && mapaDades.mapa_entrellacat && mapaDades.mapa_entrellacat.length >= capsEsperats) {
            ESTAT.trames.mapa_entrellacat = mapaDades.mapa_entrellacat;
            dades.mapa_entrellacat = mapaDades.mapa_entrellacat;
          }
        } catch (retryErr) {
          console.warn('Retry mapa trames: ' + retryErr.message);
        }
      }
    }
    mostrarTrames(res.response, dades);
  } catch (err) {
    hideLoader('9-5');
    alert('Error generant les trames: ' + err.message);
  }
}

function mostrarTrames(textOriginal, dades) {
  hideLoader('9-5');
  const result = document.getElementById('trames-result');
  const cos    = document.getElementById('trames-cos');
  if (!dades) {
    cos.innerHTML = `<pre style="white-space:pre-wrap;font-size:.85rem;color:var(--text2)">${textOriginal}</pre>`;
    result.classList.remove('hidden');
    return;
  }
  let html = '';
  if (dades.trama_principal) {
    const tp = dades.trama_principal;
    html += `<div style="background:var(--surface2);border:1px solid var(--accent);border-radius:10px;padding:16px;margin-bottom:16px">
      <div style="font-weight:700;color:var(--accent2);margin-bottom:8px">ğŸ¯ Trama Principal</div>
      <div style="font-size:.95rem">${tp.descripcio || tp}</div>
      ${tp.conflicte_central ? `<div style="font-size:.85rem;color:var(--text2);margin-top:6px">Conflicte: ${tp.conflicte_central}</div>` : ''}
      ${tp.arc_protagonista  ? `<div style="font-size:.85rem;color:var(--text2);margin-top:4px">Arc: ${tp.arc_protagonista}</div>`   : ''}
    </div>`;
  }
  if (dades.subtrames && dades.subtrames.length > 0) {
    html += `<div style="font-weight:600;color:var(--accent2);margin-bottom:10px">ğŸ•¸ï¸ Subtrames (${dades.subtrames.length})</div>`;
    dades.subtrames.forEach((st, i) => {
      html += `<div style="background:var(--surface2);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:10px">
        <div style="font-weight:600;color:var(--text)">${i + 1}. ${st.nom || 'Subtrama ' + (i + 1)}</div>
        <div style="font-size:.88rem;color:var(--text2);margin-top:4px">${st.descripcio || ''}</div>
        ${st.personatges_implicats ? `<div style="font-size:.83rem;margin-top:6px;color:var(--accent2)">Personatges: ${Array.isArray(st.personatges_implicats) ? st.personatges_implicats.join(', ') : st.personatges_implicats}</div>` : ''}
        ${st.com_entrellaÃ§a ? `<div style="font-size:.83rem;margin-top:4px;color:var(--text2)">Trama principal: ${st.com_entrellaÃ§a}</div>` : ''}
      </div>`;
    });
  }
  if (dades.mapa_entrellacat && dades.mapa_entrellacat.length > 0) {
    html += `<div style="font-weight:600;color:var(--accent2);margin:12px 0 8px">ğŸ—ºï¸ Mapa d'EntrellaÃ§at</div>
    <div style="font-size:.85rem;color:var(--text2)">`;
    dades.mapa_entrellacat.forEach(m => {
      html += `<div style="margin-bottom:4px">Cap. ${m.capitol}: ${m.trames_actives ? m.trames_actives.join(' + ') : (m.notes || '')}</div>`;
    });
    html += '</div>';
  }
  cos.innerHTML = html || `<pre style="white-space:pre-wrap;font-size:.85rem">${textOriginal}</pre>`;
  result.classList.remove('hidden');
}

// â”€â”€â”€ SISTEMA 4: Checkpoint de coherÃ¨ncia â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function mostrarCheckpoint(dades, idx) {
  if (!dades) return;
  const listId   = 'capitols-list';
  const container = document.getElementById(listId) || document.body;
  const panel    = document.createElement('div');
  panel.style.cssText = 'background:var(--surface2);border:2px solid var(--warning);border-radius:12px;padding:18px;margin:16px 0';
  const punts  = dades.puntuacio_coherencia;
  const color  = punts >= 7 ? 'var(--success)' : (punts >= 5 ? 'var(--warning)' : '#f87171');
  panel.innerHTML = `
    <div style="font-weight:700;color:var(--warning);margin-bottom:10px">ğŸ” Checkpoint de CoherÃ¨ncia â€” Cap. ${idx + 1}</div>
    <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px">
      <div style="font-size:2rem;font-weight:700;color:${color}">${punts || '?'}/10</div>
      <div style="font-size:.9rem;color:var(--text2)">${dades.valoracio_general || ''}</div>
    </div>
    ${dades.problemes_detectats && dades.problemes_detectats.length > 0
      ? `<div style="font-weight:600;color:#f87171;margin-bottom:6px">âš ï¸ Problemes detectats</div>
         <ul style="padding-left:18px;font-size:.88rem;color:var(--text2)">${dades.problemes_detectats.map(p => `<li style="margin-bottom:4px">${p}</li>`).join('\n')}</ul>`
      : '<div style="color:var(--success);font-size:.9rem">âœ“ CoherÃ¨ncia correcta fins ara</div>'}
    ${dades.recomanacions && dades.recomanacions.length > 0
      ? `<div style="font-weight:600;color:var(--accent2);margin:10px 0 6px">ğŸ’¡ Recomanacions per als prÃ²xims capÃ­tols</div>
         <ul style="padding-left:18px;font-size:.88rem">${dades.recomanacions.map(r => `<li style="margin-bottom:4px">${r}</li>`).join('\n')}</ul>`
      : ''}
  `;
  container.appendChild(panel);
  if (dades.ajustos_rumb) {
    ESTAT._ajustosRumb = dades.ajustos_rumb;
  }
}

// â”€â”€â”€ SISTEMA 3: Millorar Cliffhanger â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function millorarCliffhanger(idx, instruccions) {
  if (!instruccions) return;
  const btn = event && event.target ? event.target : null;
  if (btn) { btn.disabled = true; btn.textContent = 'â³ Millorantâ€¦'; }
  try {
    ESTAT._revisioInstruccions = ESTAT._revisioInstruccions || {};
    ESTAT._revisioInstruccions[idx] = instruccions;
    await reescriureCapitol(idx);
    if (btn) { btn.textContent = 'âœ“ Cliffhanger millorat'; }
  } catch (err) {
    if (btn) { btn.disabled = false; btn.textContent = 'ğŸ£ Millorar cliffhanger'; }
    alert('Error: ' + err.message);
  }
}

function mostrarRepeticions(reps) {
  const div = document.getElementById('revisio-global-result');
  if (!div) return;
  let html = '<div style="margin-top:16px;padding:12px;background:#fff3cd;border-radius:8px;">';
  html += '<h3>ğŸ” Expressions Repetides Detectades</h3>';
  if (reps.trigrames && reps.trigrames.length > 0) {
    html += '<p><strong>Trigrames (3+ capÃ­tols):</strong> ' + reps.trigrames.slice(0,10).map(([ng,c]) => `"${escHtml(ng)}" (${c})`).join(', ') + '</p>';
  }
  if (reps.bigrames && reps.bigrames.length > 0) {
    html += '<p><strong>Bigrames (3+ capÃ­tols):</strong> ' + reps.bigrames.slice(0,10).map(([ng,c]) => `"${escHtml(ng)}" (${c})`).join(', ') + '</p>';
  }
  html += '</div>';
  div.insertAdjacentHTML('beforeend', html);
}
</script>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     BACKEND LOCAL â€” migrat de codigo.gs
     Canvis respecte a l'original:
       Â· Eliminada la funciÃ³ doGet()
       Â· callLLM, callAnthropic, callOpenAI, callGemini â†’ async
       Â· UrlFetchApp.fetch() â†’ await fetch() (API estÃ ndard del navegador)
       Â· parseJsonResponse â†’ async, usa response.status i await response.text()
       Â· Afegit CORS_PROXY per a Anthropic (evita errors CORS des del navegador)
       Â· Totes les funcions de fase â†’ async/await callLLM
       Â· exportarADoc â†’ descÃ rrega local via Blob + URL.createObjectURL (sense DocumentApp)
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>

// â”€â”€â”€ CORS per a Anthropic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Anthropic suporta crides directes des del navegador afegint la capÃ§alera
// 'anthropic-dangerous-direct-browser-access: true'.
// AixÃ² elimina la necessitat de qualsevol proxy extern.

// â”€â”€â”€ URLs i models per defecte â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PROVIDER_DEFAULTS = {
  anthropic: {
    apiUrl: 'https://api.anthropic.com/v1/messages',
    model: 'claude-opus-4-1'
  },
  openai: {
    apiUrl: 'https://api.openai.com/v1/chat/completions',
    model: 'gpt-4o'
  },
  gemini: {
    apiUrlBase: 'https://generativelanguage.googleapis.com/v1beta/models',
    model: 'gemini-1.5-pro'
  }
};

// â”€â”€â”€ Parseig de la resposta fetch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Equivalent a parseJsonResponse de GAS, adaptat a l'API fetch:
//   Â· rawResponse.status       en lloc de rawResponse.getResponseCode()
//   Â· await rawResponse.text() en lloc de rawResponse.getContentText()
async function parseJsonResponse(rawResponse, providerName) {
  const statusCode = rawResponse.status;
  const rawText    = await rawResponse.text() || '';
  let parsed;
  try {
    parsed = JSON.parse(rawText);
  } catch (e) {
    // Resposta no JSON: pot ser pÃ gina HTML del proxy o error de xarxa
    const preview = rawText.slice(0, 300).replace(/\s+/g, ' ');
    throw new Error(
      `${providerName} HTTP ${statusCode} â€” resposta no JSON del proxy.\n` +
      `Comprova la consola del navegador (F12) per mÃ©s detalls.\n` +
      `Inici de la resposta: ${preview}`
    );
  }
  if (statusCode >= 400) {
    const message = parsed && parsed.error
      ? (parsed.error.message || JSON.stringify(parsed.error))
      : rawText.slice(0, 300);
    throw new Error(`${providerName} HTTP ${statusCode}: ${message}`);
  }
  return parsed;
}

// â”€â”€â”€ fetchSegur: fetch amb backoff exponencial â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Substitueix fetch() directe per a totes les crides LLM.
// Reintenta automÃ ticament si l'API retorna 429, 503 o 529.
async function fetchSegur(url, options, maxIntents = 4) {
  const RETRYABLE = new Set([429, 503, 529]);
  for (let intent = 0; intent < maxIntents; intent++) {
    const response = await fetch(url, options);
    if (!RETRYABLE.has(response.status)) return response;
    if (intent === maxIntents - 1) return response; // Ãºltim intent: retorna per deixar parseJsonResponse gestionar l'error
    const delayMs = Math.pow(2, intent) * 10000; // 10s â†’ 20s â†’ 40s â†’ 80s
    console.warn(`[fetchSegur] HTTP ${response.status} â€” reintent ${intent + 1}/${maxIntents - 1} en ${delayMs / 1000}s...`);
    await new Promise(resolve => setTimeout(resolve, delayMs));
  }
}

// â”€â”€â”€ analitzarRespostaGenerica: parser estandarditzat â”€â”€â”€â”€â”€â”€â”€â”€
// Extreu text i detecta tall per lÃ­mit de tokens de forma
// agnÃ²stica al proveÃ¯dor. Retorna { text, textIncomplet }.
function analitzarRespostaGenerica(respostaJSON, proveidor) {
  let text = '';
  let textIncomplet = false;

  if (proveidor === 'anthropic') {
    text = Array.isArray(respostaJSON.content)
      ? respostaJSON.content.filter(p => p && p.type === 'text').map(p => p.text || '').join('\n')
      : '';
    textIncomplet = respostaJSON.stop_reason === 'max_tokens';

  } else if (proveidor === 'openai') {
    const firstChoice = respostaJSON.choices && respostaJSON.choices[0];
    const content = firstChoice && firstChoice.message ? firstChoice.message.content : '';
    text = extractContentText(content);
    textIncomplet = !!(firstChoice && firstChoice.finish_reason === 'length');

  } else if (proveidor === 'google' || proveidor === 'gemini') {
    const firstCandidate = respostaJSON.candidates && respostaJSON.candidates[0];
    if (firstCandidate && firstCandidate.finishReason === 'SAFETY') {
      throw new Error('Gemini ha bloquejat la resposta per filtres de seguretat extrems. Prova amb un fragment menys sensible.');
    }
    const parts = firstCandidate && firstCandidate.content ? firstCandidate.content.parts : [];
    text = Array.isArray(parts) ? parts.map(p => (p && p.text) ? p.text : '').join('\n') : '';
    textIncomplet = !!(firstCandidate && firstCandidate.finishReason === 'MAX_TOKENS');

  } else {
    throw new Error(`analitzarRespostaGenerica: proveidor desconegut "${proveidor}"`);
  }

  return { text: normalizeLLMText(text), textIncomplet };
}

// â”€â”€â”€ Helpers per llegir max_output del registre â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getMaxTokens(safeConfig, modelId) {
  if (safeConfig.maxTokens) return safeConfig.maxTokens;
  const entry = MODEL_REGISTRY[modelId];
  return (entry && entry.max_output) || 4096;
}

// â”€â”€â”€ Router multi-proveÃ¯dor i multi-rol â€” v5.1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// tag: 'generacio' | 'arquitecte' | 'arquitectura'
// config._esDraft: true â†’ usa model Draft (Haiku o equivalent)
// config.model: override explÃ­cit del model (mÃ xima prioritat)
function normalizeProviderId(provider) {
  const p = String(provider || '').toLowerCase().trim();
  if (p === 'google-gemini' || p === 'google') return 'gemini';
  return p;
}

function getProviderPerRol(config, tag) {
  const cfg = config || {};
  const isArq = (tag === 'arquitecte' || tag === 'arquitectura');
  const roleProvider = isArq
    ? (cfg.providerArquitectura || cfg.provider_arq)
    : (cfg.providerGeneracio || cfg.provider_gen || cfg.providerDraft);
  return normalizeProviderId(roleProvider || cfg.provider || 'anthropic');
}

function getModelIdPerRol(config, tag) {
  const cfg = config || {};
  const isArq = (tag === 'arquitecte' || tag === 'arquitectura');

  if (isArq) {
    return cfg.modelArquitectura || cfg.modelArquitecte || cfg.model;
  }

  if (cfg._esDraft) {
    return cfg.modelDraft || cfg.modelHaiku || cfg.model;
  }

  return cfg.modelGeneracio || cfg.model;
}

function getProviderAndModelPerRol(config, tag) {
  const modelId = getModelIdPerRol(config, tag);
  let proveidor = getProviderPerRol(config, tag);
  const reg = MODEL_REGISTRY[modelId];
  const providerDelModel = normalizeProviderId(reg && reg.proveidor);

  // Si model i provider no coincideixen, prioritzem el proveÃ¯dor real del model.
  if (providerDelModel && providerDelModel !== proveidor) {
    console.warn(`[LLM Router] Provider ajustat per coherÃ¨ncia model/proveÃ¯dor: ${proveidor} -> ${providerDelModel} (model: ${modelId})`);
    proveidor = providerDelModel;
  }

  return { modelId, proveidor };
}

async function callLLMMulti(messages, systemPrompt, config, tag) {
  const safeConfig = config || {};

  // Assignem el model segons si la tasca Ã©s d'arquitectura o de generaciÃ³
  const { modelId, proveidor } = getProviderAndModelPerRol(safeConfig, tag);

  // Obtenim la clau API corresponent
  let apiKey;
  if (proveidor === 'anthropic') apiKey = ESTAT._anthropicApiKey || safeConfig.apiKey;
  if (proveidor === 'google' || proveidor === 'gemini') apiKey = ESTAT._geminiApiKey || safeConfig.apiKey;
  if (proveidor === 'openai') apiKey = ESTAT._openaiApiKey || safeConfig.apiKey;

  if (!apiKey) throw new Error(`Cal una clau API per al proveÃ¯dor: ${proveidor}`);

  const maxTokens = getMaxTokens(safeConfig, modelId);

  // Enrutem directament al proveÃ¯dor triat amb el text lliure del model
  if (proveidor === 'anthropic') return await callAnthropic(messages, systemPrompt, apiKey, modelId, maxTokens);
  if (proveidor === 'google' || proveidor === 'gemini') return await callGemini(messages, systemPrompt, apiKey, modelId, maxTokens);
  if (proveidor === 'openai') return await callOpenAI(messages, systemPrompt, apiKey, modelId, maxTokens);

  throw new Error(`ProveÃ¯dor desconegut: ${proveidor}`);
}

async function callLLMWithContinuation(messages, systemPrompt, config, tag, maxCont = 3) {
  const safeConfig = config || {};

  const { modelId, proveidor } = getProviderAndModelPerRol(safeConfig, tag);

  let apiKey;
  if (proveidor === 'anthropic') apiKey = ESTAT._anthropicApiKey || safeConfig.apiKey;
  if (proveidor === 'google' || proveidor === 'gemini') apiKey = ESTAT._geminiApiKey || safeConfig.apiKey;
  if (proveidor === 'openai') apiKey = ESTAT._openaiApiKey || safeConfig.apiKey;

  if (!apiKey) throw new Error(`Cal una clau API per al proveÃ¯dor: ${proveidor}`);

  const maxTokens = getMaxTokens(safeConfig, modelId);

  let fullText = '';
  let currentMessages = [...messages];

  for (let i = 0; i <= maxCont; i++) {
    let result;
    if (proveidor === 'anthropic') {
      result = await callAnthropicWithFinishReason(currentMessages, systemPrompt, apiKey, modelId, maxTokens);
    } else if (proveidor === 'google' || proveidor === 'gemini') {
      result = await callGeminiWithFinishReason(currentMessages, systemPrompt, apiKey, modelId, maxTokens);
    } else if (proveidor === 'openai') {
      result = await callOpenAIWithFinishReason(currentMessages, systemPrompt, apiKey, modelId, maxTokens);
    } else {
      throw new Error(`ProveÃ¯dor desconegut: ${proveidor}`);
    }

    fullText += result.text;

    if (!result.textIncomplet) break;

    console.log(`[callLLMWithContinuation] Text tallat (iteraciÃ³ ${i + 1}/${maxCont}), solÂ·licitant continuaciÃ³...`);
    currentMessages = [
      ...currentMessages,
      { role: 'assistant', content: result.text },
      { role: 'user', content: "El teu Ãºltim missatge s'ha tallat per lÃ­mits de longitud. Continua escrivint EXACTAMENT des de la teva Ãºltima lletra, sense introduccions ni disculpes." }
    ];
  }

  return fullText;
}

function textSemblaIncomplet(text) {
  const net = String(text || '').trim();
  if (!net) return true;
  if (net.length < 80) return true;
  const final = net.slice(-1);
  const tancaFrase = '.!?â€¦Â»â€"\'';
  if (!tancaFrase.includes(final)) return true;
  const opens = (net.match(/[\(\[\{"Â«]/g) || []).length;
  const closes = (net.match(/[\)\]\}"Â»]/g) || []).length;
  return opens > closes;
}

async function callLLMOneShotPlusCompletion(messages, systemPrompt, config, tag) {
  const safeConfig = config || {};

  const { modelId, proveidor } = getProviderAndModelPerRol(safeConfig, tag);
  let apiKey;
  if (proveidor === 'anthropic') apiKey = ESTAT._anthropicApiKey || safeConfig.apiKey;
  if (proveidor === 'google' || proveidor === 'gemini') apiKey = ESTAT._geminiApiKey || safeConfig.apiKey;
  if (proveidor === 'openai') apiKey = ESTAT._openaiApiKey || safeConfig.apiKey;
  if (!apiKey) throw new Error(`Cal una clau API per al proveÃ¯dor: ${proveidor}`);

  const maxTokens = getMaxTokens(safeConfig, modelId);

  let primera;
  if (proveidor === 'anthropic') {
    primera = await callAnthropicWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else if (proveidor === 'google' || proveidor === 'gemini') {
    primera = await callGeminiWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else if (proveidor === 'openai') {
    primera = await callOpenAIWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else {
    throw new Error(`ProveÃ¯dor desconegut: ${proveidor}`);
  }

  let text = primera.text || '';

  // Segona crida: nomÃ©s verificaciÃ³ de tancament (i, si cal, micro-completat).
  console.log('[callLLMOneShotPlusCompletion] Segona crida de validaciÃ³ final.');
  const missatgesTancament = [
    ...messages,
    { role: 'assistant', content: text },
    { role: 'user', content: `VERIFICACIÃ“ DE TANCAMENT (PASSADA 2):
Revisa l'Ãºltim parÃ graf que acabes d'escriure.
1. Si el text estÃ  perfectament tancat a nivell narratiu, no s'ha tallat a mitja frase i la longitud Ã©s l'adequada, respon EXACTAMENT amb la paraula: OK
2. Si el text s'ha tallat, ha quedat incomplet o necessita una expansiÃ³ final per tancar bÃ© l'escena/capÃ­tol, respon EXACTAMENT en aquest format:
APPEND: <escriu aquÃ­ la continuaciÃ³ directa des del punt exacte on t'has aturat, afegint el desenvolupament final necessari per tancar-ho amb excelÂ·lÃ¨ncia>.
No repeteixis res del que ja has escrit.` }
  ];
  const configTancament = Object.assign({}, safeConfig, { maxTokens: 220 });

  try {
    const revisio = (await callLLMMulti(missatgesTancament, systemPrompt, configTancament, tag) || '').trim();
    if (/^OK\s*$/i.test(revisio)) return text;

    const match = revisio.match(/^APPEND:\s*([\s\S]*)$/i);
    if (match && match[1] && match[1].trim()) {
      text += match[1].trimStart();
      return text;
    }

    // Fallback robust: nomÃ©s si el detector local veu final incomplet.
    if (primera.textIncomplet || textSemblaIncomplet(text)) {
      const rescat = await callLLMMulti([
        ...messages,
        { role: 'assistant', content: text },
        { role: 'user', content: "Completa NOMÃ‰S el tram final si havia quedat tallat. No repeteixis res. Escriu nomÃ©s el mÃ­nim per tancar correctament la frase o l'Ãºltim parÃ graf." }
      ], systemPrompt, Object.assign({}, safeConfig, { maxTokens: 240 }), tag);
      if (rescat && rescat.trim()) text += rescat;
    }
  } catch (err) {
    console.warn('[callLLMOneShotPlusCompletion] ValidaciÃ³ final fallida:', err.message);
  }

  return text;
}

async function callLLMOneShotConditionalCompletion(messages, systemPrompt, config, tag) {
  const safeConfig = config || {};

  const { modelId, proveidor } = getProviderAndModelPerRol(safeConfig, tag);
  let apiKey;
  if (proveidor === 'anthropic') apiKey = ESTAT._anthropicApiKey || safeConfig.apiKey;
  if (proveidor === 'google' || proveidor === 'gemini') apiKey = ESTAT._geminiApiKey || safeConfig.apiKey;
  if (proveidor === 'openai') apiKey = ESTAT._openaiApiKey || safeConfig.apiKey;
  if (!apiKey) throw new Error(`Cal una clau API per al proveÃ¯dor: ${proveidor}`);

  const maxTokens = getMaxTokens(safeConfig, modelId);

  let primera;
  if (proveidor === 'anthropic') {
    primera = await callAnthropicWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else if (proveidor === 'google' || proveidor === 'gemini') {
    primera = await callGeminiWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else if (proveidor === 'openai') {
    primera = await callOpenAIWithFinishReason(messages, systemPrompt, apiKey, modelId, maxTokens);
  } else {
    throw new Error(`ProveÃ¯dor desconegut: ${proveidor}`);
  }

  let text = primera.text || '';
  const necessitaTancament = primera.textIncomplet || textSemblaIncomplet(text);
  if (!necessitaTancament) return text;

  const missatgesTancament = [
    ...messages,
    { role: 'assistant', content: text },
    { role: 'user', content: `Continua el text exactament des d'on t'has aturat i tanca bÃ© el final.
INSTRUCCIONS ESTRICTES:
- NO repeteixis cap frase ni cap idea ja escrita
- NO resumeixis
- Afegeix nomÃ©s el mÃ­nim necessari per completar el capÃ­tol
- Acaba amb un final ben tancat` }
  ];

  const append = await callLLMMulti(
    missatgesTancament,
    systemPrompt,
    Object.assign({}, safeConfig, { maxTokens: 320 }),
    tag
  );

  if (append && append.trim()) text += append.trimStart();
  return text;
}



function parseEscenesUnificades(text, totalEscenes) {
  const net = String(text || '').replace(/\r/g, '').trim();
  const out = [];
  if (!net) return out;

  const re = /(?:^|\n)\[\[ESCENA_(\d+)\]\]\s*\n?/g;
  const marks = [];
  let m;
  while ((m = re.exec(net)) !== null) {
    marks.push({ idx: parseInt(m[1], 10), pos: m.index, len: m[0].length });
  }

  if (marks.length === 0) return out;

  for (let i = 0; i < marks.length; i++) {
    const curr = marks[i];
    const next = marks[i + 1];
    const start = curr.pos + curr.len;
    const end = next ? next.pos : net.length;
    const txt = net.slice(start, end).trim();
    if (!txt) continue;
    out.push({ escena: curr.idx, text: txt });
  }

  const uniq = {};
  out.forEach(e => { if (!uniq[e.escena]) uniq[e.escena] = e.text; });
  const ordered = Object.keys(uniq)
    .map(k => ({ escena: parseInt(k, 10), text: uniq[k] }))
    .sort((a, b) => a.escena - b.escena)
    .filter(e => e.escena >= 1 && e.escena <= Math.max(1, totalEscenes || 1));

  return ordered;
}

// â”€â”€â”€ Crida genÃ¨rica a LLM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// rol: 'generacio' (Sonnet) | 'arquitectura' (Opus) â€” nomÃ©s per a Anthropic
async function callLLM(messages, systemPrompt, config, rol) {
  rol = rol || 'generacio';
  const safeConfig = config || {};
  const provider   = String(safeConfig.provider || '').toLowerCase().trim();
  const apiKey     = safeConfig.apiKey;

  if (!provider) throw new Error('Falta el provider al config.');
  if (!apiKey)   throw new Error("Falta l'apiKey al config.");

  // SelecciÃ³ del model: si 'model' s'ha passat explÃ­citament com a override, prioritat mÃ xima
  let model;
  if (safeConfig.model) {
    model = safeConfig.model; // override explÃ­cit â€” prioritat mÃ xima (sistema hÃ­brid v5)
  } else if (rol === 'arquitectura' && provider === 'anthropic' && safeConfig.modelArquitectura) {
    model = safeConfig.modelArquitectura;
  } else {
    model = safeConfig.modelGeneracio ||
            (PROVIDER_DEFAULTS[provider] && PROVIDER_DEFAULTS[provider].model);
  }

  const maxTokens = getMaxTokens(safeConfig, model);

  if (provider === 'anthropic') return await callAnthropic(messages, systemPrompt, apiKey, model, maxTokens);
  if (provider === 'openai')    return await callOpenAI(messages, systemPrompt, apiKey, model, maxTokens);
  if (provider === 'gemini' || provider === 'google' || provider === 'google-gemini')
    return await callGemini(messages, systemPrompt, apiKey, model, maxTokens);

  throw new Error('Provider no suportat: ' + provider);
}

// â”€â”€â”€ Anthropic (Claude) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Crida directa des del navegador sense proxy extern.
// La capÃ§alera 'anthropic-dangerous-direct-browser-access' habilita CORS
// a l'API d'Anthropic per a Ãºs des del navegador (la clau queda al client,
// acceptable per a Ãºs personal/local).
async function callAnthropic(messages, systemPrompt, apiKey, model, maxTokens) {
  const payload = {
    model:      model || PROVIDER_DEFAULTS.anthropic.model,
    max_tokens: maxTokens,
    system:     systemPrompt || SYSTEM_DEFAULT,
    messages:   messages
  };

  const raw = await fetchSegur(PROVIDER_DEFAULTS.anthropic.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type':                              'application/json',
      'x-api-key':                                 apiKey,
      'anthropic-version':                         '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true'
    },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'Anthropic');
  if (result.error) throw new Error(result.error.message || "Error desconegut d'Anthropic.");
  return analitzarRespostaGenerica(result, 'anthropic').text;
}

async function callAnthropicWithFinishReason(messages, systemPrompt, apiKey, model, maxTokens) {
  const payload = {
    model:      model || PROVIDER_DEFAULTS.anthropic.model,
    max_tokens: maxTokens,
    system:     systemPrompt || SYSTEM_DEFAULT,
    messages:   messages
  };

  const raw = await fetchSegur(PROVIDER_DEFAULTS.anthropic.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type':                              'application/json',
      'x-api-key':                                 apiKey,
      'anthropic-version':                         '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true'
    },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'Anthropic');
  if (result.error) throw new Error(result.error.message || "Error desconegut d'Anthropic.");
  return analitzarRespostaGenerica(result, 'anthropic');
}

// â”€â”€â”€ OpenAI (GPT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// OpenAI permet CORS des del navegador amb la seva API pÃºblica,
// de manera que no cal proxy.
async function callOpenAI(messages, systemPrompt, apiKey, model, maxTokens) {
  const payload = {
    model:      model || PROVIDER_DEFAULTS.openai.model,
    messages:   buildOpenAIMessages(messages, systemPrompt),
    max_tokens: maxTokens
  };

  const raw = await fetchSegur(PROVIDER_DEFAULTS.openai.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type':  'application/json',
      'Authorization': 'Bearer ' + apiKey
    },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'OpenAI');
  if (result.error) throw new Error(result.error.message || "Error desconegut d'OpenAI.");
  return analitzarRespostaGenerica(result, 'openai').text;
}

async function callOpenAIWithFinishReason(messages, systemPrompt, apiKey, model, maxTokens) {
  const payload = {
    model:      model || PROVIDER_DEFAULTS.openai.model,
    messages:   buildOpenAIMessages(messages, systemPrompt),
    max_tokens: maxTokens
  };

  const raw = await fetchSegur(PROVIDER_DEFAULTS.openai.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type':  'application/json',
      'Authorization': 'Bearer ' + apiKey
    },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'OpenAI');
  if (result.error) throw new Error(result.error.message || "Error desconegut d'OpenAI.");
  return analitzarRespostaGenerica(result, 'openai');
}

// â”€â”€â”€ Google Gemini â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// La clau API va com a parÃ metre de query string a la URL,
// no cal capÃ§alera d'autenticaciÃ³ addicional.
async function callGemini(messages, systemPrompt, apiKey, model, maxTokens) {
  const finalModel = model || PROVIDER_DEFAULTS.gemini.model;
  const endpoint   = PROVIDER_DEFAULTS.gemini.apiUrlBase + '/' +
    encodeURIComponent(finalModel) + ':generateContent?key=' + encodeURIComponent(apiKey);

  const payload = {
    contents:         buildGeminiContents(messages),
    generationConfig: { maxOutputTokens: maxTokens },
    // CORRECCIÃ“: Desactivem els filtres per permetre textos literaris
    safetySettings: [
      { category: "HARM_CATEGORY_HARASSMENT",        threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_HATE_SPEECH",        threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",  threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_DANGEROUS_CONTENT",  threshold: "BLOCK_NONE" }
    ]
  };

  if (systemPrompt || SYSTEM_DEFAULT) {
    payload.systemInstruction = { parts: [{ text: systemPrompt || SYSTEM_DEFAULT }] };
  }

  const raw = await fetchSegur(endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'Gemini');
  if (result.error) {
    throw new Error(
      (result.error.message || 'Error desconegut de Gemini.') +
      (result.error.status ? ' (' + result.error.status + ')' : '')
    );
  }
  return analitzarRespostaGenerica(result, 'google').text;
}

async function callGeminiWithFinishReason(messages, systemPrompt, apiKey, model, maxTokens) {
  const finalModel = model || PROVIDER_DEFAULTS.gemini.model;
  const endpoint   = PROVIDER_DEFAULTS.gemini.apiUrlBase + '/' +
    encodeURIComponent(finalModel) + ':generateContent?key=' + encodeURIComponent(apiKey);

  const payload = {
    contents:         buildGeminiContents(messages),
    generationConfig: { maxOutputTokens: maxTokens },
    safetySettings: [
      { category: "HARM_CATEGORY_HARASSMENT",        threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_HATE_SPEECH",        threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",  threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_DANGEROUS_CONTENT",  threshold: "BLOCK_NONE" }
    ]
  };

  if (systemPrompt || SYSTEM_DEFAULT) {
    payload.systemInstruction = { parts: [{ text: systemPrompt || SYSTEM_DEFAULT }] };
  }

  const raw = await fetchSegur(endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'Gemini');
  if (result.error) {
    throw new Error(
      (result.error.message || 'Error desconegut de Gemini.') +
      (result.error.status ? ' (' + result.error.status + ')' : '')
    );
  }
  return analitzarRespostaGenerica(result, 'google');
}

// â”€â”€â”€ Helpers de construcciÃ³ de missatges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildOpenAIMessages(messages, systemPrompt) {
  const base = [];
  if (systemPrompt || SYSTEM_DEFAULT) base.push({ role: 'system', content: systemPrompt || SYSTEM_DEFAULT });
  return base.concat((messages || []).map(msg => ({
    role:    msg.role,
    content: extractContentText(msg.content)
  })));
}

function buildGeminiContents(messages) {
  return (messages || []).map(msg => ({
    role:  msg.role === 'assistant' ? 'model' : 'user',
    parts: [{ text: extractContentText(msg.content) }]
  }));
}

function extractContentText(content) {
  if (typeof content === 'string') return content;
  if (Array.isArray(content)) return content.map(item => {
    if (typeof item === 'string') return item;
    if (item && typeof item.text === 'string') return item.text;
    return '';
  }).join('\n');
  if (content && typeof content.text === 'string') return content.text;
  return content ? String(content) : '';
}

function normalizeLLMText(text) {
  return (text || '').replace(/^\s+|\s+$/g, '');
}

// â”€â”€â”€ System prompt base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SYSTEM_DEFAULT = `Ets un mestre del conte literari breu en catalÃ .
Apliques el principi d'unitat d'efecte de Poe: cada paraula serveix un Ãºnic impacte emocional final.
Escrius amb economia de paraules, primera frase magnÃ¨tica, tensiÃ³ creixent i finals memorables que ressonen.
Mai desperdicies una frase. Prioritzes mostrar sobre explicar.
DIÃ€LEGS â€” SEPARACIÃ“ DE PARÃ€GRAFS: Ã‰s OBLIGATORI fer un punt i a part (nova lÃ­nia) cada vegada que canvia el personatge que parla o hi ha un canvi d'acciÃ³ important. MAI barregis intervencions de dos personatges diferents en el mateix parÃ graf.
Escrius EXCLUSIVAMENT en catalÃ . Mai inclous paraules, frases ni comentaris en anglÃ¨s o cap altra llengua. Mai afegeixes notes meta, indicacions de nÃºmero de part ni cap text fora de la narraciÃ³ literÃ ria. Escriu directament el text.`;

// â”€â”€â”€ ExtensiÃ³ d'estil per autor (reutilitzable per conte i novelÂ·la) â”€â”€â”€
function getGenreStyle(tematica) {
  const isLarsson   = tematica && /larsson|noir|negr[ae]|nÃ²rdi/i.test(tematica);
  const isTolkien   = tematica && /tolkien|fantÃ stic|fantastic|Ã¨pic/i.test(tematica);
  const isDick      = tematica && /philip k\. dick|philip.*dick|dick/i.test(tematica);
  const isCastaneda = tematica && /castaneda|xamÃ nic/i.test(tematica);

  if (isLarsson) return `

â”€â”€ ESTIL STIEG LARSSON â”€â”€
Pensament i visiÃ³ del mÃ³n: Larsson era periodista d'investigaciÃ³ i antifeixista militant. Les seves obres neixen de la convicciÃ³ que la violÃ¨ncia contra les dones i la corrupciÃ³ institucional sÃ³n sistÃ¨miques, no excepcions. Escrius des d'aquesta consciÃ¨ncia polÃ­tica sense abanderats ni discursos.
Prosa directa i funcional, carregada de detall procedimental: cada acciÃ³ d'investigaciÃ³ â€”una trucada, un arxiu consultat, una font protegidaâ€” s'explica amb lÃ²gica interna creÃ¯ble i concreta.
L'entorn nÃ²rdic (hivern escandinau, foscor, aÃ¯llament geogrÃ fic i social) actua com a personatge amb pes propi: el fred Ã©s moral tant com climÃ tic.
Secrets familiars soterrats durant dÃ¨cades que quan surten a la llum destapen patrons de violÃ¨ncia i complicitat que ningÃº volia veure.
Protagonistes traumatitzats amb una obstinaciÃ³ quasi patolÃ²gica: no investiguen per heroisme sinÃ³ perquÃ¨ no poden parar, la ferida personal Ã©s el motor.
CrÃ­tica social concreta i documentada integrada a la trama: noms d'institucions, mecanismes de poder, estadÃ­stiques de violÃ¨ncia que apareixen de forma natural al text.
Estructura de revelaciÃ³ progressiva: el que semblava un cas aÃ¯llat obre pas a un sistema podrit que implica tothom.
Ritme metÃ²dic i pausat en la investigaciÃ³, amb pics d'acciÃ³ breu, directa i brutal quan la violÃ¨ncia irromp.`;

  if (isTolkien) return `

â”€â”€ ESTIL J.R.R. TOLKIEN â”€â”€
Pensament i visiÃ³ del mÃ³n: Tolkien era filÃ²leg, catÃ²lic i veterÃ  de la Primera Guerra Mundial. El seu univers neix de la convicciÃ³ que el llenguatge crea realitat, que el bÃ© i el mal existeixen com a forces cÃ²smiques, i que la humilitat dels petits pot transformar la histÃ²ria. Escrius des d'aquesta fe en la bellesa i el sacrifici.
Prosa Ã¨pica, lÃ­rica i detallada: les descripcions de paisatge i arquitectura transmeten profunditat i antiguitat immemorial, com si el mÃ³n existÃ­s des d'abans que comencÃ©s la histÃ²ria.
Univers tolkieniÃ  complet: races (Eldar, Khazad, hobits, homes, orcs, ents), geografies amb nom i memÃ²ria prÃ²pia, llenguatges inventats amb fonologia coherent, canÃ§ons i poemes intercalats quan l'escena ho demana.
Temes centrals: la corrupciÃ³ del poder i la tentaciÃ³ dels anells, el pes de la responsabilitat sobre les espatlles dels humils, la camaraderia com a valor suprem, la bellesa efÃ­mera davant el pas implacable del temps i l'oblit.
Llenguatge solemne perÃ² accessible: frases llargues i rÃ­tmiques, construccions arcaiques mesurades, Ã¨mfasi en els noms propis com a portadors de destÃ­.
La natura com a presÃ¨ncia viva i moral: boscos, rius i muntanyes tenen memÃ²ria, voluntat i opiniÃ³ sobre els esdeveniments dels mortals.
El mal tÃ© pes fÃ­sic i sensorial: no s'explica, es percep en l'aire que s'espesseix, la llum que s'apaga, el silenci sobtat dels ocells i la por als ulls dels animals.`;

  if (isDick) return `

â”€â”€ ESTIL PHILIP K. DICK â”€â”€
Pensament i visiÃ³ del mÃ³n: Dick era un paranoic funcional fascinat per la gnosi, les drogues, la simulaciÃ³ i la pregunta de si alguna cosa Ã©s real. Les seves obres neixen de la convicciÃ³ que la realitat Ã©s una capa prima que pot trencar-se en qualsevol moment i que el sistema â€”qualsevol sistemaâ€” menteix. Escrius des d'aquesta desconfianÃ§a radical.
Paranoia com a estat cognitiu del protagonista i del lector: les institucions (estat, corporacions, androÃ¯des, drogues prescrites) manipulen la percepciÃ³; ningÃº sap mai si el que veu Ã©s real o induÃ¯t.
Les drogues â€”legals, ilÂ·legals, prescrites per l'estatâ€” com a eina de control social i com a porta ambigua a altres realitats: poden revelar la veritat o ser la mentida mÃ©s sofisticada.
Distopia quotidiana i desgastada: el futur Ã©s una extensiÃ³ deteriorada del present, amb publicitat agressiva, burocrÃ cia kafkiana, androÃ¯des indistingibles dels humans i guerres consumides en segon pla.
Canvis sobtats i irreversibles de realitat: una frase, un objecte, una conversa trenquen el marc que el lector creia ferm. No es recupera l'estat anterior.
Protagonistes ordinaris â€”venedors, taxistes, policies de baixa graduaciÃ³â€” que descobreixen que el mÃ³n que habiten Ã©s una construcciÃ³ i han de decidir si prefereixen la mentida cÃ²moda o la veritat devastadora.
Prosa Ã gil, nerviosa i plena de diÃ leg: les espirals de pensament paranoic del protagonista s'intercalen amb l'acciÃ³ sense aturar el ritme.
Empatia com a Ãºnica brÃºixola moral: en un mÃ³n on res Ã©s real, la capacitat de sentir el dolor de l'altre Ã©s l'Ãºnic criteri per distingir l'humÃ  de la mÃ quina.`;

  if (isCastaneda) return `

â”€â”€ ESTIL CARLOS CASTANEDA â”€â”€
Pensament i visiÃ³ del mÃ³n: Castaneda partia de la tradiciÃ³ tolteca i xamÃ nica per demostrar que la realitat ordinÃ ria Ã©s un acord social, no una veritat absoluta. Les seves obres neixen de la convicciÃ³ que la percepciÃ³ es pot estendre mÃ©s enllÃ  dels lÃ­mits racionals i que hi ha un "punt d'assemblatge" que pot moure's. Escrius des d'aquesta epistemologia alternativa.
Marc antropolÃ²gic o periodÃ­stic que es dissol progressivament: el narrador arriba com a investigador racional i occidental i surt transformat per experiÃ¨ncies que la seva formaciÃ³ no pot contenir.
RelaciÃ³ mestre-aprenent com a eix narratiu: el personatge guia (el bruixot, el nagual, el curandero) no explica mai directament, ensenya a travÃ©s de tasques impossibles, silencis deliberats, paradoxes i situacions lÃ­mit.
Els estats alterats de consciÃ¨ncia â€”induÃ¯ts per plantes de poder, per privaciÃ³ sensorial, per esforÃ§ fÃ­sic extrem o per la voluntat del mestreâ€” es descriuen amb precisiÃ³ sensorial absoluta: colors, sons, sensacions corporals, distorsions temporals. No s'expliquen des de fora, es viuen des de dins.
El mÃ³n natural com a text viu: cada animal, planta, vent o lloc porta intenciÃ³ i missatge per als qui han aprÃ¨s a llegir-los.
DiÃ leg com a vehicle principal de l'ensenyament: les converses entre aprenent i mestre marquen el ritme i transformen la percepciÃ³ del lector.
TensiÃ³ irresoluble entre la racionalitat occidental del protagonista i la "realitat separada" que se li ofereix: el text no resol aquesta tensiÃ³, la mantÃ© viva fins al final.
El desert, la nit, els somnis lÃºcids i les plantes de poder com a espais on les fronteres entre mons es fan permeables.`;

  return '';
}

// â”€â”€â”€ System prompt dinÃ mic per gÃ¨nere (conte breu) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getSystemPrompt(tematica) {
  return SYSTEM_DEFAULT + getGenreStyle(tematica);
}

// â”€â”€â”€ FASE 1: 10 premisses â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase1_premisses(tematica, history, userConfig) {
  history = history || [];
  const userMsg = {
    role: 'user',
    content: `Genera 10 premisses originals per a contes breus del gÃ¨nere: **${tematica}**.

Cada premissa ha de:
- Ser una sola frase que contingui una situaciÃ³ anÃ²mala o conflicte inicial potent
- Tenir un ganxo implÃ­cit que faci preguntar "i llavors?"
- Suggerir potencial de twist o revelaciÃ³ inesperada al final
- Ser concreta, sorprenent, no Ã²bvia ni genÃ¨rica

Afegeix (Recomanat) al final de la premissa que consideris mÃ©s potent literÃ riament.

Format ESTRICTE (res mÃ©s, sense cap introducciÃ³):
1. [premissa]
2. [premissa]
3. [premissa]
4. [premissa]
5. [premissa]
6. [premissa]
7. [premissa]
8. [premissa]
9. [premissa]
10. [premissa]`
  };
  const msgs       = [...history, userMsg];
  const models = getModelConfig(userConfig);
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096, model: models.modelArquitecte }), 'arquitectura');
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 3: 5 protagonistes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase3_personatges(premissaTriada, estilDesc, history, userConfig, tematica) {
  const isNoir = tematica && /larsson|noir|negr[ae]|nÃ²rdi/i.test(tematica);

  const protagonistePrompt = isNoir
    ? `Genera 5 protagonistes possibles per a aquest conte NEGRE NÃ’RDIC.
PROHIBICIÃ“ DE CLIXÃ‰S: Evita absolutament els estereotips de Hollywood (prohibit "hackers antisocials en soterranis", policies alcohÃ²lics amb la vida destruÃ¯da, assassins a sou amb filosofia existencial, periodistes coratjoses-perÃ²-solitÃ ries). No copies arquetips del gÃ¨nere: crea persones.
Dona'ls feines reals, burocrÃ tiques o integrades a la societat (ex: analista de dades d'una teleoperadora, auditor d'hisenda, periodista d'un mitjÃ  local avorrit, funcionari de serveis socials, tÃ¨cnic d'una empresa auditora). El terror ha de nÃ©ixer de la quotidianitat, no de la marginalitat.
Cada protagonista ha de tenir veu prÃ²pia i la ferida personal que el fa avanÃ§ar quan tot indica que ha de parar.`
    : `Genera 5 protagonistes possibles per a aquest conte. Cada un ha de tenir veu prÃ²pia i tensiÃ³ interna que el faci memorable.`;

  const msgs = [
    ...history,
    {
      role: 'user',
      content: `He triat la premissa: "${premissaTriada}". L'estil narratiu serÃ : ${estilDesc}.`
    },
    {
      role: 'assistant',
      content: "Perfecte. Proposo protagonistes rics en contradiccions, coherents amb la premissa i l'estil triat."
    },
    {
      role: 'user',
      content: `${protagonistePrompt}

Afegeix (Recomanat) al final del protagonista que millor encaixi amb la premissa i l'estil triat.

Format ESTRICTE (5 opcions, res mÃ©s):
1. **[Nom, edat]** | Desig: [el que vol conscientment] | Temor: [el que l'aterroritza o amaga] | ContradicciÃ³: [la tensiÃ³ interna que el fa humÃ ] | Veu: [tret narratiu o tic que el fa distintiu]
2. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]
3. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]
4. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]
5. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]`
    }
  ];
  const models = getModelConfig(userConfig);
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096, model: models.modelDraft, _esDraft: true }), 'generacio');
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 4: 5 localitzacions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase_localitzacions(protagonistaTriat, estilDesc, history, userConfig, tematica) {
  const msgs = [
    ...history,
    { role: 'user',      content: `He triat el protagonista: "${protagonistaTriat}".` },
    { role: 'assistant', content: "Perfecte. Proposo localitzacions que maximitzin el potencial narratiu de la premissa i el protagonista." },
    {
      role: 'user',
      content: `Genera 5 localitzacions possibles per a aquest conte, coherents amb el gÃ¨nere, l'estil i el protagonista triat.

Cada localitzaciÃ³ ha de:
- Tenir una atmosfera concreta que reforci el to del conte
- Incloure un detall fÃ­sic especÃ­fic que pugui tenir rol narratiu
- Suggerir tensions o possibilitats implÃ­cites (no explicar-les)

Afegeix (Recomanat) al final de la localitzaciÃ³ que millor serveixi la premissa i l'estil.

Format ESTRICTE (5 opcions, res mÃ©s):
1. **[Nom/tipus de lloc]** | Atmosfera: [adjectius sensorials] | Detall clau: [element fÃ­sic concret] | Potencial: [possibilitat narrativa breu]
2. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]
3. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]
4. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]
5. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]`
    }
  ];
  const models = getModelConfig(userConfig);
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096, model: models.modelDraft, _esDraft: true }), 'generacio');
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 5: 5 finals possibles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase4_finals(localitzacioTriada, estilDesc, history, userConfig, tematica) {
  const msgs = [
    ...history,
    { role: 'user',      content: `He triat la localitzaciÃ³: "${localitzacioTriada}".` },
    { role: 'assistant', content: 'Perfecte. Amb totes les decisions preses, proposo possibles finals per al conte.' },
    {
      role: 'user',
      content: `Genera 5 finals possibles per a aquest conte, coherents amb la premissa, l'estil i el protagonista triats.

Cada final ha de:
- Ser diferent en to i resoluciÃ³ dels altres
- Tenir impacte emocional genuÃ­
- Ser inevitable en retrospectiva perÃ² imprevist durant la lectura
- Explicar-se en 2-3 frases que capturin l'essÃ¨ncia sense revelar massa

Afegeix (Recomanat) al final de l'opciÃ³ que consideris mÃ©s poderosa literÃ riament.

Format ESTRICTE (5 opcions, res mÃ©s):
1. [descripciÃ³ del final en 2-3 frases]
2. [descripciÃ³ del final en 2-3 frases]
3. [descripciÃ³ del final en 2-3 frases]
4. [descripciÃ³ del final en 2-3 frases]
5. [descripciÃ³ del final en 2-3 frases]`
    }
  ];
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096 }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ ESCRIPTURA: GeneraciÃ³ per parts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function escriureContePart(partNum, totalParts, paraulesPerPart, finalTriat, estilDesc, history, userConfig, tematica) {
  const pp     = parseInt(paraulesPerPart) || 750;
  const isNoir = tematica && /larsson|noir|negr[ae]|nÃ²rdi/i.test(tematica);

  const noirExtra = isNoir
    ? `\nESTIL NORDIC NOIR OBLIGATORI per a aquesta part:
â†’ Descripcions minucioses i procedimentals: cada acciÃ³ d'investigaciÃ³ s'explica amb lÃ²gica creÃ¯ble.
â†’ Integra detalls de procediment policial, forense o periodÃ­stic de forma natural a la narraciÃ³.
â†’ Pinzellades de crÃ­tica social concreta (noms d'institucions, mecanismes de poder) sense discurs explÃ­cit.
â†’ L'entorn nÃ²rdic (fred, silenci, llum escassa) present com a pressiÃ³ constant sobre els personatges.`
    : '';

  let userContent;

  if (totalParts === 1) {
    userContent =
`He triat el final: "${finalTriat}".

Escriu el CONTE COMPLET. Estil: ${estilDesc}.
ExtensiÃ³ objectiu: ~${pp} PARAULES. Desenvolupa a fons cada detall, no resumeixis.
Final obligatori: "${finalTriat}"

OBERTURA: primera frase magnÃ¨tica, tensiÃ³ immediata. Primers 3 parÃ grafs sense exposiciÃ³ directa.
ESTRUCTURA: unitat d'efecte, tensiÃ³ creixent, punt d'inflexiÃ³ a les 2/3 parts.
ESTIL: mostra no expliquis, detalls sensorials concrets, ritme variat, veu Ãºnica, diÃ legs que revelen carÃ cter.
FINAL: l'Ãºltima frase ressona i tanca un cercle del principi.${noirExtra}
Escriu directament el conte en catalÃ , sense tÃ­tol ni nota de l'autor. Cap paraula en anglÃ¨s ni cap altra llengua.`;

  } else if (partNum === 1) {
    userContent =
`He triat el final: "${finalTriat}".

Escriu la PRIMERA PART del conte. Estil: ${estilDesc}.
ExtensiÃ³ objectiu: ~${pp} PARAULES. Desenvolupa a fons cada detall, no resumeixis.

Objectiu d'aquesta part:
â†’ Primera frase impossible de no llegir (pregunta o tensiÃ³ immediata).
â†’ Establir la veu, l'atmosfera i el personatge sense exposiciÃ³ directa.
â†’ Plantar la tensiÃ³ central i el conflicte que s'ha de resoldre.
â†’ Acabar en un punt de suspens que demani la continuaciÃ³ (NO resolguis res).
Mostra, no expliquis. Detalls sensorials concrets. Veu Ãºnica.${noirExtra}
Escriu directament en catalÃ , sense tÃ­tol ni cap indicaciÃ³ de "Part 1". Cap paraula en anglÃ¨s ni cap altra llengua.`;

  } else if (partNum < totalParts) {
    userContent =
`Continua el conte amb la PART ${partNum}.
ExtensiÃ³ objectiu: ~${pp} PARAULES. Desenvolupa a fons cada detall, no resumeixis.

Objectiu d'aquesta part:
â†’ Augmenta el conflicte i la pressiÃ³ sobre el protagonista.
â†’ Introdueix el punt d'inflexiÃ³ o la complicaciÃ³ principal.
â†’ Acaba quan la tensiÃ³ arriba al mÃ xim, just abans de la resoluciÃ³.
â†’ MantÃ©n exactament la mateixa veu narrativa, to i registre de les parts anteriors.${noirExtra}
Continua directament la narraciÃ³ en catalÃ , des d'on s'ha aturat el text anterior. Sense cap indicaciÃ³ de nÃºmero de part ni comentari fora de la ficciÃ³. Cap paraula en anglÃ¨s ni cap altra llengua.`;

  } else {
    userContent =
`Finalitza el conte amb la PART FINAL.
ExtensiÃ³ objectiu: ~${pp} PARAULES. Desenvolupa a fons cada detall, no resumeixis.

El desenllaÃ§ OBLIGATORI Ã©s: "${finalTriat}"

â†’ Executa el clÃ­max i la resoluciÃ³ amb precisiÃ³ literÃ ria.
â†’ El desenllaÃ§ ha de ser inevitable en retrospectiva perÃ² imprevist durant la lectura.
â†’ L'Ãºltima frase ha de ressonar i tancar un cercle obert al principi.
â†’ MantÃ©n exactament la mateixa veu narrativa i to de les parts anteriors.${noirExtra}
Continua directament la narraciÃ³ en catalÃ , des d'on s'ha aturat el text anterior. Sense cap indicaciÃ³ de nÃºmero de part ni comentari fora de la ficciÃ³. Cap paraula en anglÃ¨s ni cap altra llengua.`;
  }

  const msgs = [...history, { role: 'user', content: userContent }];
  const models = getModelConfig(userConfig);

  const responseGeneracio = await callLLMOneShotPlusCompletion(
    msgs,
    getSystemPrompt(tematica),
    Object.assign({}, userConfig, { maxTokens: 8192, model: models.modelArquitecte, modelArquitectura: models.modelArquitecte, modelGeneracio: models.modelArquitecte }),
    'generacio'
  );

  let responseFinal = responseGeneracio;
  try {
    const msgsRefina = [
      ...msgs,
      { role: 'assistant', content: responseGeneracio },
      {
        role: 'user',
        content: `REFINAMENT ARQUITECTÃ’NIC DE PROSA:
Reescriu Ã­ntegrament aquesta mateixa part mantenint els mateixos fets, ordre narratiu i continuÃ¯tat, perÃ² millorant coherÃ¨ncia estructural, ritme i veu.
MantÃ©n una longitud equivalent (en paraules) i evita resumir.
Retorna NOMÃ‰S el text final en catalÃ .`
      }
    ];

    const responseArquitectura = await callLLMOneShotPlusCompletion(
      msgsRefina,
      getSystemPrompt(tematica),
      Object.assign({}, userConfig, {
        maxTokens: 8192,
        model: models.modelArquitecte,
        modelArquitectura: models.modelArquitecte,
        modelGeneracio: models.modelArquitecte
      }),
      'arquitectura'
    );

    if (responseArquitectura && responseArquitectura.trim()) {
      responseFinal = responseArquitectura;
    }
  } catch (err) {
    console.warn("Refinament amb model d'arquitectura no disponible, es mantÃ© la versiÃ³ de generaciÃ³:", err.message);
  }

  const newHistory = [...msgs, { role: 'assistant', content: responseFinal }];
  return { response: responseFinal, history: newHistory };
}

// â”€â”€â”€ MILLORA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function millorarConte(instruccio, conteActual, estilDesc, history, userConfig, tematica) {
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `AquÃ­ tens el conte actual:\n\n${conteActual}\n\n---\nReescriu el conte complet aplicant aquesta millora: "${instruccio}".\n\nMantÃ©n tot el que funciona bÃ©. Millora especÃ­ficament el que es demana. MantÃ©n la mateixa extensiÃ³ aproximada i l'estil: ${estilDesc}.\n\nEscriu directament el conte millorat, sense cap comentari previ.`
    }
  ];
  const maxTokens  = Math.min(Math.round(conteActual.split(' ').length * 2.5) + 600, 8000);
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 7: Worldbuilding â€” ExtracciÃ³ d'elements â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase7_worldbuilding(conteActual, tematica, estilDesc, history, userConfig) {
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `Has escrit el conte segÃ¼ent:\n\n${conteActual}\n\n---\nAra, com a arquitecte de mons, analitza el conte i proposa 8 elements del mÃ³n que es podrien expandir per convertir-lo en una novelÂ·la. Els elements han de ser:\n\n1. Geografia â€” el territori i els seus llocs rellevants\n2. PolÃ­tica â€” el sistema de poder i les seves tensions\n3. MÃ gia/Tecnologia â€” el sistema mÃ gic o tecnolÃ²gic que regeix el mÃ³n\n4. Religions â€” les creences, rituals i institucions religioses\n5. Faccions â€” els grups, bandes o organitzacions en conflicte\n6. HistÃ²ria pregressa â€” els esdeveniments passats que expliquen el present\n7. Economia â€” els recursos, el comerÃ§ i les desigualtats\n8. Cultura quotidiana â€” els costums, l'art, la gastronomia, les festes\n\nMarca amb "(Recomanat)" els 4 elements mÃ©s rellevants per expandir basant-te en el que ja apareix al conte. Cada element: nom + descripciÃ³ d'1 lÃ­nia del que caldria definir.\n\nFormat ESTRICTE (res mÃ©s, sense cap introducciÃ³):\n1. **Geografia** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n2. **PolÃ­tica** â€” [descripciÃ³ d'1 lÃ­nia]\n3. **MÃ gia/Tecnologia** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n4. **Religions** â€” [descripciÃ³ d'1 lÃ­nia]\n5. **Faccions** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n6. **HistÃ²ria pregressa** â€” [descripciÃ³ d'1 lÃ­nia]\n7. **Economia** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n8. **Cultura quotidiana** â€” [descripciÃ³ d'1 lÃ­nia]`
    }
  ];
  const response   = await callLLMMulti(
    msgs,
    getSystemPrompt(tematica),
    Object.assign({}, userConfig, { maxTokens: 3072 }),
    'arquitectura'
  );
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 7: Worldbuilding â€” ExpansiÃ³ dels elements triats â”€â”€â”€
async function fase7_expandirElements(elementsTriats, conteActual, tematica, history, userConfig) {
  const llistaElements = elementsTriats.join('\n');
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `A partir del conte i dels elements de mÃ³n proposats, desenvolupa una bÃ­blia de mÃ³n per als elements seleccionats.\n\nElements a expandir:\n${llistaElements}\n\nPer a cada element, escriu una descripciÃ³ de 3-5 lÃ­nies que:\n- Defineixi l'element amb precisiÃ³ i profunditat\n- Connecti amb el que ja apareix al conte\n- Suggereixi tensions narratives implÃ­cites\n- Sigui Ãºtil per a un escriptor que vol expandir el mÃ³n\n\nFormat ESTRICTE per a cada element:\n**[Nom de l'element]**\n[descripciÃ³ de 3-5 lÃ­nies]\n\nSepara els elements amb una lÃ­nia en blanc. Escriu exclusivament en catalÃ .`
    }
  ];
  const maxTokens  = Math.min(550 * elementsTriats.length + 1200, 8192);
  const proveidor  = String((userConfig && userConfig.provider) || '').toLowerCase().trim();

  let response = await callLLMMulti(
    msgs,
    getSystemPrompt(tematica),
    Object.assign({}, userConfig, { maxTokens }),
    'arquitectura'
  );

  // Gemini a vegades retorna blocs massa breus o incomplets en una sola passada.
  // Si detectem poca densitat, fem una segona passada d'ampliaciÃ³ guiada.
  const tePocsBlocs = (response.match(/\*\*[^*]+\*\*/g) || []).length < Math.max(2, elementsTriats.length - 1);
  const esCurt = response.split(/\s+/).length < Math.max(220, elementsTriats.length * 90);

  if ((proveidor === 'gemini' || proveidor === 'google' || proveidor === 'google-gemini') && (tePocsBlocs || esCurt)) {
    const msgsAmpl = [
      ...msgs,
      { role: 'assistant', content: response },
      {
        role: 'user',
        content: `La resposta anterior ha quedat massa curta o fragmentada. Torna-la a escriure COMPLETA i ben estructurada.

Requisits obligatoris:
- Inclou TOTS els elements seleccionats.
- Cada element ha de tenir entre 120 i 180 paraules Ãºtils.
- Sense frases telegrÃ fiques ni llistes tallades.
- MantÃ©n exactament el format:
**[Nom de l'element]**
[descripciÃ³ extensa i cohesionada]

Escriu nomÃ©s el resultat final en catalÃ .`
      }
    ];

    response = await callLLMMulti(
      msgsAmpl,
      getSystemPrompt(tematica),
      Object.assign({}, userConfig, { maxTokens: Math.min(maxTokens + 1200, 8192) }),
      'arquitectura'
    );
  }

  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 8: Elenc de personatges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase8_elencPersonatges(conteActual, protagonistaTriat, tematica, estilDesc, worldContext, history, userConfig) {
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `A partir del conte escrit i la informaciÃ³ del mÃ³n, proposa un elenc de personatges secundaris per a la seva expansiÃ³ en novelÂ·la.

Conte:
${conteActual}${worldContext}

Protagonista ja definit: ${protagonistaTriat}
GÃ¨nere: ${tematica} | Estil: ${estilDesc}

Proposa fins a 8 personatges secundaris. Cada un ha de:
- Tenir un rol clar en la trama o en el creixement del protagonista
- Tenir una relaciÃ³ especÃ­fica i dramÃ ticament Ãºtil amb el protagonista
- Tenir un tret definitori que el faci memorable en poques paraules
- Tenir una funciÃ³ dramÃ tica concreta a la novelÂ·la

Marca amb (Recomanat) els 4 personatges que consideris essencials per a la trama.

Format ESTRICTE (res mÃ©s, sense cap introducciÃ³):
1. **[Nom, edat]** | Rol: [funciÃ³ narrativa] | RelaciÃ³: [amb el protagonista] | Tret: [caracterÃ­stica definitÃ²ria] | FunciÃ³: [propÃ²sit dramÃ tic a la novelÂ·la]
2. **[Nom, edat]** | Rol: [...] | RelaciÃ³: [...] | Tret: [...] | FunciÃ³: [...]
3. ...`
    }
  ];
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 3000 }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 9: Estils de parla â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Genera el perfil de veu per al protagonista + tots els personatges
// secundaris seleccionats, per guiar l'escriptura dels diÃ legs.
async function fase9_estilParla(protagonistaTriat, personatgesSecundaris, conteActual, tematica, estilDesc, history, userConfig) {
  const totsPersonatges = Array.from(new Set([protagonistaTriat, ...personatgesSecundaris].filter(Boolean)));
  const historyCurt = Array.isArray(history) ? history.slice(-6) : [];
  const PRIMERA_TONGADA = 7;
  const partsResposta = [];

  const tongades = [
    totsPersonatges.slice(0, PRIMERA_TONGADA),
    totsPersonatges.slice(PRIMERA_TONGADA)
  ].filter(bloc => bloc.length > 0);

  for (const blocPersonatges of tongades) {
    const llista = blocPersonatges.map((p, j) => `${j + 1}. ${p}`).join('\n');

    const msgs = [
      ...historyCurt,
      {
        role: 'user',
        content: `Defineix el perfil de veu i estil de parla de cada personatge de l'elenc per guiar l'escriptura dels diÃ legs de la novelÂ·la.

Personatges:
${llista}

GÃ¨nere: ${tematica} | Estil narratiu general: ${estilDesc}

Per a cada personatge defineix els 5 eixos de la seva veu Ãºnica:
- **Vocabulari**: tipus de paraules que usa (culte, colÂ·loquial, tÃ¨cnic, dialectal, argot, arcaic, cientÃ­ficâ€¦)
- **Frases**: estructura sintÃ ctica tÃ­pica (curtes i directes, llargues i subordinades, fragmentades, retÃ²riques, amb elÂ·lipsisâ€¦)
- **Tics**: 2-3 expressions, interjeccions o fÃ³rmules recurrents que el caracteritzen (entre cometes)
- **Registre**: to general predominant (formal, irÃ²nic, directe, evasiu, emocional, fred, sarcÃ stic, poÃ¨ticâ€¦)
- **Exemple**: una frase representativa del personatge en situaciÃ³ de tensiÃ³ o conflicte (entre cometes)

Els perfils han de ser contrastats entre ells: cada personatge ha de sonar inconfusiblement diferent dels altres.
Evita paraules rebuscades o massa literÃ ries en els diÃ legs si el personatge no les justificaria. Prioritza oralitat natural.

Format ESTRICTE que has de repetir per a TOTS I CADA UN dels personatges de la llista (no t'aturis fins a fer-los tots, sense cap introducciÃ³):
**[Nom del personatge]**
Vocabulari: [...]
Frases: [...]
Tics: [...]
Registre: [...]
Exemple: Â«[frase representativa]Â»

No tallis la resposta a mitges. Si no hi ha espai, prioritza completar TOTS els personatges d'aquest bloc abans d'afegir floritures.
Separa cada personatge amb una lÃ­nia en blanc. Escriu exclusivament en catalÃ .
CRÃTIC: Hi ha EXACTAMENT ${blocPersonatges.length} personatges en aquesta llista. Ã‰s OBLIGATORI que generis la fitxa de TOTS I CADASCUN d'ells. Si et deixes un sol personatge, el sistema fallarÃ .

CRÃTIC: Has de generar un estil de parla per a TOTS I CADASCUN dels personatges de la llista. NO pots deixar-ne cap com a "pendent", "etcÃ¨tera" o ometre'l.
Per assegurar que hi caben tots en la teva resposta, sigues molt concÃ­s: dedica MÃ€XIM 3-4 lÃ­nies per personatge indicant nomÃ©s els tics verbals, to habitual, llargada de les frases i vocabulari caracterÃ­stic. L'objectiu Ã©s que TOTS els personatges de la llista tinguin el seu bloc completat.`
      }
    ];

    const models = getModelConfig(userConfig);
    const configBloc = Object.assign({}, userConfig, {
      maxTokens: 8192,
      model: models.modelArquitecte,
      modelArquitectura: models.modelArquitecte,
      modelGeneracio: models.modelArquitecte
    });

    let respostaBloc = await callLLMOneShotPlusCompletion(msgs, getSystemPrompt(tematica), configBloc, 'arquitectura');

    const missing = blocPersonatges.filter(nom => !respostaBloc.includes(`**${nom}**`));
    if (missing.length > 0) {
      const msgsRetry = [
        ...msgs,
        { role: 'assistant', content: respostaBloc },
        { role: 'user', content: `Has deixat personatges sense fitxa o la resposta s'ha tallat. Escriu NOMÃ‰S les fitxes que falten, en el mateix format estricte, sense repetir les que ja has fet.\nFalten: ${missing.join(', ')}` }
      ];
      const retry = await callLLMOneShotPlusCompletion(msgsRetry, getSystemPrompt(tematica), configBloc, 'arquitectura');
      if (retry && retry.trim()) respostaBloc += '\n\n' + retry.trim();
    }

    const missingFinal = blocPersonatges.filter(nom => !respostaBloc.includes(`**${nom}**`));
    if (missingFinal.length > 0) {
      respostaBloc += '\n\n' + missingFinal.map(nom => `**${nom}**\nVocabulari: pendent de generar\nFrases: pendent de generar\nTics: pendent de generar\nRegistre: pendent de generar\nExemple: Â«pendâ€¦Â»`).join('\n\n');
    }

    partsResposta.push(respostaBloc.trim());
  }

  const response = partsResposta.join('\n\n');
  const newHistory = [...history, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ EXPORT LOCAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Substitueix l'antiga exportarADoc que usava DocumentApp/DriveApp
// (APIs de Google no disponibles al navegador).
//
// Genera un fitxer TXT i el descarrega
// directament al navegador mitjanÃ§ant Blob + URL.createObjectURL.
// Genera un nom de fitxer segur i consistent per a descÃ rregues TXT.
function normalitzarNomFitxerTxt(base, fallback = 'document') {
  const net = String(base || '')
    .replace(/[<>:"/\\|?*]/g, ' ')
    .replace(/\s+/g, '_')
    .replace(/^_+|_+$/g, '')
    .substring(0, 80);
  return `${net || fallback}.txt`;
}

function descarregarBlobFitxer(blob, nomFitxer) {
  if (window.navigator && typeof window.navigator.msSaveOrOpenBlob === 'function') {
    window.navigator.msSaveOrOpenBlob(blob, nomFitxer);
    return;
  }

  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = nomFitxer;
  a.rel = 'noopener';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  // Alguns navegadors cancelÂ·len la descÃ rrega si el revoke Ã©s immediat.
  setTimeout(() => URL.revokeObjectURL(url), 1500);
}

function descarregarTextFallback(titol, contingut, base = 'document') {
  const nomTxt = normalitzarNomFitxerTxt(titol || base, base);
  const blob = new Blob([String(contingut || '')], { type: 'text/plain;charset=utf-8' });
  descarregarBlobFitxer(blob, nomTxt);
  return nomTxt;
}

async function obrirGoogleDocsPerImportar(contingut = '', nomFitxer = '') {
  let copiat = false;
  const text = String(contingut || '');
  if (text && navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
    try {
      await navigator.clipboard.writeText(text);
      copiat = true;
    } catch (err) {
      console.warn('[Google Docs] No s\'ha pogut copiar al porta-retalls:', err.message);
    }
  }
  window.open('https://docs.new', '_blank', 'noopener');
  if (nomFitxer) {
    toast(copiat
      ? `TXT descarregat (${nomFitxer}) i text copiat. A Google Docs, fes Ctrl/Cmd+V per enganxar-lo.`
      : `TXT descarregat (${nomFitxer}). S'ha obert Google Docs perquÃ¨ l'enganxis manualment.`);
  }
}

async function exportarADoc(titol, contingut) {
  const textNet = netejarTabulacionsInicials(contingut || '');
  const txt = [
    `TÃ­tol: ${titol || 'Conte IA'}`,
    'Generat amb Booki',
    '',
    textNet
  ].join('\n');
  const nomTxt = descarregarTextFallback(titol, txt, 'conte');
  await obrirGoogleDocsPerImportar(txt, nomTxt);
}


async function descarregarNovella() {
  const capsGenerats = ESTAT._capitols_generats || [];
  if (!capsGenerats.some(Boolean)) {
    toast('No hi ha cap capÃ­tol generat per descarregar.');
    return;
  }

  // Agafem el tÃ­tol que ha generat l'IA. Si per algun motiu falla, deixem que l'usuari l'introdueixi.
  let titolDefinitiu = ESTAT.titol_novella;
  if (!titolDefinitiu || titolDefinitiu === "NovelÂ·la Sense TÃ­tol") {
    titolDefinitiu = prompt("Introdueix un tÃ­tol per a la teva novelÂ·la:", titolDefinitiu || "La meva novelÂ·la");
  }
  if (!titolDefinitiu) return; // Si l'usuari cancelÂ·la el prompt

  // Recuperem l'epÃ­leg si existeix
  let textEpileg = '';
  if (ESTAT._epileg_generat) {
    textEpileg = ESTAT._epileg_generat;
  } else if (ESTAT.epileg) {
    textEpileg = ESTAT.epileg;
  } else {
    const epEl = document.getElementById('epileg-text');
    if (epEl && epEl.innerText.trim().length > 10) {
      // Netegem el text visible per passar-lo a l'exportador
      textEpileg = Array.from(epEl.querySelectorAll('p')).map(p => p.textContent).join('\n\n') || epEl.innerText;
    }
  }

  const btns = document.querySelectorAll('[onclick="descarregarNovella()"]');
  const origTexts = Array.from(btns).map(b => b.textContent);
  btns.forEach(b => { b.disabled = true; b.textContent = 'â³ Generant TXTâ€¦'; });
  try {
    await exportarNovella(titolDefinitiu, capsGenerats, ESTAT._estructuraCapitols || [], netejarTabulacionsInicials(textEpileg));
  } catch (err) {
    toast('Error al descarregar la novelÂ·la: ' + err.message);
    console.error('[descarregarNovella]', err);
  } finally {
    btns.forEach((b, i) => { b.disabled = false; b.textContent = origTexts[i]; });
  }
}

async function exportarNovella(titol, caps, estructura, epileg) {
  const titolObra = titol || 'NovelÂ·la IA';
  const capitolsAmbText = (caps || [])
    .map((text, i) => ({
      text,
      idx: i,
      cap: estructura[i] || null,
      titolCap: (estructura[i] && estructura[i].titol ? String(estructura[i].titol).trim() : '') || `CapÃ­tol ${i + 1}`
    }))
    .filter(item => item.text);
  const indexText = capitolsAmbText.map((item, pos) => `${pos + 1}. ${item.titolCap}`).join('\n');
  const contingut = [
    `TÃ­tol proposat per la IA: ${titolObra}`,
    'Generat amb Booki',
    '',
    indexText ? `Ãndex de capÃ­tols\n${indexText}` : '',
    ...capitolsAmbText.map((item, pos) => `CapÃ­tol ${pos + 1} â€” ${item.titolCap}\n\n${netejarTabulacionsInicials(item.text)}`),
    (epileg && String(epileg).trim()) ? `EpÃ­leg\n\n${netejarTabulacionsInicials(epileg)}` : ''
  ].filter(Boolean).join('\n\n');

  const nomTxt = descarregarTextFallback(titol, contingut, 'novella');
  await obrirGoogleDocsPerImportar(contingut, nomTxt);
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITAT: Parse robust de JSON (evita errors LLM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function parseJsonRobust(text, expectedKeys = []) {
  if (!text || typeof text !== 'string') {
    console.error("â›” [parseJsonRobust] Error: El text d'entrada Ã©s buit o no Ã©s un string.");
    return null;
  }
  const s = text.trim();

  function netejarCandidate(candidate = '') {
    return String(candidate || '')
      .replace(/[â€œâ€]/g, '"')
      .replace(/[â€˜â€™]/g, "'")
      .replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F]/g, '')
      .replace(/,\s*([}\]])/g, '$1')
      .trim();
  }

  function tancarJsonIncomplet(candidate = '') {
    const src = String(candidate || '');
    if (!src) return src;

    const stack = [];
    let inString = false;
    let escaped = false;

    for (let i = 0; i < src.length; i++) {
      const ch = src[i];

      if (inString) {
        if (escaped) {
          escaped = false;
          continue;
        }
        if (ch === '\\') { escaped = true; continue; }
        if (ch === '"') { inString = false; }
        continue;
      }

      if (ch === '"') { inString = true; continue; }
      if (ch === '{') stack.push('}');
      else if (ch === '[') stack.push(']');
      else if ((ch === '}' || ch === ']') && stack.length > 0 && stack[stack.length - 1] === ch) stack.pop();
    }

    let out = src;
    if (inString) out += '"';
    while (stack.length > 0) out += stack.pop();
    return out;
  }

  function parseLenientJson(candidate) {
    if (!candidate || typeof candidate !== 'string') return null;

    const cleaned = netejarCandidate(candidate);
    try { return JSON.parse(cleaned); } catch (e) {}

    // HeurÃ­stica clau: si la resposta s'ha tallat, intentem tancar l'objecte/array i parsejar.
    const repaired = netejarCandidate(tancarJsonIncomplet(cleaned));
    try { return JSON.parse(repaired); } catch (e) { return null; }
  }

  function validar(resultat, metode) {
    if (!resultat) return null;
    if (expectedKeys && expectedKeys.length > 0) {
      const missing = expectedKeys.filter(k => !(k in resultat));
      if (missing.length > 0) {
        console.warn(`âš ï¸ [parseJsonRobust] JSON recuperat via ${metode}, perÃ² falten claus estructurals: ${missing.join(', ')}`);
        return null;
      }
    }
    if (metode !== 'Directe') {
      console.info(`âœ… [parseJsonRobust] JSON recuperat amb Ã¨xit usant heurÃ­stica: ${metode}`);
    }
    return resultat;
  }

  // 1. Parse directe
  let direct = parseLenientJson(s);
  if (direct) return validar(direct, 'Directe');

  console.warn("âš ï¸ [parseJsonRobust] Fallada al parse directe. Intentant heurÃ­stiques...");

  // 2. Bloc de codi markdown ```json ... ```
  const codeMatch = s.match(/```(?:json)?\s*([\s\S]*?)(?:```|$)/i);
  if (codeMatch) {
    let parsedCode = parseLenientJson(codeMatch[1].trim());
    if (parsedCode) return validar(parsedCode, 'Markdown Block');
  }

  // 3. Primer objecte { ... } (tambÃ© prova reparaciÃ³ si estÃ  truncat)
  const objStart = s.indexOf('{');
  const objEnd   = s.lastIndexOf('}');
  if (objStart !== -1) {
    const objectCandidate = objEnd > objStart ? s.slice(objStart, objEnd + 1) : s.slice(objStart);
    let parsedObject = parseLenientJson(objectCandidate);
    if (parsedObject) return validar(parsedObject, 'ExtracciÃ³ Objecte {}');
  }

  // 4. Primer array [ ... ] (tambÃ© prova reparaciÃ³ si estÃ  truncat)
  const arrStart = s.indexOf('[');
  const arrEnd   = s.lastIndexOf(']');
  if (arrStart !== -1) {
    const arrayCandidate = arrEnd > arrStart ? s.slice(arrStart, arrEnd + 1) : s.slice(arrStart);
    let parsedArray = parseLenientJson(arrayCandidate);
    if (parsedArray) return validar(parsedArray, 'ExtracciÃ³ Array []');
  }

  console.error("â›” [parseJsonRobust] Totes les heurÃ­stiques han fallat. No s'ha pogut extreure JSON. Text rebut:\n", s.substring(0, 300) + "...");
  return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SYSTEM PROMPT per a novelÂ·la
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getSystemPromptNovella(tematica) {
  const base = `Ets un novelÂ·lista literari expert en catalÃ . Escrius novelÂ·la amb profunditat psicolÃ²gica, diÃ legs vius i un ritme narratiu sostingut.
Apliques les tÃ¨cniques de Donna Tartt, Elena Ferrante i Carlos Ruiz ZafÃ³n: atmÃ²sferes denses, personatges amb contradiccions genuÃ¯nes i trames que s'informen mÃºtuament.

â”â”â” REGLES INVIOLABLES â”â”â”
â€¢ LLENGUA: Escrius EXCLUSIVAMENT en catalÃ . Cap paraula en anglÃ¨s ni cap altra llengua.
â€¢ METADADES: Mai afegeixes tÃ­tols, nÃºmeros de capÃ­tol, notes ni cap text fora de la narraciÃ³. Escriu directament el text literari.
â€¢ DIÃ€LEGS â€” FORMAT: Usa SEMPRE el guiÃ³ llarg (â€”) per introduir el parlament. PROHIBIT usar cometes (Â«Â», "", ''). Format: â€”Hola â€”va dir ella. / â€”Vine aquÃ­ â€”li ordenÃ .
â€¢ DIÃ€LEGS â€” PARÃ€GRAFS: Un punt i a part OBLIGATORI cada vegada que canvia el parlant o hi ha canvi d'acciÃ³ important. MAI dos personatges al mateix parÃ graf.
â€¢ SHOW, DON'T TELL: PROHIBIT etiquetar emocions explÃ­citament ("estava trist", "sentia por", "se sentia nerviÃ³s"). MOSTRA l'emociÃ³ a travÃ©s d'accions fÃ­siques, gestualitat, interaccions amb objectes o detalls d'entorn.
â€¢ ANTI-EXPOSICIÃ“: PROHIBIT que cap personatge expliqui directament els seus plans o motivacions (zero monÃ²legs de "dolent de James Bond"). Les figures de poder parlen en eufemismes i to institucional. Cap personatge explicarÃ  res que l'interlocutor ja sÃ piga.
â€¢ CONTINUÃTAT D'ESCENA: No tanquis artificialment l'energia entre escenes. Cada escena ha de fluir cap a la segÃ¼ent amb una tensiÃ³ o pregunta oberta, llevat que sigui el tancament explÃ­cit del capÃ­tol.

â”â”â” REGLES D'ESTIL â”â”â”
â€¢ NOMS: Aplica l'article personal (en, la, l', na) i les preposicions contractes quan la normativa catalana ho requereix (la Maria, en Pere, amb la JÃºlia, del senyor Puig).
â€¢ PROSA: Evita el barroquisme. MÃ xim 1 adjectiu rellevant per substantiu. Pren-te el teu temps: descriu l'atmosfera, explora el monÃ²leg intern, coreografia els moviments per l'espai. Ets exhaustiu i detallista.
â€¢ RITME: Alterna escenes de tensiÃ³ activa (frases curtes, diÃ leg incisiu, acciÃ³ breu) amb moments de respiraciÃ³ (introspecciÃ³, detall sensorial, gest quotidiÃ ). El contrast de ritme Ã©s el que crea la ilÂ·lusiÃ³ de velocitat.
â€¢ SENSORIALITAT: PROHIBIT la prosa asÃ¨ptica. Integra textura fÃ­sica i sensorial (olors, suor, fred, fricciÃ³ material, sons ambientals) especialment quan la tensiÃ³ Ã©s alta. Quan la tensiÃ³ supera 7/10, els detalls viscerals sÃ³n OBLIGATORIS.`;
  return base + getGenreStyle(tematica || ESTAT.tematica);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 1: Brief Narratiu Centralitzat
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildBriefNarratiu() {
  const pers = ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0
    ? ESTAT._personatgesSeleccionats.join('; ')
    : '(No definits)';
  const temes = Array.isArray(ESTAT._temesCentrals) && ESTAT._temesCentrals.length > 0
    ? ESTAT._temesCentrals.slice(0, 4).join(' | ')
    : '';
  const arcGlobal = ESTAT._arcGlobal ? `\n- Arc global: ${ESTAT._arcGlobal.substring(0, 200)}` : '';
  let arcMoral = '';
  if (ESTAT._arcMoral && typeof ESTAT._arcMoral === 'object') {
    const pnr = ESTAT._arcMoral.punt_no_retorn;
    const cf  = ESTAT._arcMoral.cost_final;
    const pnrDesc = pnr && typeof pnr === 'object' ? pnr.descripcio : (typeof pnr === 'string' ? pnr : '');
    const cfDesc  = cf  && typeof cf  === 'object' ? cf.descripcio  : (typeof cf  === 'string' ? cf  : '');
    if (pnrDesc || cfDesc) arcMoral = `\n- Arc moral: ${[pnrDesc, cfDesc].filter(Boolean).join(' â†’ ').substring(0, 200)}`;
  }
  return `DECISIONS NARRATIVES:
- GÃ¨nere: ${ESTAT.tematica || '(No definit)'}
- Premissa: ${ESTAT.premissaTriada || '(No definida)'}
- Estil: ${ESTAT.estil ? ESTAT.estil.desc : '(No definit)'}
- Protagonista: ${ESTAT.protagonistaTriat || '(No definit)'}
- LocalitzaciÃ³: ${ESTAT.localitzacioTriada || '(No definida)'}
- Final planificat: ${ESTAT.finalTriat || '(No definit)'}
- Personatges seleccionats: ${pers}${temes ? '\n- Temes centrals: ' + temes : ''}${arcGlobal}${arcMoral}`;
}

function buildResumConteBreu() {
  if (!ESTAT.conteText) return '(No disponible)';
  const paragrafs = ESTAT.conteText.split(/\n\n+/).filter(p => p.trim());
  if (paragrafs.length <= 3) return ESTAT.conteText.substring(0, 800);
  const primer = paragrafs[0].substring(0, 200);
  const mig    = paragrafs[Math.floor(paragrafs.length / 2)].substring(0, 200);
  const ultim  = paragrafs[paragrafs.length - 1].substring(0, 200);
  return `INICI: ${primer}\n[...]\nMIG: ${mig}\n[...]\nFINAL: ${ultim}`;
}


function buildBlocAlertaLongitud() {
  const c = ESTAT._controlLongitud;
  if (!c || c.tendencia !== 'decreixent') return '';
  const hist = Array.isArray(c.historicLongituds) ? c.historicLongituds : [];
  const ultimes = hist.slice(-3).join(', ');
  const minim = Math.round((Number(c.objectiu || 3000)) * Number(c.llindarMinim || 0.7));
  return `ALERTA DE LONGITUD: Els Ãºltims capÃ­tols han estat progressivament mÃ©s curts ([${ultimes}]). Aquest capÃ­tol ha de tenir un MÃNIM de ${minim} paraules. Desenvolupa les escenes amb profunditat. No resumeixis; NARRA.`;
}

function verificarLongitud(capitolIdx, textGenerat) {
  if (!ESTAT._controlLongitud || typeof ESTAT._controlLongitud !== 'object') {
    ESTAT._controlLongitud = { objectiu: 3000, llindarMinim: 0.70, llindarExpansio: 0.85, historicLongituds: [], tendencia: 'estable', promptForcat: '' };
  }
  const ctrl = ESTAT._controlLongitud;
  const objectiu = Number(ctrl.objectiu || 3000);
  const paraules = compteParaules(String(textGenerat || ''));
  ctrl.historicLongituds = Array.isArray(ctrl.historicLongituds) ? ctrl.historicLongituds : [];
  ctrl.historicLongituds.push(paraules);

  const h = ctrl.historicLongituds;
  if (h.length >= 3) {
    const a = h[h.length - 3], b = h[h.length - 2], c = h[h.length - 1];
    if (a > b && b > c) ctrl.tendencia = 'decreixent';
    else if (a < b && b < c) ctrl.tendencia = 'creixent';
    else ctrl.tendencia = 'estable';
  } else {
    ctrl.tendencia = 'estable';
  }

  const percentatge = objectiu > 0 ? paraules / objectiu : 0;
  const llMin = Number(ctrl.llindarMinim || 0.70);
  const llExp = Number(ctrl.llindarExpansio || 0.85);

  if (percentatge >= llExp) {
    return { paraules, percentatge, accio: 'acceptar', motiu: 'Longitud dins del rang objectiu.' };
  }
  if (percentatge >= llMin) {
    return { paraules, percentatge, accio: 'expandir', motiu: 'CapÃ­tol acceptable perÃ² massa curt; cal expansiÃ³.' };
  }
  return { paraules, percentatge, accio: 'regenerar', motiu: 'CapÃ­tol massa curt respecte del mÃ­nim.' };
}

async function ajustarLongitud(idx, text, userConfig) {
  let decisio = verificarLongitud(idx, text);
  if (decisio.accio === 'expandir') {
    text = await expandirCapitol(text, idx, decisio.paraules, userConfig);
    const p = compteParaules(text);
    if (ESTAT._controlLongitud && Array.isArray(ESTAT._controlLongitud.historicLongituds) && ESTAT._controlLongitud.historicLongituds.length > 0)
      ESTAT._controlLongitud.historicLongituds[ESTAT._controlLongitud.historicLongituds.length - 1] = p;
    decisio = { ...decisio, paraules: p, percentatge: p / (ESTAT._controlLongitud?.objectiu || 3000), motiu: decisio.motiu + ' ExpansiÃ³ aplicada.' };
  } else if (decisio.accio === 'regenerar') {
    const regen = await regenerarCapitolPerLongitud(idx, userConfig);
    if (regen?.text) text = regen.text;
    const p = compteParaules(text);
    if (ESTAT._controlLongitud && Array.isArray(ESTAT._controlLongitud.historicLongituds) && ESTAT._controlLongitud.historicLongituds.length > 0)
      ESTAT._controlLongitud.historicLongituds[ESTAT._controlLongitud.historicLongituds.length - 1] = p;
    decisio = { ...decisio, paraules: p, percentatge: p / (ESTAT._controlLongitud?.objectiu || 3000), motiu: decisio.motiu + ' RegeneraciÃ³ aplicada.' };
  }
  return { text, decisio };
}

async function expandirCapitol(textOriginal, capitolIdx, paraulesActuals, userConfig = USER_CONFIG) {
  const ctrl = ESTAT._controlLongitud || { objectiu: 3000 };
  const objectiu = Number(ctrl.objectiu || 3000);
  const diferencia = Math.max(0, objectiu - Number(paraulesActuals || 0));
  const systemPrompt = buildSystemPromptCapitol();
  const msgs = [{
    role: 'user',
    content: `El capÃ­tol segÃ¼ent tÃ© ${paraulesActuals} paraules perÃ² l'objectiu Ã©s ${objectiu}.
Falten aproximadament ${diferencia} paraules. EXPANDEIX el capÃ­tol afegint:
- MÃ©s profunditat sensorial a les escenes d'acciÃ³
- Interioritat del personatge (pensaments, sensacions, records)
- Detalls d'ambient i atmosfera
- DilataciÃ³ temporal en els moments de tensiÃ³ alta

NO afegeixis escenes noves ni subtrames. Enriqueix les existents.
Retorna el capÃ­tol COMPLET expandit.

CAPÃTOL A EXPANDIR:
${String(textOriginal || '').slice(0, 20000)}`
  }];
  const models = getModelConfig(userConfig || USER_CONFIG || {});
  const raw = await callLLMOneShotPlusCompletion(
    msgs,
    systemPrompt,
    Object.assign({}, userConfig || USER_CONFIG || {}, { maxTokens: 14000, model: models.modelGeneracio }),
    'generacio'
  );
  return netejarTabulacionsInicials(raw || textOriginal || '');
}

async function regenerarCapitolPerLongitud(capitolIdx, userConfig = USER_CONFIG) {
  const ctrl = ESTAT._controlLongitud || { objectiu: 3000, llindarMinim: 0.70 };
  const minim = Math.round(Number(ctrl.objectiu || 3000) * Number(ctrl.llindarMinim || 0.70));
  ESTAT._controlLongitud.promptForcat = `OBJECTIU DE LONGITUD (REGENERACIÃ“): Aquest capÃ­tol HA de tenir un mÃ­nim de ${minim} paraules. Desenvolupa les escenes amb profunditat. No resumeixis; NARRA.`;
  try {
    const res = await generarCapitolNKG(capitolIdx, userConfig || USER_CONFIG || {});
    return {
      text: netejarTabulacionsInicials((res && res.response) || ''),
      meta: res || {}
    };
  } finally {
    ESTAT._controlLongitud.promptForcat = '';
  }
}

function comptarSilLabesAproximades(paraula) {
  const p = String(paraula || '').toLowerCase().normalize('NFD').replace(/[Ì€-Í¯]/g, '');
  const grups = p.match(/[aeiouÃ Ã¨Ã©Ã­Ã¯Ã²Ã³ÃºÃ¼]+/g);
  return grups ? grups.length : 0;
}

function obtenirFrases(text) {
  return String(text || '')
    .replace(/\s+/g, ' ')
    .split(/(?<=[.!?â€¦])\s+/)
    .map(f => f.trim())
    .filter(Boolean);
}

function actualitzarRegistreEstil(capitolIdx, textCapitol) {
  if (!ESTAT._registreEstil || typeof ESTAT._registreEstil !== 'object') {
    ESTAT._registreEstil = { frequencies: {}, alertes: [], verbs_atribucio: {}, tancaments: [] };
  }

  const stopWords = new Set([
    'el','la','els','les','un','una','uns','unes','de','del','dels','a','al','als','i','o','u','que','en','amb','per','pel','pels','sense','sobre','entre','cap','com','si','no','sÃ­','ja','mÃ©s','mes','tot','tots','tota','totes',
    'jo','tu','ell','ella','nosaltres','vosaltres','ells','elles','em','et','es','ens','us','meu','teva','seu','seva','nostre','nostra','vostre','vostra'
  ]);

  const paraules = String(textCapitol || '')
    .toLowerCase()
    .normalize('NFD').replace(/[Ì€-Í¯]/g, '')
    .replace(/[^a-z0-9\s']/g, ' ')
    .split(/\s+/)
    .map(w => w.trim())
    .filter(Boolean);

  paraules.forEach(w => {
    if (w.length < 3) return;
    if (stopWords.has(w)) return;
    if (comptarSilLabesAproximades(w) < 2) return;
    if (!ESTAT._registreEstil.frequencies[w]) ESTAT._registreEstil.frequencies[w] = { count: 0, ultimCapitol: capitolIdx + 1 };
    ESTAT._registreEstil.frequencies[w].count += 1;
    ESTAT._registreEstil.frequencies[w].ultimCapitol = capitolIdx + 1;
  });

  const reAttrib = /va\s+(dir|xiuxiuejar|cridar|respondre|murmurar|preguntar|ordenar|sentenciar|exclamar|sospirar|tallar|replicar|afegir)/gi;
  const matches = String(textCapitol || '').matchAll(reAttrib);
  for (const m of matches) {
    const v = `va ${String(m[1] || '').toLowerCase()}`;
    ESTAT._registreEstil.verbs_atribucio[v] = (ESTAT._registreEstil.verbs_atribucio[v] || 0) + 1;
  }

  const frases = obtenirFrases(textCapitol);
  const ultimes2 = frases.slice(-2).join(' ');
  if (ultimes2) {
    ESTAT._registreEstil.tancaments.push({ capitol: capitolIdx + 1, text: ultimes2 });
    if (ESTAT._registreEstil.tancaments.length > 30) ESTAT._registreEstil.tancaments = ESTAT._registreEstil.tancaments.slice(-30);
  }
}

function generarAlertesEstil() {
  if (!ESTAT._registreEstil || typeof ESTAT._registreEstil !== 'object') {
    ESTAT._registreEstil = { frequencies: {}, alertes: [], verbs_atribucio: {}, tancaments: [] };
  }

  const alertes = [];
  const capitolsTotals = Math.max(1, (ESTAT._capitols_generats || []).filter(t => t && t.trim()).length);

  Object.entries(ESTAT._registreEstil.frequencies || {}).forEach(([paraula, dades]) => {
    const count = Number(dades && dades.count ? dades.count : 0);
    const mitjana = count / capitolsTotals;
    if (mitjana > 2) {
      alertes.push(`ALERTA: '${paraula}' s'ha usat ${count} cops en ${capitolsTotals} capÃ­tols. Busca sinÃ²nims o reformulacions.`);
    }
  });

  const verbs = ESTAT._registreEstil.verbs_atribucio || {};
  const totalVerbs = Object.values(verbs).reduce((a, b) => a + Number(b || 0), 0);
  if (totalVerbs > 0) {
    Object.entries(verbs).forEach(([verb, count]) => {
      const pct = (Number(count || 0) / totalVerbs) * 100;
      if (pct > 30) {
        alertes.push(`ALERTA: '${verb}' domina els diÃ legs (${pct.toFixed(1)}% de les atribucions). Varia: considerar, murmurar, replicar, tallar, sentenciar...`);
      }
    });
  }

  const tancaments = Array.isArray(ESTAT._registreEstil.tancaments) ? ESTAT._registreEstil.tancaments.slice(-3) : [];
  if (tancaments.length === 3) {
    const nomProta = String(ESTAT.protagonistaTriat || '').toLowerCase();
    const patrons = ["ja no era", "era el", "era la", "havia deixat de ser", "s'havia convertit"];
    const totsPatro = tancaments.every(t => {
      const txt = String((t && t.text) || '').toLowerCase();
      const teNom = nomProta ? txt.includes(nomProta) : /\b(protagonista|maja)\b/.test(txt);
      const tePatro = patrons.some(p => txt.includes(p));
      return teNom && tePatro;
    });
    if (totsPatro) {
      alertes.push("ALERTA: Els Ãºltims 3 capÃ­tols acaben amb sentÃ¨ncies metafÃ²riques sobre la protagonista. Trenca el patrÃ³: prova acabar amb una imatge, una acciÃ³, un diÃ leg, o un canvi de punt de vista.");
    }
  }

  ESTAT._registreEstil.alertes = alertes;
  return alertes;
}

function buildBlocAlertesEstil() {
  const alertes = generarAlertesEstil();
  if (!alertes || alertes.length === 0) return '';
  return `ALERTES D'ESTIL ACTIVES (basat en l'anÃ lisi acumulada dels capÃ­tols anteriors):
${alertes.map(a => `- ${a}`).join('\n')}
Respecta aquestes alertes per mantenir la frescor de la prosa.`;
}

function normalitzarBeatNarratiu(beat) {
  const b = String(beat || '')
    .toLowerCase()
    .normalize('NFD').replace(/[Ì€-Í¯]/g, '')
    .replace(/[^a-z0-9_\s-]/g, ' ')
    .replace(/\s+/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_+|_+$/g, '');
  return b.slice(0, 60);
}

function esBeatNarratiuTrivial(beat) {
  const b = String(beat || '').toLowerCase();
  return /^(caminar|parlar|mirar|entrar|sortir|respirar|pensar)$/.test(b)
    || /(^|[_\s-])(caminar|parlar|mirar)([_\s-]|$)/.test(b);
}

function buildBlocBeatsNarratiusProhibits() {
  const beats = (ESTAT._nkg && Array.isArray(ESTAT._nkg.beats_gastats)) ? ESTAT._nkg.beats_gastats : [];
  if (beats.length === 0) return '';
  const lines = beats.slice(-30).map(b => `- ${b}`);
  return `BEATS NARRATIUS PROHIBITS â€” Aquests recursos dramÃ tics ja s'han utilitzat en capÃ­tols anteriors. NO els repeteixis ni en variaciÃ³. Troba alternatives originals:
${lines.join('\n')}

Si l'escaleta del capÃ­tol actual requereix una acciÃ³ similar a un beat prohibit, REIMAGINA'L amb una mecÃ nica diferent.`;
}

async function actualitzarBeatsNarratiusGastats(textCapitol, capitolNum, userConfig = USER_CONFIG) {
  if (!ESTAT._nkg) return;
  if (!Array.isArray(ESTAT._nkg.beats_gastats)) ESTAT._nkg.beats_gastats = [];
  const txt = String(textCapitol || '').trim();
  if (!txt) return;

  const msgs = [{
    role: 'user',
    content: `Analitza el capÃ­tol segÃ¼ent i extreu els BEATS NARRATIUS CLAU: accions dramÃ tiques Ãºniques, girs de guiÃ³, revelacions, confrontacions o moments climÃ tics que JA S'HAN CONSUMIT i que NO s'haurien de repetir en capÃ­tols futurs. Format: array JSON de strings curts i descriptius.
Exemples: 'protagonista_prem_enviar_dades', 'descoberta_factura_pes', 'confrontacio_directa_antagonista_passadis', 'trucada_testament_exmarit'.
Retorna NOMÃ‰S el JSON array, res mÃ©s.

CAPÃTOL ${capitolNum}:
${txt.slice(0, 14000)}`
  }];

  try {
    const models = getModelConfig(userConfig || USER_CONFIG || {});
    const raw = await callLLMMulti(
      msgs,
      'Ets una analista de beats narratius. Retorna exclusivament JSON array.',
      Object.assign({}, userConfig || USER_CONFIG || {}, { maxTokens: 900, model: models.modelArquitecte }),
      'arquitectura'
    );
    let parsed = parseJsonRobust(raw);
    if (!Array.isArray(parsed)) {
      try { parsed = JSON.parse(String(raw || '').trim()); } catch { parsed = []; }
    }
    const nous = Array.isArray(parsed) ? parsed : [];
    const filtrats = nous
      .map(normalitzarBeatNarratiu)
      .filter(Boolean)
      .filter(b => b.length <= 60)
      .filter(b => !esBeatNarratiuTrivial(b));

    const set = new Set(ESTAT._nkg.beats_gastats);
    filtrats.forEach(b => set.add(b));
    ESTAT._nkg.beats_gastats = Array.from(set).slice(-30);
  } catch (err) {
    console.warn('Beats narratius: error no bloquejant:', err.message);
  }
}


function calcularPressioDeTancament(capitolActualIdx) {
  const totalCapitols = Number(ESTAT._nombreCapitols || (ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols.length : 0) || 0);
  const reg = ESTAT.llibreRegistre || {};
  const filsObertsArr = Array.isArray(reg.fils_oberts) ? reg.fils_oberts : [];
  const filsTancatsArr = Array.isArray(reg.fils_tancats) ? reg.fils_tancats : [];
  const capitolsRestants = Math.max(0, totalCapitols - capitolActualIdx - 1);
  const filsOberts = filsObertsArr.length;
  const ratio = filsOberts / Math.max(capitolsRestants, 1);
  const filsPerCapitol = Math.ceil(filsOberts / Math.max(capitolsRestants, 1));

  let pressio = 'baixa';
  if (capitolsRestants === 0) pressio = 'critica';
  else if (capitolsRestants <= 2) pressio = 'alta';
  else if (capitolsRestants <= 4) pressio = 'mitjana';

  return {
    totalCapitols,
    capitolsRestants,
    filsOberts,
    filsTancats: filsTancatsArr.length,
    ratio,
    filsPerCapitol,
    pressio,
    filsObertsArr,
    filsTancatsArr
  };
}

function classificarPrioritatFil(filTxt) {
  const f = String(filTxt || '').toLowerCase();
  const nomsPrincipals = [ESTAT.protagonistaTriat]
    .concat((ESTAT._personatgesSeleccionats || []).slice(0, 3))
    .filter(Boolean)
    .map(n => String(n).toLowerCase());
  if (nomsPrincipals.some(n => n && f.includes(n))) return 'alta';
  if (/(trama principal|protagon|antagon|climax|conflicte central|arc)/.test(f)) return 'alta';
  if (/(subtrama|secundari|aliat|famili|amic|mentor)/.test(f)) return 'mitjana';
  return 'baixa';
}

function generarDirectivaFils(capitolActualIdx) {
  const d = calcularPressioDeTancament(capitolActualIdx);
  const oberts = d.filsObertsArr || [];
  if (oberts.length === 0) return "DIRECTIVA DE FILS: No hi ha fils oberts al registre. MantÃ©n la coherÃ¨ncia i evita obrir-ne de nous innecessaris.";

  const alta = [];
  const mitjana = [];
  const baixa = [];
  oberts.forEach(f => {
    const p = classificarPrioritatFil(f);
    if (p === 'alta') alta.push(f);
    else if (p === 'mitjana') mitjana.push(f);
    else baixa.push(f);
  });

  if (d.pressio === 'baixa') {
    return `Fils narratius actius (referÃ¨ncia): ${oberts.slice(0, 10).join(' | ')}. No cal tancar-los tots, perÃ² no els contradiguis.`;
  }

  if (d.pressio === 'mitjana') {
    const minim = Math.max(2, d.filsPerCapitol);
    return `DIRECTIVA DE FILS: Queden ${d.capitolsRestants} capÃ­tols. Fils oberts: ${d.filsOberts}. Aquest capÃ­tol HA DE tancar o avanÃ§ar significativament un mÃ­nim de ${minim} dels fils segÃ¼ents (en ordre de prioritat):
PRIORITAT ALTA: ${alta.length ? alta.join(' | ') : '(cap detectada)'}
PRIORITAT MITJANA: ${mitjana.length ? mitjana.join(' | ') : '(cap detectada)'}
Per tancar un fil, necessites: resoluciÃ³ explÃ­cita, menciÃ³ del destÃ­ del personatge/situaciÃ³, o tancament temÃ tic.`;
  }

  const prioritats = [...alta, ...mitjana].slice(0, Math.max(4, d.filsPerCapitol));
  const menors = baixa.slice(0, 8);
  return `URGÃˆNCIA NARRATIVA: Aquest Ã©s un dels ${Math.max(d.capitolsRestants, 1)} Ãºltims capÃ­tols. Hi ha ${d.filsOberts} fils sense resoldre. Ã‰s IMPERATIU que aquest capÃ­tol resolgui o doni tancament a:
${prioritats.length ? prioritats.map(f => `- ${f}`).join('\n') : '- (prioritats no detectades)'}

Fils que es poden tancar amb una frase o menciÃ³ breu:
${menors.length ? menors.map(f => `- ${f}`).join('\n') : '- (cap fil menor)'}

Cap fil de PRIORITAT ALTA pot quedar obert al final de la novelÂ·la.`;
}

function buildSystemPromptCapitol() {
  const idxActual = Number(ESTAT._capitolActual || 0);
  const directivaContinuitat = generarDirectivaContinuitat(idxActual);
  const directivaFils = generarDirectivaFils(idxActual);
  const totalCapitolsPlanificats = Number(ESTAT._nombreCapitols || (ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols.length : 0) || 0);
  const capitolsRestants = Math.max(0, totalCapitolsPlanificats - idxActual - 1);
  const blocAntiProliferacioFils = capitolsRestants <= 3
    ? "PROHIBIT OBRIR FILS NOUS: A partir d'aquest punt, no introdueixis cap personatge nou, cap subtrama nova ni cap misteri nou. NomÃ©s tanca i resol."
    : '';
  const capitolsRegistre = (ESTAT.llibreRegistre && Array.isArray(ESTAT.llibreRegistre.capitols))
    ? ESTAT.llibreRegistre.capitols
    : [];
  const r1 = idxActual - 1 >= 0 ? capitolsRegistre[idxActual - 1] : null;
  const r2 = idxActual - 2 >= 0 ? capitolsRegistre[idxActual - 2] : null;
  const prohibirIniciMeteorologic = !!(r1 && r2 && r1.inici_meteorologic === true && r2.inici_meteorologic === true);

  // PONT NKG: quan el NKG Ã©s actiu, system prompt reduÃ¯t (el context va al prompt d'escena)
  if (ESTAT._nkg) {
    const parts = [];
    parts.push(getSystemPromptNovella(ESTAT.tematica));
    parts.push(buildBriefNarratiu());

    if (ESTAT.worldbuilding) {
      parts.push('\nBÃBLIA DE MÃ“N (regles, geografies i lleis de l\'univers â€” NO contradir):\n' + ESTAT.worldbuilding.substring(0, 1200) + (ESTAT.worldbuilding.length > 1200 ? '\n[â€¦]' : ''));
    }

    if (ESTAT.estilsParla) {
      parts.push('\nESTILS DE PARLA DELS PERSONATGES:\n' + ESTAT.estilsParla.substring(0, 2000));
      const ctxPsico = construirContextPsicologicPersonatges(10);
      if (ctxPsico) {
        parts.push(`\nESTAT ANIMIC ACTUAL: Adapta l'estil de veu base de cada personatge al seu estat d'Ã nim actual. Per exemple, si el seu estil Ã©s 'frases curtes i analÃ­tiques' perÃ² el seu estat anÃ­mic actual Ã©s 'pÃ nic absolut', la seva veu ha de reflectir el pÃ nic perdent l'estructura analÃ­tica.\n\nPERSONATGES (nom, estil_veu, perfil_psicologic, estat_animic_actual):\n${ctxPsico}`);
      }
    }
    if (ESTAT._goldenPassage) {
      parts.push('\nREFERÃˆNCIA DE VEU (escriu amb aquest to):\n' + ESTAT._goldenPassage.substring(0, 800));
    }
    if (ESTAT._capitols_generats.filter(t => t).length >= 3) {
      const repsDetectades = detectarRepeticions();
      if (repsDetectades) {
        const trigrames = repsDetectades.trigrames || [];
        const bigrames = repsDetectades.bigrames || [];
        const evitar = [...trigrames.slice(0,5), ...bigrames.slice(0,5)].map(([ng]) => `"${ng}"`);
        if (evitar.length > 0) parts.push(`\nEXPRESSIONS A EVITAR (massa repetides): ${evitar.join(', ')}`);
      }
      const repsTematiques = detectarRepeticionsTematiques();
      if (repsTematiques) {
        parts.push('\nREGLA ANTI-REDUNDÃ€NCIA EMOCIONAL: Els personatges ja han tingut les revelacions emocionals segÃ¼ents i NO poden "redescobrir-les": ' +
          repsTematiques.map(r => `"${r.tema}" (caps. ${r.capitols.join(', ')})`).join('; ') +
          '. Si un personatge ja ha tingut una revelaciÃ³ emocional en un capÃ­tol anterior, NO pot "redescobrir" el mateix. Ha de: (a) actuar en conseqÃ¼Ã¨ncia, (b) descobrir una capa NOVA del problema, o (c) intentar negar-ho i fracassar. La repeticiÃ³ de la mateixa epifania Ã©s la mort del ritme narratiu.');
      }
    }
    if (ESTAT._manualEstil) {
      const m = ESTAT._manualEstil;
      const linies = [];
      if (m.longitud_frases) linies.push(`â€¢ Longitud de frases: ${m.longitud_frases}`);
      if (m.estil_dialeg) linies.push(`â€¢ DiÃ leg: ${m.estil_dialeg}`);
      if (m.sensorialitat) linies.push(`â€¢ Sensorialitat: ${m.sensorialitat}`);
      if (m.ritme) linies.push(`â€¢ Ritme: ${m.ritme}`);
      if (m.vocabulari) linies.push(`â€¢ Vocabulari: ${m.vocabulari}`);
      if (linies.length > 0) parts.push('\nMANUAL D\'ESTIL DE REFERÃˆNCIA:\n' + linies.join('\n'));
    }
    const autorRef = String((ESTAT.configProjecte && ESTAT.configProjecte.autor_referencia) || '').toLowerCase();
    const modeTolkien = /tolkien/.test(autorRef);
    const modeCastaneda = /castaneda/.test(autorRef);
    const tensioActiva = (ESTAT._corbaTensio || []).find(t => t.capitol === (Number(ESTAT._capitolActual || 0) + 1));
    if (modeTolkien) {
      parts.push('\nINTENSITAT NARRATIVA (MODE TOLKIEN): Prioritza gravetat mÃ­tica, memÃ²ria del paisatge i pes moral de les decisions. La tensiÃ³ no ha de ser sempre frenÃ¨tica: alterna amplitud Ã¨pica, respiraciÃ³ lÃ­rica i conseqÃ¼Ã¨ncia histÃ²rica.');
    } else if (modeCastaneda) {
      parts.push("\nINTENSITAT NARRATIVA (MODE CASTANEDA): Prioritza desplaÃ§ament perceptiu, ambigÃ¼itat ontolÃ²gica i procÃ©s iniciÃ tic. La tensiÃ³ pot ser interior i cognitiva: sostÃ©n silencis, paradoxes i fractures de percepciÃ³ sense accelerar artificialment l'acciÃ³.");
    } else if (tensioActiva && Number(tensioActiva.nivell) > 7) {
      parts.push("\nCONTROL DE CONTRAST SENSORIAL (NKG>7): Trenca qualsevol fredor comptable amb detalls viscerals o orgÃ nics (olors, suor, brutÃ­cia, reaccions fÃ­siques involuntÃ ries). Quan la tensiÃ³ Ã©s alta, aquests detalls sÃ³n OBLIGATORIS i han d'entrar dins l'acciÃ³.");
    } else {
      parts.push('\nCONTROL DE CONTRAST SENSORIAL: Evita la prosa asÃ¨ptica. Integra textura fÃ­sica i sensorial (cos, entorn, fricciÃ³ material) per humanitzar la tensiÃ³.');
    }
    parts.push("\nREGLA D'ESTIL OBLIGATÃ’RIA (SHOW, DON'T TELL): Tens totalment prohibit utilitzar etiquetes emocionals explÃ­cites per descriure com se sent un personatge (ex: prohibit dir \"estava trist\", \"se sentia enfadat\", \"estava nerviÃ³s\"). En comptes d'aixÃ², has de MOSTRAR l'emociÃ³ a travÃ©s d'accions fÃ­siques, interaccions amb objectes, vestimenta, llenguatge corporal o detalls de l'entorn.");
    parts.push("\nREGLA DE CONTINUITAT OBLIGATÃ’RIA: Llevat que se t'indiqui explÃ­citament que Ã©s el final del capÃ­tol, NO tanquis artificialment l'energia narrativa. MantÃ©n continuÃ¯tat orgÃ nica segons el to de l'obra: suspens d'acciÃ³, ressonÃ ncia lÃ­rica, o desplaÃ§ament perceptiu; la segÃ¼ent generaciÃ³ ha de poder recollir el testimoni de forma natural.");
        const blocBeatsProhibits = buildBlocBeatsNarratiusProhibits();
    if (blocBeatsProhibits) parts.push('\n' + blocBeatsProhibits);
    const blocAlertesEstil = buildBlocAlertesEstil();
    if (blocAlertesEstil) parts.push('\n' + blocAlertesEstil);
    const blocLongitud = buildBlocAlertaLongitud();
    if (blocLongitud) parts.push('\n' + blocLongitud);
    if (directivaFils) parts.push('\n' + directivaFils);
    if (blocAntiProliferacioFils) parts.push('\n' + blocAntiProliferacioFils);
    if (directivaContinuitat) parts.push('\n' + directivaContinuitat);
    if (ESTAT._controlLongitud && ESTAT._controlLongitud.promptForcat) parts.push('\n' + ESTAT._controlLongitud.promptForcat);
    if (prohibirIniciMeteorologic) {
      parts.push("PROHIBIT comenÃ§ar descrivint el temps atmosfÃ¨ric. ComenÃ§a 'in media res' o amb un diÃ leg.");
    }
    return parts.join('\n');
  }
  // ESTAT._nkg Ã©s sempre truthy en producciÃ³; la branca no-NKG s'ha eliminat
  return '';
}

function buildRegistreContextLegacy(idx) {
  const reg = ESTAT.llibreRegistre;
  if (!reg || !(reg.capitols || []).some(c => c)) return '';

  const parts = ['ESTAT ACTUAL DEL REGISTRE NARRATIU:'];

  if (reg.estat_personatges && reg.estat_personatges.length > 0) {
    parts.push('Personatges i ubicacions actuals:');
    reg.estat_personatges.forEach(p => parts.push(`- ${p.nom}: ${p.ubicacio} (${p.estat_actual})`));
  }

  if (reg.fils_oberts && reg.fils_oberts.length > 0) {
    parts.push('\nFils narratius oberts (OBLIGATORI tractar en aquest capÃ­tol o deixar explÃ­citament obert):');
    reg.fils_oberts.forEach(f => parts.push(`- ${f}`));
  }

  // Ãšltims 2 resums de capÃ­tol
  const capsFets = (reg.capitols || []).filter(c => c);
  if (capsFets.length > 0) {
    const recents = capsFets.slice(-2);
    parts.push('\nResums dels darrers capÃ­tols:');
    recents.forEach(c => {
      const capNum = (reg.capitols || []).indexOf(c) + 1;
      parts.push(`CapÃ­tol ${capNum}: ${c.resum_capitol}`);
    });
  }

  return '\n' + parts.join('\n');
}

function buildRegistreContext(idx) {
  // PONT NKG: el context ve del NKG (nkgGenerarContextMinim) quan Ã©s actiu
  if (ESTAT._nkg) return '';
  return buildRegistreContextLegacy(idx);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 4: Control de Ritme i TensiÃ³
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function obtenirInstruccionsDeTensio(nivellTensio) {
  const nivell = Math.max(1, Math.min(10, Number(nivellTensio) || 5));
  if (nivell <= 3) {
    return `ESTIL I RITME: TensiÃ³ baixa (${nivell}/10). Escriu amb un ritme pausat. Crea una atmosfera introspectiva, centra't en descripcions sensorials riques de l'entorn i allarga els parÃ grafs. Deixa que els personatges reflexionin.`;
  }
  if (nivell <= 7) {
    return `ESTIL I RITME: TensiÃ³ mitjana (${nivell}/10). Ritme equilibrat. Combina diÃ leg fluid amb accions concretes. L'escena ha d'avanÃ§ar de manera constant cap al seu objectiu.`;
  }
  return `ESTIL I RITME: TensiÃ³ alta (${nivell}/10). Ritme frenÃ¨tic. Utilitza frases mÃ©s curtes i contundents. Elimina descripcions innecessÃ ries. L'acciÃ³ i la urgÃ¨ncia sÃ³n primordials.`;
}

function getInstruccionsRitme(nivell, tipus) {
  const base = obtenirInstruccionsDeTensio(nivell);
  return tipus ? `${base} Focus de corba: ${tipus}.` : base;
}


function obtenirTextEnllac(textEscenaAnterior) {
  const raw = String(textEscenaAnterior || '').replace(/\r/g, '').trim();
  if (!raw) return '';

  // Neteja marcadors tÃ¨cnics i lÃ­nies de metadades que poden contaminar el punt d'enganx.
  const net = raw
    .replace(/\[\[ESCENA_\d+\]\]/g, '')
    .split('\n')
    .filter(l => !/^\s*(ESCENA\s+\d+|CAP[IÃ]TOL\s+\d+)\b/i.test(l.trim()))
    .join('\n')
    .trim();

  if (!net) return '';

  const paragrafs = net.split(/\n\s*\n+/).map(p => p.trim()).filter(Boolean);
  if (paragrafs.length === 0) return '';

  // Prioritza els darrers 2-3 parÃ grafs; si sÃ³n molt curts, completa fins ~1000 carÃ cters.
  let text = paragrafs.slice(-3).join('\n\n').trim();
  if (text.length < 600 && paragrafs.length > 3) {
    text = paragrafs.slice(-4).join('\n\n').trim();
  }

  const maxChars = 1000;
  if (text.length > maxChars) {
    text = text.slice(-maxChars).trim();
    const idx = text.indexOf('\n\n');
    if (idx > 0 && idx < 250) text = text.slice(idx + 2).trim();
  }

  return text;
}

function determinarTipusTransicio(escenaAnterior, escenaActual) {
  if (!escenaAnterior) return 'continuacio_directa';

  const llocAnt = (escenaAnterior.lloc || escenaAnterior.localitzacio || '').trim().toLowerCase();
  const llocAct = (escenaActual.lloc || escenaActual.localitzacio || '').trim().toLowerCase();
  const canviLloc = llocAnt && llocAct && llocAnt !== llocAct;

  const pistaSalt = `${escenaActual?.nom || ''} ${escenaActual?.funcio_narrativa || ''} ${escenaActual?.beat_narratiu || ''}`
    .toLowerCase();
  const teSaltTemporal = /(m[eÃ©]s\s+tard|hores\s+despr[eÃ©]s|l'?endem[aÃ ]|dies\s+despr[eÃ©]s|setmanes\s+despr[eÃ©]s|mentrestant|temps\s+despr[eÃ©]s|al\s+cap\s+de)/.test(pistaSalt);

  if (canviLloc || teSaltTemporal) return 'salt_temporal';
  return 'continuacio_directa';
}


function buildInstruccionsTransicio(textEnllac, tipusTransicio) {
  if (!textEnllac) return '';

  let instruccionsTransicio = `TEXT ANTERIOR (PUNT D'ENGANX): AixÃ­ Ã©s com ha acabat l'escena just anterior:
"${textEnllac}"

`;

  if (tipusTransicio === 'salt_temporal') {
    instruccionsTransicio += `INSTRUCCIÃ“ DE TRANSICIÃ“: Inicia aquesta escena fent una transiciÃ³ temporal o espacial elegant respecte al text anterior. Fes servir el primer parÃ graf per situar el lector en el nou context sense fer un tall abrupte.
`;
  } else {
    instruccionsTransicio += `INSTRUCCIÃ“ DE TRANSICIÃ“: L'acciÃ³ d'aquesta nova escena continua EXACTAMENT en el mateix lloc i segon on ho ha deixat el text anterior. El teu primer parÃ graf ha de ser una continuaciÃ³ completament fluida i natural d'aquest punt d'enganx, mantenint la mateixa cadÃ¨ncia literÃ ria. No facis introduccions, segueix l'acciÃ³.
`;
  }

  return instruccionsTransicio;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 5: Sistema de PrefiguraciÃ³
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getPrefiguracionsActives(idx, estat = ESTAT) {
  const prefs  = estat._prefiguracions || [];
  const capNum = idx + 1;
  const aPlantarAra      = prefs.filter(p => p.plantada_capitol === capNum);
  const aRecollirAra     = prefs.filter(p => p.resolucio_capitol === capNum);
  const plantadesNoResoltes = prefs.filter(p =>
    p.plantada_capitol < capNum && p.resolucio_capitol > capNum
  );
  return { aPlantarAra, aRecollirAra, plantadesNoResoltes };
}

function llistarPrefiguracions() {
  const prefs = ESTAT._prefiguracions || [];
  if (prefs.length === 0) return '(Cap prefiguraciÃ³ planificada)';
  return prefs.map(p =>
    `Cap.${p.plantada_capitol}â†’${p.resolucio_capitol}: ${p.element || ''}`
  ).join('\n');
}

function obtenirUbicacioEscaletaCapitol(idx) {
  const cap = ESTAT._estructuraCapitols && ESTAT._estructuraCapitols[idx] ? ESTAT._estructuraCapitols[idx] : null;
  const escaletaCap = (ESTAT._escaletes || []).find(e => e.capitol === idx + 1);
  const escena0 = escaletaCap && Array.isArray(escaletaCap.escenes) ? escaletaCap.escenes[0] : null;
  return (escena0 && (escena0.lloc || escena0.localitzacio || escena0.ubicacio)) || (cap && cap.localitzacio) || '';
}

async function validarIReomplirEscaleta(idxCapitol, userConfig) {
  const escaletaCap = (ESTAT._escaletes || []).find(e => e.capitol === idxCapitol + 1);
  if (!escaletaCap || !Array.isArray(escaletaCap.escenes)) return;

  // Comprovar si les escenes tenen contingut real
  const escenesBuides = escaletaCap.escenes.filter(sc =>
    !sc || !sc.nom || !sc.funcio_narrativa || String(sc.nom).trim().length < 3
  );
  if (escenesBuides.length === 0 && escaletaCap.escenes.length >= 3) return; // escaleta vÃ lida

  console.warn(`Escaleta cap. ${idxCapitol + 1}: ${escenesBuides.length} escenes buides. Reomplintâ€¦`);

  const reg = ESTAT.llibreRegistre || {};
  const beatsGastats = Array.isArray(ESTAT._nkg && ESTAT._nkg.beats_gastats)
    ? ESTAT._nkg.beats_gastats.slice(-6) : [];
  const filsTancats = Array.isArray(reg.fils_tancats) ? reg.fils_tancats.slice(-5) : [];
  const snapshotAnterior = idxCapitol > 0 ? (ESTAT._snapshotsFinals || {})[idxCapitol - 1] : null;
  const resumAnterior = idxCapitol > 0 && reg.capitols && reg.capitols[idxCapitol - 1]
    ? reg.capitols[idxCapitol - 1].resum_capitol || '' : '';
  const cap = (ESTAT._estructuraCapitols && ESTAT._estructuraCapitols[idxCapitol]) || {};
  const tensio = (ESTAT._corbaTensio || []).find(t => t.capitol === idxCapitol + 1);

  const msgs = [{
    role: 'user',
    content: `Genera una escaleta detallada per al capÃ­tol ${idxCapitol + 1}: "${cap.titol || ''}".

RESUM DEL CAPÃTOL ANTERIOR:
${resumAnterior || '(primer capÃ­tol)'}

SNAPSHOT DE CONTINUÃTAT (final del cap. anterior):
${snapshotAnterior
  ? `UbicaciÃ³: ${snapshotAnterior.ubicacio}\nEstat emocional: ${snapshotAnterior.estat_emocional}\nSituaciÃ³: ${snapshotAnterior.situacio_immediata}`
  : '(no disponible)'}

BEATS JA GASTATS (NO repetir):
${beatsGastats.map(b => `- ${b}`).join('\n') || '(cap)'}

FILS JA TANCATS (NO reobrir):
${filsTancats.map(f => `- ${f}`).join('\n') || '(cap)'}

NIVELL DE TENSIÃ“: ${tensio ? tensio.nivell + '/10 (' + (tensio.tipus || '') + ')' : '(no definit)'}

Genera entre 5 i 7 escenes. Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "escenes": [
    {
      "nom": "tÃ­tol breu (3-5 paraules)",
      "paraules_objectiu": 600,
      "funcio_narrativa": "una frase curta",
      "personatges": ["nom1"],
      "beat_narratiu": "diÃ leg"
    }
  ]
}`
  }];

  const models = getModelConfig(userConfig || USER_CONFIG);
  const raw = await callLLMMulti(
    msgs,
    'Ets un dramaturg expert en narrativa. Respon EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig || USER_CONFIG, { maxTokens: 1200, model: models.modelArquitecte }),
    'arquitectura'
  );
  const dades = parseJsonRobust(raw);
  if (dades && Array.isArray(dades.escenes) && dades.escenes.length >= 3) {
    escaletaCap.escenes = dades.escenes;
    console.log(`Escaleta cap. ${idxCapitol + 1} reomperta: ${dades.escenes.length} escenes.`);
  }
}

function normalitzarUbicacioContinuitat(txt) {
  return String(txt || '')
    .normalize('NFD')
    .replace(/[Ì€-Í¯]/g, '')
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

async function generarSnapshotFinalCapitol(capitolIdx, userConfig = USER_CONFIG) {
  if (!ESTAT._snapshotsFinals || typeof ESTAT._snapshotsFinals !== 'object') ESTAT._snapshotsFinals = {};

  const textCapitol = (ESTAT._capitols_generats && ESTAT._capitols_generats[capitolIdx])
    ? String(ESTAT._capitols_generats[capitolIdx])
    : '';
  if (!textCapitol.trim()) return null;

  const protagonist = ESTAT.protagonistaTriat || 'la protagonista';
  const msgs = [{
    role: 'user',
    content: `Extreu un snapshot de continuÃ¯tat del FINAL del capÃ­tol ${capitolIdx + 1}.

PROTAGONISTA: ${protagonist}

CAPÃTOL COMPLET:
${textCapitol.slice(-14000)}

Retorna EXCLUSIVAMENT JSON vÃ lid amb aquesta forma:
{
  "ubicacio": "Lloc fÃ­sic exacte on acaba el personatge",
  "hora_narrativa": "Hora/moment del dia aproximat",
  "estat_emocional": "Estat psicolÃ²gic en acabar el capÃ­tol",
  "situacio_immediata": "QuÃ¨ estÃ  passant exactament al tancament",
  "objectes_rellevants": ["llista d'objectes que porta o ha perdut"],
  "ultimes_3_frases": "Les 3 Ãºltimes frases del capÃ­tol (literal)"
}`
  }];

  try {
    const models = getModelConfig(userConfig || USER_CONFIG || {});
    const raw = await callLLMMulti(
      msgs,
      "Ets una analista de continuÃ¯tat narrativa. Respon nomÃ©s JSON.",
      Object.assign({}, userConfig || USER_CONFIG || {}, { maxTokens: 900, model: models.modelArquitecte }),
      'arquitectura'
    );
    const parsed = parseJsonRobust(raw) || {};
    const snapshot = {
      ubicacio: String(parsed.ubicacio || '').trim() || 'No determinat',
      hora_narrativa: String(parsed.hora_narrativa || '').trim() || 'No determinat',
      estat_emocional: String(parsed.estat_emocional || '').trim() || 'No determinat',
      situacio_immediata: String(parsed.situacio_immediata || '').trim() || 'No determinat',
      objectes_rellevants: Array.isArray(parsed.objectes_rellevants) ? parsed.objectes_rellevants.map(o => String(o || '').trim()).filter(Boolean) : [],
      ultimes_3_frases: String(parsed.ultimes_3_frases || '').trim() || textCapitol.split(/(?<=[.!?â€¦])\s+/).slice(-3).join(' ').trim(),
      protagonista: protagonist
    };
    ESTAT._snapshotsFinals[capitolIdx] = snapshot;
    return snapshot;
  } catch (err) {
    console.warn('Snapshot final capÃ­tol: error no bloquejant:', err.message);
    return null;
  }
}

async function generarSnapshotValidat(idx, textCapitol, userConfig) {
  if (!ESTAT._snapshotsFinals || typeof ESTAT._snapshotsFinals !== 'object') ESTAT._snapshotsFinals = {};
  if (!textCapitol || !textCapitol.trim()) return null;

  const campsBuids = (snap) => !snap ||
    ['ubicacio', 'hora_narrativa', 'estat_emocional', 'situacio_immediata'].some(c => !snap[c] || snap[c] === 'No determinat');

  const protagonist = ESTAT.protagonistaTriat || 'la protagonista';
  const ultimes800 = textCapitol.trim().split(/\s+/).slice(-800).join(' ');

  let snapshot = null;
  try {
    const models = getModelConfig(userConfig || USER_CONFIG || {});
    const msgs = [{
      role: 'user',
      content: `Extreu un snapshot de continuÃ¯tat del FINAL del capÃ­tol ${idx + 1}.

PROTAGONISTA: ${protagonist}

FINAL DEL CAPÃTOL (Ãºltimes 800 paraules):
${ultimes800}

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "ubicacio": "Lloc fÃ­sic exacte on acaba el personatge",
  "hora_narrativa": "Hora/moment del dia aproximat",
  "estat_emocional": "Estat psicolÃ²gic en acabar el capÃ­tol",
  "situacio_immediata": "QuÃ¨ estÃ  passant exactament al tancament",
  "objectes_rellevants": ["objectes que porta o ha perdut"],
  "ultimes_3_frases": "Les 3 Ãºltimes frases del capÃ­tol (literal)"
}`
    }];
    const raw = await callLLMMulti(
      msgs,
      'Ets una analista de continuÃ¯tat narrativa. Respon nomÃ©s JSON.',
      Object.assign({}, userConfig || USER_CONFIG || {}, { maxTokens: 600, model: models.modelArquitecte }),
      'arquitectura'
    );
    const parsed = parseJsonRobust(raw) || {};
    snapshot = {
      ubicacio:           String(parsed.ubicacio           || '').trim(),
      hora_narrativa:     String(parsed.hora_narrativa     || '').trim(),
      estat_emocional:    String(parsed.estat_emocional    || '').trim(),
      situacio_immediata: String(parsed.situacio_immediata || '').trim(),
      objectes_rellevants: Array.isArray(parsed.objectes_rellevants) ? parsed.objectes_rellevants.map(o => String(o || '').trim()).filter(Boolean) : [],
      ultimes_3_frases:   String(parsed.ultimes_3_frases  || '').trim(),
      protagonista:       protagonist
    };
  } catch (err) {
    console.warn('generarSnapshotValidat: error LLM, aplicant fallback:', err.message);
  }

  // Fallback per camps buits: extreure les Ãºltimes 3 frases del text
  if (campsBuids(snapshot)) {
    const frases = textCapitol.split(/(?<=[.!?â€¦])\s+/).filter(f => f.trim().length > 10);
    const ultimes3 = frases.slice(-3).join(' ').trim();
    snapshot = {
      ubicacio:           snapshot?.ubicacio           || 'No determinat',
      hora_narrativa:     snapshot?.hora_narrativa     || 'No determinat',
      estat_emocional:    snapshot?.estat_emocional    || 'No determinat',
      situacio_immediata: snapshot?.situacio_immediata || ultimes3.substring(0, 300) || 'No determinat',
      objectes_rellevants: snapshot?.objectes_rellevants || [],
      ultimes_3_frases:   snapshot?.ultimes_3_frases   || ultimes3,
      protagonista:       protagonist,
      _fallback:          true
    };
  }

  ESTAT._snapshotsFinals[idx] = snapshot;
  return snapshot;
}

function generarDirectivaContinuitat(capitolIdx) {
  if (capitolIdx <= 0) return '';
  if (!ESTAT._snapshotsFinals || typeof ESTAT._snapshotsFinals !== 'object') ESTAT._snapshotsFinals = {};

  const snapshotAnterior = ESTAT._snapshotsFinals[capitolIdx - 1];
  if (!snapshotAnterior) return '';

  const protagonista = snapshotAnterior.protagonista || ESTAT.protagonistaTriat || 'la protagonista';
  const ubicacioAnterior = snapshotAnterior.ubicacio || 'ubicaciÃ³ no determinada';
  const ubicacioNova = obtenirUbicacioEscaletaCapitol(capitolIdx) || 'ubicaciÃ³ no especificada';
  const mateixaUbicacio = normalitzarUbicacioContinuitat(ubicacioAnterior) === normalitzarUbicacioContinuitat(ubicacioNova);
  const objectes = Array.isArray(snapshotAnterior.objectes_rellevants) && snapshotAnterior.objectes_rellevants.length > 0
    ? snapshotAnterior.objectes_rellevants.join(', ')
    : 'cap objecte crÃ­tic';

  if (mateixaUbicacio) {
    return `CONTINUÃTAT: El capÃ­tol anterior va acabar amb ${protagonista} a ${ubicacioAnterior}, ${snapshotAnterior.situacio_immediata || 'en situaciÃ³ no especificada'}. Hora: ${snapshotAnterior.hora_narrativa || 'no determinada'}. Estat: ${snapshotAnterior.estat_emocional || 'no determinat'}. Objectes: ${objectes}. COMENÃ‡A exactament des d'aquest punt.`;
  }

  return `ALERTA DE CONTINUÃTAT: El capÃ­tol anterior va acabar amb ${protagonista} a ${ubicacioAnterior}, ${snapshotAnterior.situacio_immediata || 'en situaciÃ³ no especificada'}, ${snapshotAnterior.hora_narrativa || 'hora no determinada'}. El nou capÃ­tol se situa a ${ubicacioNova}. Ã‰S IMPERATIU que narris el desplaÃ§ament o facis una elÂ·lipsi temporal explÃ­cita a l'inici. NO pots comenÃ§ar com si el personatge ja fos allÃ  sense explicaciÃ³. Estat emocional previ: ${snapshotAnterior.estat_emocional || 'no determinat'}. El personatge NO pot reiniciar-se emocionalment sense motiu.`;
}

function filtrarContextFutur(capitolActualIdx) {
  // FUTURE MASKING
  const estatFiltrat = typeof structuredClone === 'function'
    ? structuredClone(ESTAT)
    : JSON.parse(JSON.stringify(ESTAT));
  const redactat = '[REDACTAT â€” Esdeveniment futur]';

  estatFiltrat._estructuraCapitols = (estatFiltrat._estructuraCapitols || []).map((capitol, i) => {
    if (i <= capitolActualIdx) return capitol;
    return {
      numero: capitol?.numero,
      titol: capitol?.titol,
      resum: redactat,
      prefiguracions_a_recollir: redactat,
      connexio_seguent: redactat,
      connexio_anterior: redactat
    };
  });

  estatFiltrat._corbaTensio = (estatFiltrat._corbaTensio || []).map(t => (
    t && t.capitol > capitolActualIdx + 1
      ? { ...t, nivell: redactat, tipus: redactat }
      : t
  ));

  if (estatFiltrat._arcMoral && typeof estatFiltrat._arcMoral === 'object') {
    if (estatFiltrat._arcMoral.punt_no_retorn && estatFiltrat._arcMoral.punt_no_retorn.capitol > capitolActualIdx) {
      estatFiltrat._arcMoral.punt_no_retorn = redactat;
    }
    if (estatFiltrat._arcMoral.cost_final && estatFiltrat._arcMoral.cost_final.capitol > capitolActualIdx) {
      estatFiltrat._arcMoral.cost_final = redactat;
    }
  }

  estatFiltrat.finalTriat = '[REDACTAT]';

  estatFiltrat._prefiguracions = (estatFiltrat._prefiguracions || []).map(p => (
    p && p.resolucio_capitol > capitolActualIdx
      ? { ...p, resolucio_capitol: redactat }
      : p
  ));

  return estatFiltrat;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 3: Context complet per a cada capÃ­tol
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function buildContextCapitolsComplets(idx, opts = {}, estat = ESTAT) {
  const entrades = [];
  (estat._capitols_generats || []).slice(0, idx).forEach((t, i) => {
    if (t && t.trim()) entrades.push({ idx: i, text: t });
  });
  if (entrades.length === 0) return '';

  // Pressupost aproximat: 4500 paraules representen uns 6000 tokens.
  // AixÃ² deixa prou espai lliure al prompt per la BÃ­blia de mÃ³n i l'escaleta.
  const MAX_PARAULES_CONTEXT = opts.maxParaules || 4500;
  let paraulesAcumulades = 0;
  const parts = [];

  // Recorrem els capÃ­tols de mÃ©s recent a mÃ©s antic
  for (let i = entrades.length - 1; i >= 0; i--) {
    const e = entrades[i];
    const textComplet = e.text.trim();
    const paraulesText = textComplet.split(/\s+/).length;

    // TIER 1: Si hi ha pressupost, posem el capÃ­tol sencer
    if (paraulesAcumulades + paraulesText <= MAX_PARAULES_CONTEXT) {
      parts.unshift(`### CAPÃTOL ${e.idx + 1}
${textComplet}`);
      paraulesAcumulades += paraulesText;
    } else {
      // TIER 2: Si ja no hi cap el text sencer, usem el resum del llibre de registre
      const reg = estat.llibreRegistre?.capitols?.[e.idx];
      let resum = reg?.resum_capitol || textComplet.slice(0, 1000) + '...';
      const paraulesResum = resum.split(/\s+/).length;

      if (paraulesAcumulades + paraulesResum <= MAX_PARAULES_CONTEXT) {
        parts.unshift(`### CAPÃTOL ${e.idx + 1} (Resum)
${resum}`);
        paraulesAcumulades += paraulesResum;
      } else {
        // TIER 3: Estem al lÃ­mit del pressupost. Afegim la memÃ²ria global comprimida per cobrir la resta i parem el bucle.
        const cobertaFinsCap = e.idx + 1;
        let memoriaText = '';

        if (estat._memoriasComprimides && estat._memoriasComprimides.length > 0) {
          const mem = [...estat._memoriasComprimides]
            .filter(m => m.finsCap <= cobertaFinsCap)
            .sort((a, b) => b.finsCap - a.finsCap)[0];
          if (mem && mem.text) memoriaText = mem.text;
        }
        if (!memoriaText && estat._resumCompacte) {
          memoriaText = estat._resumCompacte;
        }

        if (memoriaText) {
          parts.unshift(`### SINOPSI CAPÃTOLS 1â€“${cobertaFinsCap} (comprimida)
${memoriaText.trim()}`);
        } else {
          // Mini-fallback per evitar quedar-nos sense context inicial si no hi ha memÃ²ria
          parts.unshift(`### CAPÃTOLS 1â€“${cobertaFinsCap}
(Contingut omÃ¨s per mantenir el focus narratiu).`);
        }
        break; // Tallem l'addiciÃ³ de context antic per protegir el context window
      }
    }
  }

  return `

CAPÃTOLS ANTERIORS (Context dinÃ mic per pressupost de tokens):
${parts.join('\n\n')}`;
}

function buildContextCapitolLegacy(idx, skipRegistre = false, estat = ESTAT) {
  const parts = [];

  // 1) Fonaments globals: Brief + BÃ­blia + Trames
  const brief = buildBriefNarratiu();
  if (brief && brief.trim()) parts.push(brief);

  const biblia = estat.bibliaNarrativa;
  if (biblia) {
    const bibliaLines = [];
    if (biblia.fets_canonics && biblia.fets_canonics.length > 0) {
      bibliaLines.push('FETS CANÃ’NICS ESTABLERTS (NO CONTRADIR):');
      biblia.fets_canonics.slice(-8).forEach(f => bibliaLines.push('- ' + f));
    }

    const capEst = ESTAT._estructuraCapitols[idx];
    const personatgesCap = (capEst && capEst.personatges) ? capEst.personatges : [];
    const fitxesRellevants = (biblia.fitxes_personatges || []).filter(f =>
      personatgesCap.some(nom =>
        nom.toLowerCase().includes((f.nom || '').toLowerCase()) ||
        (f.nom || '').toLowerCase().includes(nom.toLowerCase())
      )
    );
    if (fitxesRellevants.length > 0) {
      bibliaLines.push('ESTAT ACTUAL DELS PERSONATGES PRESENTS:');
      fitxesRellevants.forEach(f => {
        bibliaLines.push(`- ${f.nom}: ${f.estat_actual || '(no definit)'}`);
        if (f.motivacions) bibliaLines.push(`  MotivaciÃ³: ${f.motivacions}`);
      });
    }

    if (biblia.regles_mon && biblia.regles_mon.length > 0) {
      bibliaLines.push('REGLES DEL MÃ“N (respecta-les sempre):');
      biblia.regles_mon.forEach(r => bibliaLines.push('- ' + r));
    }

    if (bibliaLines.length > 0) {
      parts.push('\nBÃBLIA NARRATIVA:\n' + bibliaLines.join('\n'));
    }
  }

  const trames = estat.trames;
  if (trames && (trames.trama_principal || trames.subtrames.length > 0)) {
    const tramesLines = ['TRAMES ACTIVES EN AQUEST CAPÃTOL:'];
    if (trames.trama_principal) {
      const tp = trames.trama_principal;
      tramesLines.push('Trama principal: ' + (typeof tp === 'string' ? tp : (tp.descripcio || JSON.stringify(tp))));
    }
    const mapaEntry = (trames.mapa_entrellacat || []).find(m => m.capitol === idx + 1);
    if (mapaEntry && mapaEntry.trames_actives) {
      const subActive = trames.subtrames.filter(st =>
        mapaEntry.trames_actives.some(t =>
          t === st.nom || t.toLowerCase().includes((st.nom || '').toLowerCase())
        )
      );
      subActive.forEach(st => tramesLines.push(`Subtrama "${st.nom}": ${st.descripcio || ''}`));
    }
    parts.push('\n' + tramesLines.join('\n'));
  }

  // 2) Context de capÃ­tols i continuÃ¯tat (memÃ²ria global textual)
  const capsContext = buildContextCapitolsComplets(idx, {}, estat);
  if (capsContext) parts.push(capsContext);

  if (idx > 0 && estat._capitols_generats[idx - 1]) {
    const parasAnterior = estat._capitols_generats[idx - 1].split(/\n\n+/);
    const ultims = parasAnterior.slice(-2).join('\n\n');
    if (ultims.trim()) {
      parts.push('\nFINAL DEL CAPÃTOL ANTERIOR (mantÃ©n la continuÃ¯tat de to i escena):\n' + ultims);
    }
  }

  // 3) Registre antic opcional (desacoblat quan NKG Ã©s actiu)
  if (!skipRegistre) {
    const registreCtx = buildRegistreContext(idx);
    if (registreCtx && registreCtx.trim()) parts.push(registreCtx);
  }

  // 4) Ajustos globals de rumb
  if (estat._ajustosRumb) {
    const ajustos = typeof estat._ajustosRumb === 'string' ? estat._ajustosRumb : JSON.stringify(estat._ajustosRumb);
    if (ajustos && ajustos.trim()) {
      parts.push(`\nAJUSTOS DE RUMB (indicaciÃ³ del checkpoint de coherÃ¨ncia): ${ajustos}`);
    }
  }

  // 5) Claus de l'Arquitecte per a aquest capÃ­tol (Fix 2)
  if (Array.isArray(estat._clausPromptSeguent) && estat._clausPromptSeguent.length > 0) {
    parts.push('\nCLAUS DE CONTINUÃTAT (extretes per l\'Arquitecte del capÃ­tol anterior):\n' +
      estat._clausPromptSeguent.slice(0, 5).map(c => `- ${c}`).join('\n'));
  }

  // 6) Alerta i millores de l'Arquitecte (Fix 3)
  if (estat._alertaArquitecte) {
    const a = estat._alertaArquitecte;
    const lines = [];
    if (a.alerta) lines.push(`âš ï¸ ALERTA CRÃTICA (cap ${a.capitol}): ${a.alerta}`);
    if (a.millores && a.millores.length > 0) {
      lines.push('MILLORES PRIORITÃ€RIES DE L\'ARQUITECTE (aplica-les en aquest capÃ­tol):');
      a.millores.forEach(m => lines.push(`- [${m.capitol_afectat || 'general'}] ${m.proposta || m.problema || ''}`));
    }
    if (lines.length > 0) parts.push('\n' + lines.join('\n'));
  }

  return parts.join('\n');
}

function buildContextCapitol(idx) {
  // FUTURE MASKING
  const estatContext = filtrarContextFutur(idx);
  const capitolsRegistre = (ESTAT.llibreRegistre && Array.isArray(ESTAT.llibreRegistre.capitols))
    ? ESTAT.llibreRegistre.capitols
    : [];
  const r1 = idx - 1 >= 0 ? capitolsRegistre[idx - 1] : null;
  const r2 = idx - 2 >= 0 ? capitolsRegistre[idx - 2] : null;
  const prohibirIniciMeteorologic = !!(r1 && r2 && r1.inici_meteorologic === true && r2.inici_meteorologic === true);

  const cap = estatContext._estructuraCapitols ? estatContext._estructuraCapitols[idx] : null;

  // Context global (Brief, BÃ­blia, Trames, etc.) sempre present
  const ctxGlobalBase = ESTAT._nkg
    ? buildContextCapitolLegacy(idx, true, estatContext)
    : buildContextCapitolLegacy(idx, false, estatContext);

  // Bloc de planificaciÃ³/escaleta (quÃ¨ passa en aquest capÃ­tol)
  const blocEscaleta = [];
  if (cap) {
    const capLines = [];
    if (cap.titol) capLines.push(`TÃ­tol: ${cap.titol}`);
    if (cap.fil || cap.fil_principal) capLines.push(`Fil principal: ${cap.fil || cap.fil_principal}`);
    if (cap.resum) capLines.push(`Resum: ${cap.resum}`);
    if (cap.personatges && cap.personatges.length > 0) capLines.push(`Personatges: ${cap.personatges.join(', ')}`);
    if (cap.localitzacio) capLines.push(`LocalitzaciÃ³: ${cap.localitzacio}`);
    if (cap.connexioAnterior) capLines.push(`ConnexiÃ³ anterior: ${cap.connexioAnterior}`);
    if (cap.connexioSeguent) capLines.push(`ConnexiÃ³ segÃ¼ent: ${cap.connexioSeguent}`);
    if (capLines.length > 0) blocEscaleta.push('PLANIFICACIÃ“ DEL CAPÃTOL ACTUAL:\n' + capLines.join('\n'));
  }

  const escaletaCap = (estatContext._escaletes || []).find(e => e.capitol === idx + 1);
  if (escaletaCap && Array.isArray(escaletaCap.escenes) && escaletaCap.escenes.length > 0) {
    const escenes = escaletaCap.escenes.slice(0, 8).map((sc, i) => {
      const p = [];
      if (sc.nom) p.push(`Nom: ${sc.nom}`);
      if (sc.funcio_narrativa) p.push(`FunciÃ³: ${sc.funcio_narrativa}`);
      if (sc.personatges && sc.personatges.length > 0) p.push(`Personatges: ${sc.personatges.join(', ')}`);
      if (sc.beat_narratiu) p.push(`Beat: ${sc.beat_narratiu}`);
      if (sc.paraules_objectiu) p.push(`Paraules: ${sc.paraules_objectiu}`);
      return `- Escena ${i + 1}: ${p.join(' | ')}`;
    }).join('\n');
    blocEscaleta.push('ESCALETA/ESCENES DEL CAPÃTOL:\n' + escenes);
  }

  // Prefiguracions + to/tensiÃ³
  const blocFinal = [];
  const { aPlantarAra, aRecollirAra, plantadesNoResoltes } = getPrefiguracionsActives(idx, estatContext);
  if (aPlantarAra.length > 0) {
    blocFinal.push('PREFIGURACIONS A PLANTAR EN AQUEST CAPÃTOL (integra-les subtilment):');
    aPlantarAra.forEach(p => blocFinal.push(`- ${p.element}`));
  }
  if (aRecollirAra.length > 0) {
    blocFinal.push('PREFIGURACIONS A RECOLLIR (elements plantats abans que ara es resolen):');
    aRecollirAra.forEach(p => blocFinal.push(`- ${p.element}`));
  }
  if (plantadesNoResoltes.length > 0) {
    blocFinal.push('PREFIGURACIONS ACTIVES (encara no resoltes):');
    plantadesNoResoltes.forEach(p => blocFinal.push(`- ${p.element} (resoluciÃ³ prevista cap. ${p.resolucio_capitol})`));
  }

  if (cap && cap.toRitme) blocFinal.push(`TO I RITME D'AQUEST CAPÃTOL: ${cap.toRitme}`);
  const tensio = (estatContext._corbaTensio || []).find(t => t.capitol === idx + 1);
  if (tensio) {
    const instrRitme = getInstruccionsRitme(tensio.nivell, tensio.tipus);
    blocFinal.push(`NIVELL DE TENSIÃ“ OBJECTIU: ${tensio.nivell}/10 (${tensio.tipus || ''})`);
    blocFinal.push(`INSTRUCCIONS DE PROSA: ${instrRitme}`);
  }

  // Quan NKG Ã©s actiu, combina (no substitueix) ctxGlobal + ctxNkg
  if (ESTAT._nkg) {
    const escenaSpec = {
      capitol: idx + 1,
      escena: 1,
      personatges: cap ? (cap.personatges || []) : [],
      lloc: cap ? (cap.localitzacio || '') : '',
      escaleta: null
    };
    const ctxNkg = nkgGenerarContextMinim(escenaSpec);

    const seccionsNkg = [
      ctxGlobalBase,
      blocEscaleta.length > 0 ? blocEscaleta.join('\n\n') : '',
      ctxNkg,
      blocFinal.length > 0 ? blocFinal.join('\n') : ''
    ].filter(Boolean);

    let contextFinalNkg = seccionsNkg.join('\n\n');
    if (prohibirIniciMeteorologic) {
      contextFinalNkg += "\n\nPROHIBIT comenÃ§ar descrivint el temps atmosfÃ¨ric. ComenÃ§a 'in media res' o amb un diÃ leg.";
    }
    contextFinalNkg += construirSeccioProhibicions(idx);
    return contextFinalNkg;
  }

  const seccions = [
    ctxGlobalBase,
    blocEscaleta.length > 0 ? blocEscaleta.join('\n\n') : '',
    blocFinal.length > 0 ? blocFinal.join('\n') : ''
  ].filter(Boolean);

  let contextFinal = seccions.join('\n\n');
  if (prohibirIniciMeteorologic) {
    contextFinal += "\n\nPROHIBIT comenÃ§ar descrivint el temps atmosfÃ¨ric. ComenÃ§a 'in media res' o amb un diÃ leg.";
  }
  contextFinal += construirSeccioProhibicions(idx);
  return contextFinal;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10: Estructura de la novelÂ·la (Opus) â€” JSON
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEstructuraNovella(userConfig) {
  const personatgesCtx = ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0
    ? ESTAT._personatgesSeleccionats.join('\n')
    : '(No definit)';

  const brief = buildBriefNarratiu();

  // Context de trames (si s'han generat prÃ¨viament a la fase de trames)
  let tramesCtx = '';
  if (ESTAT.trames && ESTAT.trames.trama_principal) {
    const tp = ESTAT.trames.trama_principal;
    tramesCtx = `\nDISSENY DE TRAMES PREVI (integra'l a l'estructura capÃ­tol a capÃ­tol):
TRAMA PRINCIPAL: ${typeof tp === 'string' ? tp : (tp.descripcio || JSON.stringify(tp))}`;
    if (tp.conflicte_central) tramesCtx += `\nConflicte central: ${tp.conflicte_central}`;
    if (tp.arc_protagonista)  tramesCtx += `\nArc protagonista: ${tp.arc_protagonista}`;
    if (ESTAT.trames.subtrames.length > 0) {
      tramesCtx += '\nSUBTRAMES:';
      ESTAT.trames.subtrames.forEach(st => {
        tramesCtx += `\n- ${st.nom} (caps. ${st.capitol_inici || '?'}-${st.capitol_resolucio || '?'}): ${st.descripcio || ''}`;
      });
    }
  }

  const msgs = [{
    role: 'user',
    content: `A partir del conte original, la bÃ­blia de mÃ³n i l'elenc, crea l'estructura completa de la novelÂ·la.

${brief}

CONTE ORIGINAL (resum):
${ESTAT.conteText ? ESTAT.conteText.substring(0, 2000) + (ESTAT.conteText.length > 2000 ? '\n[â€¦conte truncat per espaiâ€¦]' : '') : '(No disponible)'}

BÃBLIA DE MÃ“N:
${ESTAT.worldbuilding ? ESTAT.worldbuilding.substring(0, 1500) + (ESTAT.worldbuilding.length > 1500 ? '\n[â€¦]' : '') : '(No definida)'}

ELENC DE PERSONATGES SELECCIONATS:
${personatgesCtx}

ESTILS DE PARLA (resum):
${ESTAT.estilsParla ? ESTAT.estilsParla.substring(0, 1000) + (ESTAT.estilsParla.length > 1000 ? '\n[â€¦]' : '') : '(No definits)'}${tramesCtx}

NOMBRE DE CAPÃTOLS: Entre 12 i 22 capÃ­tols. La decisiÃ³ depÃ¨n de la complexitat i profunditat de la trama:
- 12-14 capÃ­tols: Trama principal + 0-2 subtrames. Arc narratiu concentrat. NovelÂ·la de ritme Ã gil (50.000-65.000 paraules objectiu).
- 15-18 capÃ­tols: Trama principal + 2-3 subtrames significatives, o elencs de 4+ personatges amb arcs propis.
  Espai per a subplots emocionals, desviaments i caps de pont entre actes. (65.000-80.000 paraules objectiu).
- 19-22 capÃ­tols: Trama principal + 3-4 subtrames complexes, mÃºltiples girs, revelacions escalonades,
  o una estructura coral amb 4+ protagonistes que requereix capÃ­tols de perspectiva alternada. (80.000-100.000 paraules objectiu).

REGLA D'OR: Cada capÃ­tol ha de justificar la seva existÃ¨ncia â€” si un capÃ­tol es pot fusionar
amb l'anterior o el posterior sense perdre res essencial, fusiona'l.
Prioritza l'amplitud dramÃ tica: Ã©s millor una novelÂ·la ben desplegada que un relat comprimit.
NO superis MAI 22 capÃ­tols. La densitat narrativa Ã©s tan important com l'extensiÃ³.

INSTRUCCIONS DE CORBA DE TENSIÃ“:
La "corba_tensio" ha de seguir una estructura dramÃ tica adaptada al nombre de capÃ­tols.
La corba NO Ã©s lineal ascendent â€” ha d'OSCILÂ·LAR: desprÃ©s de cada pic hi ha un moment de respir.
Alterna capÃ­tols d'acciÃ³ (frases curtes, diÃ leg rÃ pid) amb capÃ­tols de respiraciÃ³ (introspectiu, descriptiu).

PER A 12-14 CAPÃTOLS (estructura 3-5/7-4):
  - Acte I (caps 1-3): exposiciÃ³ â†’ incident detonant
    Â· Cap 1: nivell 3 (establir mÃ³n i protagonista)
    Â· Cap 2: nivell 4 (complicaciÃ³, presentar conflicte)
    Â· Cap 3: nivell 6 (primer punt de gir â€” no hi ha marxa enrere)
  - Acte II (caps 4-9/10): desenvolupament â†’ crisi
    Â· Caps 4-5: nivell 5-6 (explorar conflicte, subtrames)
    Â· Cap mig: nivell 7 (punt mig â€” revelaciÃ³ o gir)
    Â· Caps segÃ¼ents: nivell 7-8 (complicaciÃ³ greu)
    Â· PenÃºltim de l'Acte II: nivell 9 (tot sembla perdut)
  - Acte III (caps finals 4): clÃ­max â†’ resoluciÃ³
    Â· PenÃºltim: nivell 8 (reorganitzaciÃ³, pla desesperat)
    Â· ClÃ­max: nivell 10
    Â· ResoluciÃ³: nivell 7
    Â· Tancament: nivell 4-5 (epÃ­leg narratiu)

PER A 15-18 CAPÃTOLS (estructura 4-9/10-4/5):
  - Acte I (caps 1-4): exposiciÃ³ ampliada, presentaciÃ³ de subtrames
    Â· Cap 1: nivell 3 | Cap 2: nivell 4 | Cap 3: nivell 5 | Cap 4: nivell 6 (primer gir)
  - Acte II (caps 5-13/14): desenvolupament ric amb oscilÂ·laciÃ³
    Â· Caps 5-6: nivell 5-6 (respiraciÃ³, explorar subtrames)
    Â· Cap mig-1: nivell 7 (revelaciÃ³ parcial)
    Â· Caps segÃ¼ents: nivell 6-7 (conseqÃ¼Ã¨ncies, subtrames)
    Â· Cap mig+2: nivell 8 (complicaciÃ³ greu, possible gir de subtrama)
    Â· Cap penÃºltim Acte II: nivell 5 (calma abans de la tempesta)
    Â· Cap Ãºltim Acte II: nivell 9 (crisi mÃ xima)
  - Acte III (caps 14/15-18): resoluciÃ³ i tancament
    Â· Cap 1 Acte III: nivell 8 | ClÃ­max: nivell 10 | ResoluciÃ³: nivell 7 | Tancament: nivell 4-5

PER A 19-22 CAPÃTOLS (estructura 5-12/14-4/5):
  - Acte I (caps 1-5): exposiciÃ³ coral, introducciÃ³ de mÃºltiples fils
    Â· Caps 1-2: nivell 3-4 | Cap 3: nivell 5 | Cap 4: nivell 5-6 | Cap 5: nivell 7 (primer gir major)
  - Acte II (caps 6-17/18): desplegament complex, mÃºltiples subtrames
    Â· OscilÂ·la entre nivells 4 i 9, amb respiraciÃ³ cada 2-3 capÃ­tols
    Â· Inclou: un punt mig (nivell 7-8), un fals clÃ­max (nivell 9), una calma estratÃ¨gica (nivell 4-5)
    Â· Subtrames han de tenir el seu propi clÃ­max intern (nivell 8) abans de convergir amb la principal
  - Acte III (caps finals 4-5): convergÃ¨ncia i resoluciÃ³
    Â· PenÃºltim Acte II: nivell 9 | ClÃ­max: nivell 10 | ResoluciÃ³: nivell 7 | EpÃ­leg: nivell 4

INSTRUCCIÃ“ D'ARC DE PERSONATGE: Qualsevol caiguda moral, traÃ¯ciÃ³ als propis principis o canvi radical de paradigma del protagonista NO pot passar en un sol capÃ­tol. Ha d'haver-hi almenys un capÃ­tol sencer de "Dubte i RacionalitzaciÃ³" on el personatge intenti auto-enganyar-se abans d'acceptar la seva nova naturalesa corrupta o el seu canvi d'alineaciÃ³. Planifica explÃ­citament aquest capÃ­tol de transiciÃ³ a l'estructura. Fes que les derrotes morals se sentin orgÃ niques i justificades, no precipitades.

ARC MORAL DEL PROTAGONISTA (OBLIGATORI):
A mÃ©s de la corba de tensiÃ³, defineix una "corba moral" independent amb exactament 5 punts:
1. ESTAT INICIAL: Valors i creences del protagonista al comenÃ§ar
2. PRIMERA FISSURA (cap. 3-5): Un moment on els seus principis fallen per primera vegada
3. BACKSLIDING (cap. 6-9): Un intent genuÃ­ de tornar als seus valors originals que FRACASSA â€” no per debilitat, sinÃ³ perquÃ¨ el mÃ³n ja no li ho permet
4. PUNT DE NO RETORN (cap. 9-12): La decisiÃ³ irreversible que el transforma
5. COST FINAL (Ãºltims 2-3 caps): El preu emocional/moral concret de la transformaciÃ³
Inclou-ho com a camp "arc_moral" al JSON de retorn.

IMPORTANT: L'array "capitols" ha de contenir EXACTAMENT el nombre de capÃ­tols indicat a "nombre_capitols". Prioritza completar tots els capÃ­tols encara que les descripcions dels Ãºltims siguin mÃ©s breus. Un JSON truncat Ã©s INACCEPTABLE.
CRÃTIC: L'array "corba_tensio" HA DE CONTENIR EXACTAMENT una entrada per a CADA capÃ­tol de la novelÂ·la. Si tries 18 capÃ­tols, hi ha d'haver 18 entrades a la corba de tensiÃ³. NO T'ATURIS A LA MEITAT.

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "titol_novella": "Escriu aquÃ­ un tÃ­tol atractiu, evocador i comercial per a l'obra",
  "nombre_capitols": 12,
  "justificacio_capitols": "Explica en 2-3 lÃ­nies per quÃ¨ has triat N capÃ­tols i no N-1 o N+1",
  "arc_global": "descripciÃ³ de l'arc narratiu complet en 5-8 lÃ­nies",
  "temes_centrals": ["tema1", "tema2", "tema3"],
  "prefiguracions": [
    {"plantada_capitol": 2, "resolucio_capitol": 8, "element": "descripciÃ³ de l'element plantat"},
    {"plantada_capitol": 3, "resolucio_capitol": 11, "element": "descripciÃ³ de l'element plantat"}
  ],
  "corba_tensio": [
    {"capitol": 1, "nivell": 3, "tipus": "exposiciÃ³"},
    {"capitol": 2, "nivell": 5, "tipus": "complicaciÃ³"},
    {"capitol": 3, "nivell": 6, "tipus": "gir"},
    {"capitol": "...", "nivell": 0, "tipus": "continua aixÃ­ fins a arribar al darrer capÃ­tol, sense saltar-ne cap"}
  ],
  "arc_moral": {
    "estat_inicial": "descripciÃ³ dels valors inicials del protagonista",
    "primera_fissura": {"capitol": 4, "descripcio": "moment on els principis fallen per primera vegada"},
    "backsliding": {"capitol": 7, "descripcio": "intent genuÃ­ de tornar als valors originals que fracassa"},
    "punt_no_retorn": {"capitol": 10, "descripcio": "decisiÃ³ irreversible que el transforma"},
    "cost_final": {"capitol": 13, "descripcio": "preu emocional/moral concret de la transformaciÃ³"}
  },
  "capitols": [
    {
      "numero": 1,
      "titol": "tÃ­tol evocador",
      "resum": "resum de 3-5 lÃ­nies",
      "personatges": ["nom1", "nom2"],
      "fil_principal": "fil narratiu que avanÃ§a",
      "to_ritme": "lent i introspectiu / trepidant / etc.",
      "prefiguracions_a_plantar": ["element que es plantarÃ  aquÃ­"],
      "prefiguracions_a_recollir": ["element plantat abans que es resol aquÃ­"],
      "connexio_anterior": "com lliga amb l'anterior",
      "connexio_seguent": "com prepara el segÃ¼ent"
    }
  ]
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un arquitecte narratiu expert en estructures de novelÂ·la. Retornes EXCLUSIVAMENT un objecte JSON vÃ lid, sense cap text addicional ni markdown. Escrius els valors de text en catalÃ .',
    Object.assign({}, userConfig, { maxTokens: 16384, model: getModelConfig(userConfig).modelArquitecte }),
    'arquitectura'
  );

  // Validem abans de retornar que l'estructura com a mÃ­nim tingui l'array de capÃ­tols
  const validacio = parseJsonRobust(response, ['capitols']);
  if (!validacio) {
    throw new Error("L'API no ha retornat una estructura vÃ lida amb la clau 'capitols'. Cal reintentar.");
  }

  // Guardem el tÃ­tol generat a l'estat global perquÃ¨ estigui disponible a l'exportaciÃ³
  ESTAT.titol_novella = validacio.titol_novella || "NovelÂ·la Sense TÃ­tol";

  return { response };
}

async function completarEstructuraCapitols(capitolsExistents, capsEsperats, userConfig) {
  const ultimCapitol = capitolsExistents[capitolsExistents.length - 1];
  const primerACompletar = ultimCapitol ? ultimCapitol.numero + 1 : capitolsExistents.length + 1;
  const capsQueFalten = capsEsperats - capitolsExistents.length;

  const resumExistents = capitolsExistents.map(c =>
    `Cap. ${c.numero}: "${c.titol}" â€” ${(c.resum || '').substring(0, 80)}`
  ).join('\n');

  const msgs = [{
    role: 'user',
    content: `L'estructura de la novelÂ·la estÃ  incompleta. Tens els primers ${capitolsExistents.length} capÃ­tols i falten els capÃ­tols ${primerACompletar} a ${capsEsperats}.

CAPÃTOLS JA DEFINITS:
${resumExistents}

ARC GLOBAL: ${ESTAT._arcGlobal || '(no disponible)'}
FINAL PLANIFICAT: ${ESTAT.finalTriat || '(no definit)'}

CORBA DE TENSIÃ“ per als capÃ­tols que falten:
${(ESTAT._corbaTensio || []).filter(t => t.capitol >= primerACompletar).map(t => `Cap.${t.capitol}: nivell ${t.nivell} (${t.tipus})`).join(', ') || '(no disponible)'}

Genera EXACTAMENT ${capsQueFalten} capÃ­tols (del ${primerACompletar} al ${capsEsperats}).

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "capitols": [
    {
      "numero": ${primerACompletar},
      "titol": "tÃ­tol evocador",
      "resum": "resum de 2-3 lÃ­nies",
      "personatges": ["nom1", "nom2"],
      "fil_principal": "fil narratiu",
      "to_ritme": "to i ritme",
      "prefiguracions_a_plantar": [],
      "prefiguracions_a_recollir": [],
      "connexio_anterior": "com lliga amb l'anterior",
      "connexio_seguent": "com prepara el segÃ¼ent"
    }
  ]
}

CRÃTIC: Han de ser EXACTAMENT ${capsQueFalten} capÃ­tols. L'Ãºltim (${capsEsperats}) ha de conduir al final planificat.`
  }];

  const response = await callLLMMulti(msgs,
    'Ets un arquitecte narratiu. Retorna EXCLUSIVAMENT JSON vÃ lid amb els capÃ­tols que falten.',
    Object.assign({}, userConfig, { maxTokens: 6000 }), 'arquitectura');
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 11: Escriure capÃ­tol (Sonnet) â€” FASE 3: Context complet
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function generarInstruccionsGanxoFinalCapitol(idx) {
  const esUltimCapitol = idx >= ((ESTAT._estructuraCapitols && ESTAT._estructuraCapitols.length) ? ESTAT._estructuraCapitols.length - 1 : 0);
  const autorRef = String((ESTAT.configProjecte && ESTAT.configProjecte.autor_referencia) || '').toLowerCase();
  const modeTolkien = /tolkien/.test(autorRef);
  const modeCastaneda = /castaneda/.test(autorRef);
  const oberts = (ESTAT.llibreRegistre && Array.isArray(ESTAT.llibreRegistre.fils_oberts))
    ? ESTAT.llibreRegistre.fils_oberts.filter(Boolean)
    : [];
  const capitolsRegistre = (ESTAT.llibreRegistre && Array.isArray(ESTAT.llibreRegistre.capitols))
    ? ESTAT.llibreRegistre.capitols
    : [];
  const c1 = idx - 1 >= 0 ? capitolsRegistre[idx - 1] : null;
  const c2 = idx - 2 >= 0 ? capitolsRegistre[idx - 2] : null;
  const dosCliffhangersConsecutius = !!(c1 && c2 && c1.es_cliffhanger === true && c2.es_cliffhanger === true);

  if (dosCliffhangersConsecutius && !modeTolkien && !modeCastaneda) {
    return "PROHIBIT acabar amb cliffhanger. Ja n'hi ha hagut dos consecutius. Aquest capÃ­tol HA d'acabar amb una resoluciÃ³ parcial o una reflexiÃ³ interna.";
  }

  if (esUltimCapitol) {
    return `Com que Ã©s l'Ãºltim capÃ­tol, tanca els fils prioritaris i deixa una reverberaciÃ³ emocional final potent: una Ãºltima imatge, una realitzaciÃ³ del personatge o una resoluciÃ³ que ressoni. Sense cliffhanger fort, perÃ² que la darrera frase es quedi gravada.`;
  }

  if (modeTolkien) {
    return "TANCAMENT DE CAPÃTOL (MODE TOLKIEN): Evita cliffhangers mecÃ nics. Acaba amb ressonÃ ncia Ã¨pica o lÃ­rica: conseqÃ¼Ã¨ncia moral, memÃ²ria del paisatge, jurament, pÃ¨rdua o esperanÃ§a continguda. L'objectiu no Ã©s el xoc immediat, sinÃ³ la profunditat de mÃ³n i destÃ­.";
  }

  if (modeCastaneda) {
    return "TANCAMENT DE CAPÃTOL (MODE CASTANEDA): Evita cliffhangers d'acciÃ³ convencionals. Acaba amb desplaÃ§ament perceptiu, paradoxa o pregunta iniciÃ tica que desestabilitzi el marc del personatge. L'objectiu Ã©s una fractura de percepciÃ³, no un tall efectista.";
  }

  const tecniques = `Tria la tÃ¨cnica que encaixi millor amb el moment narratiu â€” NO forÃ§is una pregunta retÃ²rica si no Ã©s la mÃ©s efectiva:
  Â· RevelaciÃ³: una informaciÃ³ nova que ho canvia tot o qÃ¼estiona el que el lector creia saber
  Â· AmenaÃ§a imminent: el perill arriba i el capÃ­tol talla just abans de la colÂ·lisiÃ³
  Â· Ruptura: traÃ¯ciÃ³, pÃ¨rdua o descobriment que trenca l'equilibri emocional establert
  Â· DecisiÃ³ congelada: el personatge davant d'una elecciÃ³ impossible, el lector no sap quÃ¨ farÃ 
  Â· InversiÃ³: el poder, la veritat o la situaciÃ³ s'inverteixen de cop
  Â· Imatge final: una Ãºltima escena o detall que ressona emocionalment i obre una promesa no dita
  Â· Escalada d'apostes: un element nou (personatge, objecte, informaciÃ³) que puja el risc de tot el que ve
  L'objectiu Ã©s que el lector NECESSITI girar la pÃ gina, no que es faci una pregunta.`;

  if (oberts.length > 0) {
    const mostra = oberts.slice(0, 3).join(' Â· ');
    return `Al tram final crea un moment que faci la lectura addictiva, connectant l'escena final amb algun fil obert del registre (${mostra}) per intensificar-lo o encaminar-ne la resoluciÃ³ futura. ${tecniques}`;
  }

  return `Al tram final crea un moment que faci la lectura addictiva. ${tecniques}`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Actualitzar Llibre de Registre (Sonnet â€” background)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function actualitzarRegistre(textCapitol, idx, userConfig) {
  const reg = ESTAT.llibreRegistre;
  const registreAnterior = reg.capitols && reg.capitols[idx - 1]
    ? JSON.stringify(reg.capitols[idx - 1], null, 2)
    : JSON.stringify({ estat_personatges: [], fils_oberts: [], fils_tancats: [] });

  const msgs = [{
    role: 'user',
    content: `Ets un Script Supervisor. A partir del Llibre de Registre actual i el nou capÃ­tol, actualitza l'estat.

LLIBRE DE REGISTRE ACTUAL:
${registreAnterior}

CAPÃTOL ${idx + 1} ACABAT DE GENERAR:
${textCapitol.substring(0, 4000)}${textCapitol.length > 4000 ? '\n[â€¦text truncatâ€¦]' : ''}

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense cap text addicional, sense markdown):
{
  "resum_capitol": "resum de 2-3 frases del capÃ­tol",
  "estat_personatges": [{"nom": "nom", "ubicacio": "on Ã©s ara", "estat_actual": "situaciÃ³ emocional/fÃ­sica actual"}],
  "fils_oberts": ["fil narratiu que queda obert o s'ha introduÃ¯t"],
  "fils_tancats": ["fil narratiu que s'ha resolt en aquest capÃ­tol"],
  "fils_nous_detectats": ["fils que s'han obert explÃ­citament en aquest capÃ­tol"],
  "fils_resolts_detectats": ["fils preexistents que aquÃ­ es resolen"],
  "prefiguracions_detectades": ["element que apareix en aquest capÃ­tol i podria ser una prefiguraciÃ³ o referÃ¨ncia a una"],
  "inici_meteorologic": true,
  "es_cliffhanger": false
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un supervisor narratiu. Retornes EXCLUSIVAMENT un objecte JSON vÃ lid, sense cap altre text.',
    Object.assign({}, userConfig, { maxTokens: 1500, model: getModelConfig(userConfig).modelDraft, _esDraft: true }),
    'generacio'
  );
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RevisiÃ³ inter-capÃ­tol (Opus) â€” FASE 5: verifica prefiguracions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function revisarCapitol(textCapitol, idx, userConfig) {
  const cap       = ESTAT._estructuraCapitols[idx];
  const registreCtx = buildRegistreContext(idx);
  const { aPlantarAra, aRecollirAra } = getPrefiguracionsActives(idx);

  let prefCtx = '';
  if (aPlantarAra.length > 0) {
    prefCtx += '\nPREFIGURACIONS QUE CALIA PLANTAR EN AQUEST CAPÃTOL:\n' +
      aPlantarAra.map(p => `- ${p.element}`).join('\n');
  }
  if (aRecollirAra.length > 0) {
    prefCtx += '\nPREFIGURACIONS QUE CALIA RECOLLIR EN AQUEST CAPÃTOL:\n' +
      aRecollirAra.map(p => `- ${p.element}`).join('\n');
  }

  const planificacioCompleta = (() => {
    if (!cap) return `CapÃ­tol ${idx + 1}`;
    const lines = [];
    if (cap.titol)       lines.push(`TÃ­tol: ${cap.titol}`);
    if (cap.fil)         lines.push(`Fil principal: ${cap.fil}`);
    if (cap.toRitme)     lines.push(`To i ritme: ${cap.toRitme}`);
    if (cap.personatges && cap.personatges.length > 0)
      lines.push(`Personatges: ${cap.personatges.join(', ')}`);
    if (cap.resum)       lines.push(`\nResum/PlanificaciÃ³:\n${cap.resum}`);
    if (cap.connexioAnterior) lines.push(`\nConnexiÃ³ amb l'anterior: ${cap.connexioAnterior}`);
    if (cap.connexioSeguent)  lines.push(`ConnexiÃ³ amb el segÃ¼ent: ${cap.connexioSeguent}`);
    if (cap.prefiguracionsPlantar && cap.prefiguracionsPlantar.length > 0)
      lines.push(`\nPrefiguracions a plantar: ${cap.prefiguracionsPlantar.join(' | ')}`);
    if (cap.prefiguracionsRecollir && cap.prefiguracionsRecollir.length > 0)
      lines.push(`Prefiguracions a recollir: ${cap.prefiguracionsRecollir.join(' | ')}`);
    if (cap.text) lines.push(`\nPlanificaciÃ³ original (JSON complet):\n${cap.text}`);
    return lines.join('\n');
  })();

  const nkgEstat = (() => {
    const nkg = ESTAT._nkg;
    if (!nkg) return '';
    const parts = [];

    const pers = Object.values(nkg.personatges);
    if (pers.length > 0) {
      parts.push('PERSONATGES (estat NKG actualitzat fins a l\'escena anterior):\n' +
        pers.map(p => {
          const inv = Array.isArray(p.objectes_inventari) && p.objectes_inventari.length > 0
            ? p.objectes_inventari.join(', ') : '(sense objectes)';
          let line = `â€¢ ${p.nom}: emociÃ³="${p.estat_emocional || 'neutre'}"`;
          if (p.estat_fisic)         line += ` | fÃ­sic="${p.estat_fisic}"`;
          if (p.indumentaria_actual) line += ` | roba="${p.indumentaria_actual}"`;
          line += ` | inventari=[${inv}]`;
          if (p.ubicacio)            line += ` | ubicaciÃ³="${p.ubicacio}"`;
          if (p.viu === false)       line += ' | MORT';
          return line;
        }).join('\n'));
    }

    if (Array.isArray(nkg.timeline_accions) && nkg.timeline_accions.length > 0) {
      parts.push('ÃšLTIMES ACCIONS CONSUMADES (detecta regressiÃ³ si el capÃ­tol les torna a narrar):\n' +
        nkg.timeline_accions.slice(-10).map(a => `â€¢ ${a}`).join('\n'));
    }

    if (Array.isArray(nkg.fets_canonics) && nkg.fets_canonics.length > 0) {
      parts.push('FETS CANÃ’NICS ESTABLERTS (no han de contradir-se):\n' +
        nkg.fets_canonics.slice(-10).map(f => `â€¢ Cap.${f.capitol_origen}: ${f.descripcio}`).join('\n'));
    }

    return parts.join('\n\n');
  })();

  const capitolsAnteriors = (ESTAT._capitols_generats || [])
    .slice(0, idx)
    .map((text, i) => text ? `â•â•â• CAPÃTOL ${i + 1} â•â•â•\n${text}` : null)
    .filter(Boolean)
    .join('\n\n');

  const msgs = [{
    role: 'user',
    content: `Revisa aquest capÃ­tol i comprova la coherÃ¨ncia amb tots els capÃ­tols anteriors i amb la planificaciÃ³ narrativa.
${capitolsAnteriors ? `
CAPÃTOLS ANTERIORS (text complet â€” usa'ls per detectar incongruÃ¨ncies, repeticions, contradiccions de fets, objectes, roba o emocions):
${capitolsAnteriors}

` : ''}
PLANIFICACIÃ“ COMPLETA D'AQUEST CAPÃTOL:
${planificacioCompleta}
${registreCtx}
${prefCtx}
${nkgEstat ? `
ESTAT DEL NKG:
${nkgEstat}` : ''}

CAPÃTOL ${idx + 1} GENERAT:
${textCapitol}

La teva tasca Ã©s avaluar si el text Ã©s publicable i si compleix amb els objectius de l'escaleta.
Fixa't especialment en:
1. CoherÃ¨ncia amb l'escaleta i personatges.
2. Format (errors de diÃ legs al mateix parÃ graf = rebuig automÃ tic).
3. Qualitat (ritme, telling vs showing, info-dumping).
4. Escenes equivalents: Avisa si hi ha alguna escena que serveixi per al mateix propÃ²sit narratiu que una del capÃ­tol anterior i demana'n la transformaciÃ³.
5. ContinuÃ¯tat fÃ­sica: Verifica que cap objecte canviÃ¯ de lloc o desaparegui mÃ gicament de les mans d'un personatge.
6. MetÃ fores repetides: Assegura't que no s'utilitza una imatge poÃ¨tica o metÃ fora ja gastada.

CRÃTIC PER ESTALVIAR TOKENS: Si aproves el capÃ­tol, les valoracions han de ser buides o d'1 sola paraula. Si el rebutges, les "instruccions_correccio" han de ser EXTREMADAMENT BREUS, en estil telegrÃ fic (3 o 4 bullet points directes al gra). Prohibit justificar-te o enrotllar-te.

SELECCIÃ“ DE PASSATGE:
A mÃ©s de la revisiÃ³, selecciona el MILLOR passatge del capÃ­tol (entre 150 i 250 paraules) que millor exemplifiqui la veu narrativa. Copia'l literalment del text.

Retorna ÃšNICAMENT un objecte JSON amb la segÃ¼ent estructura plana:
IMPORTANT: Si detectes solapament de diÃ legs entre personatges en un mateix parÃ graf, "ok_per_continuar" HA DE ser false i has de donar "instruccions_correccio" explÃ­cites per reescriure separant els parÃ grafs.
{
  "puntuacio": 8,
  "problemes": ["descripciÃ³ concreta del problema 1", "Solapament de diÃ legs detectat: intervencions de diferents personatges en un mateix parÃ graf. Cal reescriure separant-los."],
  "instruccions_correccio": "MÃ€XIM 30-40 PARAULES. Estil telegrÃ fic. Ex: '- Ritme massa lent. - Elimina l'info-dumping sobre la mÃ gia. - Fes que el diÃ leg final sigui mÃ©s tens.' Si Ã©s true, deixa-ho completament buit.",
  "ok_per_continuar": true,
  "prefiguracions_ok": true,
  "prefiguracions_problemes": ["descripciÃ³ del problema de prefiguraciÃ³ si n'hi ha"],
  "obertura_puntuacio": 7,
  "obertura_comentari": "comentari breu sobre l'obertura",
  "cliffhanger_puntuacio": 6,
  "cliffhanger_comentari": "comentari breu sobre el cliffhanger",
  "ritme_intern_puntuacio": 8,
  "ritme_comentari": "comentari breu sobre el ritme intern",
  "promesa_puntuacio": 7,
  "promesa_narrativa": "promesa narrativa en una frase",
  "instruccions_cliffhanger": "instruccions concretes per millorar el cliffhanger si la puntuaciÃ³ Ã©s < 6 (buit si no cal)",
  "comentari_editor_final": "possible millora global de capÃ­tol (buit si no cal)",
  "golden_passage": "el text del millor passatge (150-250 paraules)"
}

IMPORTANT: Has de comenÃ§ar la teva resposta EXACTAMENT amb el carÃ cter '{'. EstÃ  completament prohibit escriure cap salutaciÃ³, text previ o l'etiqueta \`\`\`json.
`
  }];

  const textRevisio = await callLLMMulti(
    msgs,
    "Ets un editor literari sÃ¨nior. Retorna EXCLUSIVAMENT un objecte JSON pur.",
    Object.assign({}, userConfig, { maxTokens: 2500 }),
    'arquitectura'
  );

  const revisat = parseJsonRobust(textRevisio);
  if (revisat && revisat.instruccions_correccio) {
    ESTAT._revisioInstruccions = ESTAT._revisioInstruccions || {};
    ESTAT._revisioInstruccions[idx] = revisat.instruccions_correccio;
  }

  return { response: textRevisio };
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 6: RevisiÃ³ Global Transversal (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function revisioGlobalOpusAPI(userConfig) {
  // Fragments clau de cada capÃ­tol: primer + mig + Ãºltim parÃ graf
  const fragments = ESTAT._capitols_generats.map((text, i) => {
    if (!text) return null;
    const pars = text.split(/\n\n+/).filter(p => p.trim());
    if (pars.length === 0) return null;
    const primer = pars[0].substring(0, 300);
    const mig    = pars.length > 2 ? pars[Math.floor(pars.length / 2)].substring(0, 300) : '';
    const ultim  = pars[pars.length - 1].substring(0, 300);
    return `--- CAPÃTOL ${i + 1} ---\nINICI: ${primer}${mig ? '\nMIG: ' + mig : ''}\nFINAL: ${ultim}`;
  }).filter(Boolean).join('\n\n');

  // Resums del registre
  const resums = (ESTAT.llibreRegistre.capitols || [])
    .map((c, i) => c ? `Cap.${i + 1}: ${c.resum_capitol || ''}` : '')
    .filter(Boolean).join('\n');

  const prefLlistat = llistarPrefiguracions();

  const msgs = [{
    role: 'user',
    content: `Revisa la novelÂ·la transversalment. Tens fragments representatius de cada capÃ­tol i els resums complets.

${buildBriefNarratiu()}

PREFIGURACIONS PLANIFICADES:
${prefLlistat}

RESUMS DE TOTS ELS CAPÃTOLS:
${resums || '(No disponibles)'}

FRAGMENTS REPRESENTATIUS DELS CAPÃTOLS:
${fragments || '(No disponibles)'}

Avalua:
1. COHERÃˆNCIA DE VEU: El narrador mantÃ© el mateix registre al llarg de la novelÂ·la? Detecta canvis de to injustificats.
2. REPETICIONS: Hi ha escenes, diÃ legs o descripcions que es repeteixen entre capÃ­tols?
3. COHERÃˆNCIA FACTUAL: Detalls concrets (colors, noms, distÃ ncies, dates) sÃ³n consistents?
4. PREFIGURACIONS: Totes les plantades s'han resolt? N'hi ha alguna pendent?
5. ARCS DE PERSONATGE: Cada personatge ha evolucionat? Algun s'ha estancat o ha desaparegut?
6. RITME GLOBAL: La novelÂ·la respira bÃ©? Hi ha zones mortes o massa llargues?

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "puntuacio_global": 7,
  "veu_consistent": true,
  "problemes": [{"capitol": 3, "tipus": "repeticiÃ³", "descripcio": "descripciÃ³ del problema", "gravetat": "mitja"}],
  "capitols_a_reescriure": [3],
  "instruccions_reescriptura": {"3": "instruccions concretes per al capÃ­tol 3"},
  "prefiguracions_pendents": ["element no resolt"],
  "veredicte": "text lliure amb el diagnÃ²stic general en catalÃ "
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari sÃ¨nior fent una revisiÃ³ global transversal. Retornes EXCLUSIVAMENT un objecte JSON vÃ lid. Els textos han de ser en catalÃ .',
    Object.assign({}, userConfig, { maxTokens: 3000 }),
    'arquitectura'
  );
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Reescriure capÃ­tol amb instruccions d'Opus (Sonnet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function reescriureCapitolAmbInstruccions(idx, instruccions, userConfig) {
  const textActual  = ESTAT._capitols_generats[idx] || '';
  const cap         = ESTAT._estructuraCapitols[idx];
  const capText     = cap ? cap.text : '';
  const systemPrompt= buildSystemPromptCapitol();

  const promptMilIora = `
CRITERIS DE QUALITAT LITERÃ€RIA (aplica sempre en la reescriptura):
- MOSTRA, no expliquis: substitueix el "telling" emocional ("va sentir por", "estava nerviÃ³s", "es va posar content") per accions, diÃ leg o pensament intern que mostrin l'emociÃ³.
- Alterna frases curtes, mitjanes i llargues per crear ritme i evitar la monotonia robÃ²tica.
- Varia els inicis de frase; no comencis massa seguides amb el nom del personatge o el mateix connector.
- Elimina adjectius febles i substitueix-los per verbs d'acciÃ³ forts.
- MantÃ©n veus diferenciades per a cada personatge; no parlin tots amb la mateixa cadÃ¨ncia.
- Evita clixÃ©s, resolucions mandroses i diÃ legs que exposen informaciÃ³ que els personatges ja saben.`;

  const msgs = [{
    role: 'user',
    content: `Reescriu el CapÃ­tol ${idx + 1} incorporant les correccions de l'editor.

PLANIFICACIÃ“ DEL CAPÃTOL:
${capText}

CAPÃTOL ACTUAL:
${textActual.substring(0, 4000)}${textActual.length > 4000 ? '\n[â€¦]' : ''}

INSTRUCCIONS DE CORRECCIÃ“ DE L'EDITOR (Opus):
${instruccions || 'Millora la qualitat literÃ ria general del capÃ­tol.'}
${promptMilIora}

Reescriu el capÃ­tol complet incorporant les correccions. MantÃ©n la mateixa veu i extensiÃ³ (~2000 paraules). Escriu directament la narraciÃ³ en catalÃ , sense tÃ­tol ni notes.`
  }];

  const response = await callLLMMulti(msgs, systemPrompt, Object.assign({}, userConfig, { maxTokens: 6000 }), 'generacio');
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 12: Control d'Arcs Narratius (Opus) â€” FASE 9: context complet
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function controlArcsNovella(userConfig) {
  const reg = ESTAT.llibreRegistre;
  const resums = (reg.capitols || [])
    .map((c, i) => c ? `CapÃ­tol ${i + 1}: ${c.resum_capitol || '(sense resum)'}` : '')
    .filter(Boolean)
    .join('\n');

  const filsOberts  = (reg.fils_oberts  || []).map(f => `- ${f}`).join('\n') || '(Cap registrat)';
  const filsTancats = (reg.fils_tancats || []).map(f => `- ${f}`).join('\n') || '(Cap registrat)';

  // Estructura completa (JSON si disponible, text si legacy)
  const estructuraCompleta = ESTAT.estructuraNovella || '(No disponible)';

  // Prefiguracions i si s'han resolt
  const prefCtx = llistarPrefiguracions();

  // Resultats de la revisiÃ³ global (si existeix)
  const revisioGlobalCtx = ESTAT._revisioGlobal
    ? ESTAT._revisioGlobal.veredicte || '(No disponible)'
    : '(No s\'ha realitzat revisiÃ³ global)';

  const msgs = [{
    role: 'user',
    content: `Ets un editor sÃ¨nior avaluant una novelÂ·la a partir dels resums dels capÃ­tols.

${buildBriefNarratiu()}

PREFIGURACIONS PLANIFICADES:
${prefCtx}

RESULTAT DE LA REVISIÃ“ GLOBAL (Opus transversal):
${revisioGlobalCtx}

ESTRUCTURA PLANIFICADA ORIGINALMENT:
${estructuraCompleta}

RESUMS DELS CAPÃTOLS ESCRITS:
${resums || '(Cap capÃ­tol generat)'}

FILS NARRATIUS OBERTS: ${filsOberts}
FILS NARRATIUS TANCATS: ${filsTancats}

Revisa i diagnostica:
1. S'ha complert la premissa original?
2. El final planificat s'ha executat adequadament?
3. Queden fils oberts greus que fan la novelÂ·la incompleta?
4. Hi ha incoherÃ¨ncies de personatges o de trama detectades als resums?
5. Totes les prefiguracions planificades s'han resolt? Indica explÃ­citament quines queden obertes.

Retorna un diagnÃ²stic detallat en catalÃ . Si hi ha fils oberts greus, prefiguracions no resoltes o el final no s'ha resolt adequadament, proposa detalladament el contingut d'un EPÃLEG que els tanqui (secciÃ³ clarament marcada com "PROPOSTA D'EPÃLEG").`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor sÃ¨nior de novelÂ·la. Analitzes amb rigor i retornes un diagnÃ²stic constructiu i accionable en catalÃ .',
    Object.assign({}, userConfig, { maxTokens: 3500 }),
    'arquitectura'
  );
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Checkpoint de coherÃ¨ncia a meitat de novelÂ·la
//  S'executa automÃ ticament al capÃ­tol N/2 (novelÂ·les â‰¥16 caps)
//  Genera ajustos de rumb que s'injecten a tots els capÃ­tols restants
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function controlArcsIntermedi(capitolActual, userConfig) {
  const reg = ESTAT.llibreRegistre;
  const totalCapitols = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols.length : 0;
  const capsRestants = totalCapitols - capitolActual;

  const resums = (reg.capitols || [])
    .slice(0, capitolActual)
    .map((c, i) => c ? `CapÃ­tol ${i + 1}: ${c.resum_capitol || '(sense resum)'}` : '')
    .filter(Boolean)
    .join('\n');

  const filsOberts = (reg.fils_oberts || []).map(f => `- ${f}`).join('\n') || '(Cap registrat)';

  const prefCtx = llistarPrefiguracions();

  // CapÃ­tols pendents (de N/2 fins al final)
  const capsRestantsText = (ESTAT._estructuraCapitols || [])
    .slice(capitolActual)
    .map((c, i) => `Cap. ${capitolActual + i + 1}: "${c.titol || ''}" â€” ${(c.resum || '').substring(0, 80)}`)
    .join('\n');

  const msgs = [{
    role: 'user',
    content: `Ets un editor sÃ¨nior fent una revisiÃ³ de coherÃ¨ncia a MEITAT d'una novelÂ·la en curs.

${buildBriefNarratiu()}

PREFIGURACIONS PLANIFICADES (plantades i per plantar):
${prefCtx}

RESUMS DELS CAPÃTOLS ESCRITS FINS ARA (${capitolActual} de ${totalCapitols}):
${resums || '(Cap resum disponible)'}

FILS NARRATIUS OBERTS: ${filsOberts}

CAPÃTOLS QUE QUEDEN PER ESCRIURE (${capsRestants} capÃ­tols restants):
${capsRestantsText}

La novelÂ·la va per la meitat. Diagnostica l'estat actual i genera instruccions de rumb per als capÃ­tols restants.

Analitza:
1. SUBTRAMES: Quines subtrames s'estan desenvolupant correctament? Quines s'han descuidat o han desaparegut?
2. PERSONATGES: Algun personatge important porta massa capÃ­tols sense aparÃ¨ixer o amb arc estancat?
3. PREFIGURACIONS: Quines prefiguracions plantades han de recollir-se en els capÃ­tols restants? UrgÃ¨ncia?
4. DERIVA DE TRAMA: Hi ha alguna desviaciÃ³ respecte a l'arc planificat originalment que calgui corregir?
5. RITME: El ritme actual (tensiÃ³ acumulada fins ara) Ã©s adequat per arribar al clÃ­max planificat?
6. ARC MORAL DEL PROTAGONISTA: El protagonista ha mostrat RESISTÃˆNCIA genuÃ¯na a la seva transformaciÃ³? (no compten dubtes retÃ²rics o monÃ²legs interns). Hi ha hagut almenys un moment de "backsliding" on intenta tornar als seus valors originals? Si la resposta Ã©s NO a qualsevol dels dos, marca "arc_lineal" com a problema greu i recomana un capÃ­tol de reversiÃ³.

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "estat_subtrames": [
    {"nom": "nom subtrama", "estat": "activa/descuidada/resolta", "urgent": true, "nota": "breu diagnÃ²stic"}
  ],
  "personatges_absents": ["nom1", "nom2"],
  "prefiguracions_urgents": [
    {"element": "descripciÃ³", "capitol_resolucio": 15, "nota": "breu indicaciÃ³ de com resoldre-la"}
  ],
  "deriva_detectada": "descripciÃ³ breu si n'hi ha, buit si tot va bÃ©",
  "arc_lineal": false,
  "ajustos_rumb": "instruccions concretes en 3-5 lÃ­nies per als capÃ­tols restants: quins fils recuperar, quins personatges fer aparÃ¨ixer, quines tensions apujar o baixar. Escrit com a nota interna de l'arquitecte per al model que escriurÃ  els capÃ­tols."
}`
  }];

  try {
    const response = await callLLMMulti(
      msgs,
      'Ets un editor sÃ¨nior de novelÂ·la. Retornes EXCLUSIVAMENT JSON vÃ lid, sense text addicional.',
      Object.assign({}, userConfig, { maxTokens: 2000 }),
      'arquitectura'
    );
    const data = parseJsonRobust(response);
    if (data && data.ajustos_rumb) {
      ESTAT._ajustosRumb = data.ajustos_rumb;
      ESTAT._checkpointIntermedi = data;
      console.log(`Checkpoint meitat novelÂ·la (cap.${capitolActual}/${totalCapitols}):`, data.ajustos_rumb);
    }
    return data;
  } catch (err) {
    console.warn('Checkpoint intermedi: error no bloquejant:', err.message);
    return null;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EpÃ­leg Resolutiu (Sonnet) â€” FASE 7: context real
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEpileg(instruccionsOpus, userConfig) {
  const registreCtx  = buildRegistreContext(ESTAT._estructuraCapitols.length);
  const systemPrompt = buildSystemPromptCapitol();

  // Ãšltim capÃ­tol complet (o Ãºltims 3000 chars)
  const numCaps      = ESTAT._capitols_generats.length;
  const ultimCapText = numCaps > 0 && ESTAT._capitols_generats[numCaps - 1]
    ? ESTAT._capitols_generats[numCaps - 1].slice(-3000)
    : '(No disponible)';

  // Primer parÃ graf del primer capÃ­tol (per tancament circular)
  const primerCapText = ESTAT._capitols_generats[0]
    ? ESTAT._capitols_generats[0].split(/\n\n+/).filter(p => p.trim())[0] || ''
    : '';

  // Prefiguracions pendents (de la revisiÃ³ global si existeix)
  const prefsPendents = ESTAT._revisioGlobal && Array.isArray(ESTAT._revisioGlobal.prefiguracions_pendents)
    ? ESTAT._revisioGlobal.prefiguracions_pendents
    : [];

  const msgs = [{
    role: 'user',
    content: `Escriu l'EPÃLEG de la novelÂ·la seguint les instruccions de l'editor.

${buildBriefNarratiu()}

DIAGNÃ’STIC I INSTRUCCIONS DE L'EDITOR (Opus):
${instruccionsOpus ? instruccionsOpus.substring(0, 2000) : '(No disponible)'}
${registreCtx}

PRIMER PARÃ€GRAF DE LA NOVELÂ·LA (per tancar el cercle narratiu):
${primerCapText || '(No disponible)'}

ÃšLTIM CAPÃTOL (per continuÃ¯tat de to i escena):
${ultimCapText}

${prefsPendents.length > 0 ? 'PREFIGURACIONS PENDENTS DE RESOLUCIÃ“:\n' + prefsPendents.map(p => `- ${p}`).join('\n') : ''}

L'epÃ­leg ha de:
- Tancar els fils narratius indicats per l'editor
- Connectar directament amb l'escena final de l'Ãºltim capÃ­tol (continuÃ¯tat de to)
- Fer eco del primer parÃ graf de la novelÂ·la (tancament circular)
- Tenir entre 450 i 900 paraules (si cal, una mica mÃ©s curt per assegurar completitud)
- Resoldre les prefiguracions pendents si n'hi ha
- PRIORITAT ABSOLUTA: retorna un epÃ­leg complet i tancat; no deixis el text a mitges

Escriu directament el text de l'epÃ­leg en catalÃ , sense tÃ­tol ni notes de l'autor.`
  }];

  const response = await callLLMOneShotPlusCompletion(msgs, systemPrompt, Object.assign({}, userConfig, { maxTokens: 2600, model: getModelConfig(userConfig).modelGeneracio }), 'generacio');
  return { response };
}

// â”€â”€â”€ SISTEMA 1: BÃ­blia Narrativa â€” backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function inicialitzarBiblia(userConfig) {
  const brief = buildBriefNarratiu();
  const personatgesCtx = ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0
    ? ESTAT._personatgesSeleccionats.join('\n')
    : '(No definit)';

  const msgs = [{
    role: 'user',
    content: `Crea una bÃ­blia narrativa estructurada a partir del material existent.

${brief}

CONTE ORIGINAL (resum):
${ESTAT.conteText ? ESTAT.conteText.substring(0, 2000) + (ESTAT.conteText.length > 2000 ? '\n[â€¦]' : '') : '(No disponible)'}

BÃBLIA DE MÃ“N:
${ESTAT.worldbuilding ? ESTAT.worldbuilding.substring(0, 1500) + (ESTAT.worldbuilding.length > 1500 ? '\n[â€¦]' : '') : '(No definida)'}

ELENC DE PERSONATGES:
${personatgesCtx}

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "regles_mon": ["regla del mÃ³n 1", "regla del mÃ³n 2"],
  "llocs_importants": [{"nom": "nom del lloc", "descripcio": "descripciÃ³ breu del lloc i el seu paper"}],
  "objectes_clau": [{"nom": "nom de l'objecte", "significat": "significat narratiu o simbÃ²lic"}],
  "fitxes_personatges": [
    {
      "nom": "nom",
      "motivacions": "motivaciÃ³ principal (1 frase)",
      "secrets": "secret principal o buit",
      "estat_actual": "estat breu (1 frase)"
    }
  ],
  "fets_canonics": ["fet establert que NO es pot contradir 1", "fet establert 2"]
}

IMPORTANT: El JSON ha de ser COMPLET amb TOTS els personatges de l'elenc. MantÃ©n les descripcions concises (1 frase per camp) per assegurar que el JSON no es talli.`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari creant una bÃ­blia narrativa de referÃ¨ncia. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 6000 }),
    'arquitectura'
  );

  const dades = parseJsonRobust(response);
  if (dades) {
    if (dades.regles_mon)         ESTAT.bibliaNarrativa.regles_mon         = dades.regles_mon;
    if (dades.llocs_importants)   ESTAT.bibliaNarrativa.llocs_importants   = dades.llocs_importants;
    if (dades.objectes_clau)      ESTAT.bibliaNarrativa.objectes_clau      = dades.objectes_clau;
    if (dades.fitxes_personatges) ESTAT.bibliaNarrativa.fitxes_personatges = dades.fitxes_personatges;
    const fetsInicials = normalitzarFetsCanonics(dades.fets_canonics || []);
    ESTAT.bibliaNarrativa.fets_canonics = fetsInicials.length > 0
      ? fetsInicials
      : normalitzarFetsCanonics(((ESTAT._nkg && ESTAT._nkg.fets_canonics) || []).map(f => f.descripcio));
  }
  return { response };
}

async function completarBibliaPersonatges(userConfig) {
  const biblia = ESTAT.bibliaNarrativa;
  const nomsExistents = (biblia.fitxes_personatges || []).map(f => f.nom.toLowerCase());
  const personatgesFaltants = (ESTAT._personatgesSeleccionats || []).filter(nom => {
    const nomNet = nom.replace(/\*\*/g, '').split('|')[0].split(',')[0].trim().toLowerCase();
    return !nomsExistents.some(n => n.includes(nomNet) || nomNet.includes(n));
  });

  if (personatgesFaltants.length === 0) return;

  const msgs = [{
    role: 'user',
    content: `Crea fitxes per als personatges que falten a la bÃ­blia narrativa.

PERSONATGES QUE JA TENEN FITXA: ${nomsExistents.join(', ') || '(cap)'}

PERSONATGES QUE FALTEN:
${personatgesFaltants.join('\n')}

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "fitxes_personatges": [
    {
      "nom": "nom",
      "motivacions": "motivaciÃ³ principal (1 frase)",
      "secrets": "secret principal o buit",
      "estat_actual": "estat breu (1 frase)"
    }
  ]
}

Descripcions concises: 1 frase per camp.`
  }];

  const response = await callLLMMulti(msgs,
    'Retorna EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 2000 }), 'arquitectura');

  const dades = parseJsonRobust(response);
  if (dades && dades.fitxes_personatges) {
    biblia.fitxes_personatges = (biblia.fitxes_personatges || []).concat(dades.fitxes_personatges);
    console.log(`BÃ­blia completada: ${biblia.fitxes_personatges.length} fitxes totals`);
  }
}

async function actualitzarBiblia(textCapitol, idx, userConfig) {
  const biblia = ESTAT.bibliaNarrativa;
  const bibliaCurrent = JSON.stringify({
    fitxes_personatges: biblia.fitxes_personatges || [],
    fets_canonics:      (biblia.fets_canonics || []).slice(-10)
  });

  const msgs = [{
    role: 'user',
    content: `Actualitza la bÃ­blia narrativa amb el que ha passat en el CapÃ­tol ${idx + 1}.

BÃBLIA ACTUAL (resum):
${bibliaCurrent}

CAPÃTOL ${idx + 1} GENERAT:
${textCapitol.substring(0, 4000)}${textCapitol.length > 4000 ? '\n[â€¦text truncatâ€¦]' : ''}

Identifica NOMÃ‰S canvis reals (no repeteixis el que ja Ã©s a la bÃ­blia):

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid:
{
  "nous_fets_canonics": ["nou fet establert en aquest capÃ­tol"],
  "actualitzar_personatges": [
    {"nom": "nom", "nou_estat": "nou estat emocional/fÃ­sic", "nous_secrets": "secrets revelats o nous", "motivacions": "motivaciÃ³ actualitzada si ha canviat"}
  ],
  "nous_llocs": [{"nom": "lloc nou", "descripcio": "descripciÃ³"}],
  "nous_objectes": [{"nom": "objecte nou", "significat": "significat"}]
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari actualitzant una bÃ­blia narrativa. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 1500, model: getModelConfig(userConfig).modelDraft, _esDraft: true }),
    'generacio'
  );

  const canvis = parseJsonRobust(response) || {};
  if (!Array.isArray(canvis.nous_fets_canonics) || canvis.nous_fets_canonics.length === 0) {
    const fetsNkgCapitol = ((ESTAT._nkg && ESTAT._nkg.fets_canonics) || [])
      .filter(f => Number(f.capitol_origen) === idx + 1)
      .map(f => f.descripcio);
    if (fetsNkgCapitol.length > 0) canvis.nous_fets_canonics = fetsNkgCapitol;
  }
  aplicarCanvisBiblia(canvis);
  return { response };
}

// â”€â”€â”€ SISTEMA 2: Fase de Trames â€” backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function generarTrames(userConfig) {
  const brief = buildBriefNarratiu();
  const bibliaCtx = ESTAT.bibliaNarrativa.fitxes_personatges && ESTAT.bibliaNarrativa.fitxes_personatges.length > 0
    ? '\nPERSONATGES (bÃ­blia):\n' + ESTAT.bibliaNarrativa.fitxes_personatges.map(p => `${p.nom}: ${p.motivacions || ''}`).join('\n')
    : '';

  const msgs = [{
    role: 'user',
    content: `Dissenya l'arquitectura de trames per a aquesta novelÂ·la.

${brief}

CONTE ORIGINAL:
${ESTAT.conteText || '(No disponible)'}

BÃBLIA DE MÃ“N:
${ESTAT.worldbuilding || '(No definida)'}

ELENC DE PERSONATGES:
${ESTAT._personatgesSeleccionats ? ESTAT._personatgesSeleccionats.join('\n') : '(No definit)'}${bibliaCtx}

ESTILS DE PARLA:
${ESTAT.estilsParla || '(No definits)'}

Crea un disseny de trames entrellaÃ§ades que:
1. Tingui una trama principal clara que connecti amb el final planificat
2. 2-4 subtrames que enriqueixin el mÃ³n i els personatges secundaris
3. Un mapa de com les trames s'entrelaÃ§en capÃ­tol a capÃ­tol (aproximat, 12-22 capÃ­tols)
4. Cada subtrama ha de tenir una resoluciÃ³ prÃ²pia (no necessÃ riament al capÃ­tol final)

REGLA DE REALISME D'INVESTIGACIÃ“: Prohibit utilitzar "MacGuffins" propis del cinema d'acciÃ³ (com llapis USB encriptats amb autodestrucciÃ³, missatges pÃ²stums pre-gravats, claus amagades en llocs secrets o pistes plantades de forma inversemblant). Tota investigaciÃ³ o descobriment de la veritat s'ha de fer a travÃ©s de mÃ¨todes lents i realistes: creuament de dades financeres avorrides, solÂ·licituds de transparÃ¨ncia governamental, contradiccions en documents notarials o factures, testimonis que diuen mitges veritats.

IMPORTANT: El JSON ha de ser COMPLET. El mapa_entrellacat ha de cobrir TOTS els capÃ­tols (12-22 entrades). Les notes del mapa han de ser MOLT breus (3-5 paraules mÃ xim per estalviar espai).

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "trama_principal": {
    "descripcio": "descripciÃ³ de la trama principal en 3-5 lÃ­nies",
    "conflicte_central": "el conflicte central en una frase",
    "arc_protagonista": "com evoluciona el protagonista",
    "resolucio": "com i quan es resol"
  },
  "subtrames": [
    {
      "nom": "nom de la subtrama",
      "descripcio": "descripciÃ³ breu",
      "personatges_implicats": ["nom1", "nom2"],
      "capitol_inici": 2,
      "capitol_resolucio": 10,
      "com_entrellaÃ§a": "com s'entrellaÃ§a amb la trama principal"
    }
  ],
  "mapa_entrellacat": [
    {"capitol": 1, "trames_actives": ["trama_principal"], "notes": "establiment del mÃ³n"},
    {"capitol": 2, "trames_actives": ["trama_principal", "subtrama_1"], "notes": "s'introdueix la subtrama 1"}
  ]
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un arquitecte narratiu expert en construcciÃ³ de trames entrellaÃ§ades. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 8192 }),
    'arquitectura'
  );

  return { response };
}

async function completarMapaTrames(tramesTotals, capsEsperats, userConfig) {
  const tp = tramesTotals.trama_principal;
  const tpDesc = tp ? (typeof tp === 'string' ? tp : (tp.descripcio || JSON.stringify(tp))) : '?';
  const subtramesNoms = (tramesTotals.subtrames || []).map(st => st.nom).join(', ');
  const msgs = [{
    role: 'user',
    content: `Genera el mapa d'entrellaÃ§at COMPLET per a exactament ${capsEsperats} capÃ­tols.

TRAMA PRINCIPAL: ${tpDesc}
SUBTRAMES: ${subtramesNoms || '(cap)'}

Retorna EXCLUSIVAMENT un JSON vÃ lid amb EXACTAMENT ${capsEsperats} entrades:
{
  "mapa_entrellacat": [
    {"capitol": 1, "trames_actives": ["trama_principal"], "notes": "breu 3-5 paraules"},
    {"capitol": 2, "trames_actives": ["trama_principal", "nom_subtrama"], "notes": "breu"},
    ... fins a capitol ${capsEsperats}
  ]
}

CRÃTIC: Han de ser EXACTAMENT ${capsEsperats} entrades. Notes de 3-5 paraules MÃ€XIM.`
  }];
  const response = await callLLMMulti(msgs,
    'Retorna EXCLUSIVAMENT JSON vÃ lid. Cap text addicional.',
    Object.assign({}, userConfig, { maxTokens: 2048 }), 'arquitectura');
  return { response };
}

// â”€â”€â”€ SISTEMA 4: Checkpoint de coherÃ¨ncia â€” backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function executarCheckpoint(idx, userConfig) {
  const brief = buildBriefNarratiu();

  const capitolsEscrits = ESTAT._capitols_generats
    .slice(0, idx + 1)
    .map((text, i) => {
      if (!text) return null;
      const resum = (ESTAT.llibreRegistre.capitols[i] && ESTAT.llibreRegistre.capitols[i].resum_capitol)
        || text.substring(0, 300) + 'â€¦';
      return `CapÃ­tol ${i + 1}: ${resum}`;
    })
    .filter(Boolean)
    .join('\n');

  const ajustosAnteriors = ESTAT._ajustosRumb
    ? '\nAJUSTOS DE RUMB ANTERIORS:\n' + (typeof ESTAT._ajustosRumb === 'string' ? ESTAT._ajustosRumb : JSON.stringify(ESTAT._ajustosRumb))
    : '';

  // DetecciÃ³ programÃ tica de repeticions temÃ tiques (NKG)
  const repetidesTematiques = detectarRepeticionsTematiques();
  const repetidesTematiquesCtx = repetidesTematiques
    ? '\nREVELACIONS REPETIDES DETECTADES:\n' + repetidesTematiques.map(r =>
        `- "${r.tema}" repetida ${r.cops} vegades (caps. ${r.capitols.join(', ')})`
      ).join('\n') +
      '\nINSTRUCCIÃ“: Si una revelaciÃ³ emocional ja s\'ha produÃ¯t, el segÃ¼ent capÃ­tol ha de COMPLICAR-LA (afegir una capa nova, una contradicciÃ³, un cost emocional diferent) o SUPERAR-LA (el personatge ja ho sap i actua en conseqÃ¼Ã¨ncia, no ho "redescobeix").'
    : '';

  const tramesCtx = ESTAT.trames.trama_principal
    ? `\nTRAMA PRINCIPAL: ${typeof ESTAT.trames.trama_principal === 'string' ? ESTAT.trames.trama_principal : (ESTAT.trames.trama_principal.descripcio || '')}
SUBTRAMES: ${ESTAT.trames.subtrames.length > 0 ? ESTAT.trames.subtrames.map(st => st.nom + ': ' + (st.descripcio || '')).join(' | ') : '(cap)'}`
    : '';

  const msgs = [{
    role: 'user',
    content: `Fes un checkpoint de coherÃ¨ncia narrativa desprÃ©s del CapÃ­tol ${idx + 1}.

${brief}${tramesCtx}

CAPÃTOLS ESCRITS FINS ARA:
${capitolsEscrits}${ajustosAnteriors}${repetidesTematiquesCtx}

Verifica:
1. CoherÃ¨ncia entre capÃ­tols (no contradiccions, no lapsus de memÃ²ria dels personatges)
2. Les subtrames s'estan desenvolupant com estava planificat
3. El ritme narratiu Ã©s adequat (ni massa accelerat ni estancat)
4. Les prefiguracions plantades es mantenen sense resoldre prematurament
5. VITALITAT DELS SECUNDARIS: Per a cada personatge secundari, indica si ha tingut almenys una escena d'autonomia en els Ãºltims 4 capÃ­tols. Si algun secundari porta 4+ capÃ­tols sent nomÃ©s reactiu al protagonista, marca'l com a "estancat" i recomana una escena d'autonomia.

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid:
{
  "puntuacio_coherencia": 8,
  "valoracio_general": "descripciÃ³ breu de l'estat de la novelÂ·la en una frase",
  "problemes_detectats": ["problema concret 1 si n'hi ha"],
  "recomanacions": ["recomanaciÃ³ especÃ­fica per als prÃ²xims capÃ­tols"],
  "secundaris_estancats": ["nom del personatge estancat si n'hi ha"],
  "ajustos_rumb": "instruccions especÃ­fiques per als capÃ­tols ${idx + 2}-${idx + 4} si cal ajustar el rumb (buit si tot va bÃ©)"
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari fent un checkpoint de coherÃ¨ncia narrativa. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 1500 }),
    'arquitectura'
  );

  const dades = parseJsonRobust(response);
  mostrarCheckpoint(dades, idx);
  return { response, dades };
}

async function executarLoopCoherenciaFinal(userConfig) {
  const total = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols.length : 0;
  if (total <= 0) return;

  const idxFinal = total - 1;
  const puntuacioObjectiu = 8;
  const maxIteracions = 3;

  for (let iter = 1; iter <= maxIteracions; iter++) {
    const loaderEl = document.getElementById('loader-11-text');
    if (loaderEl) loaderEl.textContent = `ğŸ” RevisiÃ³ final de coherÃ¨ncia (${iter}/${maxIteracions})â€¦`;

    let dades = null;
    try {
      const checkpoint = await executarCheckpoint(idxFinal, userConfig);
      dades = checkpoint ? checkpoint.dades : null;
    } catch (err) {
      console.warn('Loop final coherÃ¨ncia: checkpoint fallit:', err.message);
      break;
    }

    const punts = Number((dades && dades.puntuacio_coherencia) || 0);
    if (punts >= puntuacioObjectiu) {
      toast(`âœ… CoherÃ¨ncia final validada (${punts}/10).`);
      return;
    }

    const blocInici = Math.max(0, idxFinal - (2 + (iter - 1) * 2));
    try {
      if (loaderEl) loaderEl.textContent = `ğŸ› ï¸ Aplicant correccions finals (${iter}/${maxIteracions})â€¦`;
      await microReescripturaBlocOpus(blocInici, idxFinal, userConfig);
    } catch (err) {
      console.warn('Loop final coherÃ¨ncia: micro-reescriptura fallida:', err.message);
      break;
    }
  }

  toast("â„¹ï¸ RevisiÃ³ final completada amb marge de millora. Revisa control d'arcs per ajustos addicionals.");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10.5: Generar Escaleta per Bloc de CapÃ­tols (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEscaletaBloc(capitols, offset, userConfig) {
  const brief = buildBriefNarratiu();
  const capsText = capitols.map((c, i) => `Cap. ${offset + i + 1}: ${c.titol || ''} â€” ${c.resum || ''}`).join('\n');
  const corbaTensio = ESTAT._corbaTensio || [];

  // Arc moral del protagonista (si existeix)
  const arcMoral = ESTAT._arcMoral;
  const arcMoralCtx = arcMoral ? (() => {
    const capsBloc = capitols.map((_, i) => offset + i + 1);
    const punts = [];
    if (arcMoral.backsliding && capsBloc.includes(arcMoral.backsliding.capitol)) {
      punts.push(`BACKSLIDING (cap. ${arcMoral.backsliding.capitol}): Almenys 2 escenes on el protagonista intenta genuÃ¯nament tornar al seu antic jo. Ha de ser un intent CREÃBLE, no un gest simbÃ²lic. DescripciÃ³: ${arcMoral.backsliding.descripcio}`);
    }
    if (arcMoral.punt_no_retorn && capsBloc.includes(arcMoral.punt_no_retorn.capitol)) {
      punts.push(`PUNT DE NO RETORN (cap. ${arcMoral.punt_no_retorn.capitol}): L'escena de decisiÃ³ ha de ser AMBIGUA moralment â€” el lector ha de poder defensar tant la decisiÃ³ com la seva alternativa. DescripciÃ³: ${arcMoral.punt_no_retorn.descripcio}`);
    }
    if (arcMoral.primera_fissura && capsBloc.includes(arcMoral.primera_fissura.capitol)) {
      punts.push(`PRIMERA FISSURA (cap. ${arcMoral.primera_fissura.capitol}): El moment on els principis del protagonista fallen per primera vegada. DescripciÃ³: ${arcMoral.primera_fissura.descripcio}`);
    }
    return punts.length > 0 ? '\n\nVERIFICACIÃ“ D\'ARC MORAL DEL PROTAGONISTA:\n' + punts.join('\n') : '';
  })() : '';
  const prompt = `Ets un dramaturg expert. Genera una escaleta detallada per escenes per als capÃ­tols segÃ¼ents de la novelÂ·la.

BRIEF:
${brief}

CAPÃTOLS A ESCALETEJAR:
${capsText}

ESCENES PER CAPÃTOL (adapta al ritme del capÃ­tol):
- Genera entre 5 i 8 escenes per a aquest capÃ­tol. (No menys de 5).
- CapÃ­tols d'exposiciÃ³/respiraciÃ³ (nivell tensiÃ³ â‰¤4): 5-6 escenes (~650 paraules/escena). Aprofita per desplegar el mÃ³n, explorar relacions i construir subtexte emocional.
- CapÃ­tols de desenvolupament (nivell tensiÃ³ 5-7): 6-7 escenes (~700 paraules/escena). Alterna acciÃ³ i respiraciÃ³; cada escena ha de capgirar o complicar la situaciÃ³ anterior.
- CapÃ­tols de clÃ­max/acciÃ³ (nivell tensiÃ³ â‰¥8): 7-8 escenes (~550 paraules/escena, ritme rÃ pid). REGLA CRÃTICA: En els clÃ­maxs, crea SEMPRE una escena de beat "introspecciÃ³" per a la PRESA DE DECISIÃ“ (mostrant el cost fÃ­sic/mental), separada i prÃ¨via a l'escena d'"acciÃ³" posterior.
- CapÃ­tol final/resoluciÃ³: 5-6 escenes (~750 paraules/escena, ritme pausat). DÃ³na espai per tancar fils secundaris i deixar una ressonÃ ncia emocional duradora.

TOTAL OBJECTIU: ~3.500-5.000 paraules per capÃ­tol. La novelÂ·la completa ha de fer entre 60.000 i 100.000 paraules (12-22 capÃ­tols Ã— ~4.000 paraules).

CORBA DE TENSIÃ“ (per orientar el ritme de cada capÃ­tol):
${corbaTensio.length > 0 ? corbaTensio.map(t => `Cap.${t.capitol}: nivell ${t.nivell} (${t.tipus})`).join(', ') : '(no disponible)'}${arcMoralCtx}

Cada escena ha d'incloure (camps OBLIGATORIS, res mÃ©s):
- nom: tÃ­tol breu (3-5 paraules)
- paraules_objectiu: nombre enter
- funcio_narrativa: 1 frase curta (mÃ xim 10 paraules)
- personatges: array de noms
- beat_narratiu: "diÃ leg" | "acciÃ³" | "introspecciÃ³" | "descripciÃ³"
- REGLA DE DIÃ€LEG: Com a mÃ­nim el 50% de les escenes d'un capÃ­tol han de tenir el "beat_narratiu" fixat a "diÃ leg". Prioritza sempre la interacciÃ³ verbal.
- Cada escena ha de tenir un objectiu fÃ­sic (avanÃ§ar en la trama) i un objectiu emocional o reflexiu (introspecciÃ³, record, subtrama).

NO incloguis emocio_entrada, emocio_sortida ni punt_inflexio per estalviar espai.

REGLA DE PROFUNDITAT DELS SECUNDARIS:
- Cada personatge secundari ha de tenir almenys 1 escena cada 4 capÃ­tols on actuÃ¯ per iniciativa prÃ²pia (no com a reacciÃ³ al protagonista).
- En aquestes escenes, el secundari ha de mostrar un desig, por o contradicciÃ³ que NO estigui directament relacionada amb la trama principal.
- Indica al camp "funcio_narrativa" quan una escena Ã©s d'"autonomia del secundari" amb el tag [AUTONOMIA: Nom].

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "escaletes": [
    {
      "capitol": 1,
      "titol": "tÃ­tol del capÃ­tol",
      "escenes": [
        {
          "nom": "nom breu",
          "paraules_objectiu": 450,
          "funcio_narrativa": "frase curta",
          "personatges": ["nom1"],
          "beat_narratiu": "diÃ leg"
        }
      ]
    }
  ]
}`;
  const msgs = [{ role: 'user', content: prompt }];
  const models = getModelConfig(userConfig);
  const response = await callLLMMulti(
    msgs,
    'Ets un dramaturg expert en narrativa i estructura d\'escenes.',
    Object.assign({}, userConfig, { maxTokens: 8192, model: models.modelArquitecte }),
    'arquitectura'
  );
  return { response };
}

async function cridaAPI_GenerarText(promptEscena, systemPrompt, userConfig, maxTokensOverride) {
  const models = getModelConfig(userConfig);
  const cfg = Object.assign({}, userConfig, {
    maxTokens: maxTokensOverride || Math.max(1500, (promptEscena.length / 2) | 0),
    model: models.modelGeneracio
  });
  return await callLLMMulti([{ role: 'user', content: promptEscena }], systemPrompt, cfg, 'generacio');
}

async function avaluarQualitatLiteraria(textEscena, userConfig) {
  const models = getModelConfig(userConfig);
  const textNet = String(textEscena || '').slice(0, 6000);

  // --- NIVELL 1: JUTGE PROGRAMÃ€TIC (0 tokens, estalvi de costos) ---
  const instanciesTelling = detectarTellingEmocional(textNet);
  const metriquesVeu = analitzarVarianciaVeu(textNet);
  const problemesProgramatics = [];

  // Rebuig per Telling (MÃ©s de 3 Ã©s inacceptable)
  if (instanciesTelling.length > 3) {
    problemesProgramatics.push(`S'ha detectat massa 'telling' emocional directe: ${instanciesTelling.slice(0, 3).join(', ')}... Cal MOSTRAR l'emociÃ³ amb accions o diÃ leg, no etiquetar-la.`);
  }

  // Rebuig per mecÃ niques de veu pobres
  if (metriquesVeu) {
    if (metriquesVeu.ratioConsecutives > 0.65) {
      problemesProgramatics.push("La prosa Ã©s massa monÃ²tona i robÃ²tica: hi ha massa frases consecutives de la mateixa longitud. Alterna frases curtes, mitjanes i llargues.");
    }
    if (metriquesVeu.ratioStarts > 0.4) {
      problemesProgramatics.push("Falta varietat en els inicis de frase. Massa frases comencen de la mateixa manera. Utilitza diferents connectors o estructures.");
    }
    if (metriquesVeu.densitat_adjectival > 0.6) {
      problemesProgramatics.push("SobrecÃ rrega d'adjectius detectada. Poda'ls i substitueix-los per noms mÃ©s precisos o verbs d'acciÃ³.");
    }
    if (metriquesVeu.comparacions_com > 3) {
      problemesProgramatics.push("ExcÃ©s de comparacions ('com un/a'). Redueix-les a un mÃ xim de 3 i substitueix la resta per metÃ fores directes.");
    }
    if (metriquesVeu.adverbisTotal > 6) {
      problemesProgramatics.push("Massa adverbis acabats en '-ment'. Redueix-los i utilitza verbs mÃ©s forts.");
    }
  }

  // Si no supera el Nivell 1, tallem l'execuciÃ³ aquÃ­ sense cridar a l'API
  if (problemesProgramatics.length > 0) {
    console.log("â›” Rebutjat pel Jutge ProgramÃ tic (estalviant tokens):", problemesProgramatics);
    const scoreProgramatic = Math.max(30, 72 - (problemesProgramatics.length * 9));
    return {
      aprovat: false,
      critiques: "Filtre de qualitat automÃ tic no superat: " + problemesProgramatics.join(" "),
      score_global: scoreProgramatic,
      blocking_issues: problemesProgramatics,
      sub_scores: {
        coherencia: Math.max(35, scoreProgramatic - 8),
        veu: Math.max(35, scoreProgramatic - 5),
        dialeg: Math.max(35, scoreProgramatic - 5),
        prosa: Math.max(35, scoreProgramatic - 7),
        catala: Math.max(40, scoreProgramatic)
      }
    };
  }

  // --- NIVELL 2: JUTGE LLM (NomÃ©s si passa el Nivell 1 o no detectem errors greus programÃ tics) ---
  const promptAvaluador = `Ets un editor literari exigent i un filÃ²leg expert en llengua catalana. Llegeix aquest text:

"""${textNet}"""

La teva tasca tÃ© dues parts:
1. AVALUACIÃ“ LITERÃ€RIA: Rebutja l'escena immediatament si detectes qualsevol d'aquests errors de principiant:
   - INFO-DUMPING: Personatges explicant coses que l'altre personatge ja sap, nomÃ©s perquÃ¨ el lector se n'assabenti.
   - MONÃ’LEG DE DOLENT / EXPOSICIÃ“ DIRECTA: Figures de poder explicant els seus plans clarament. Han de parlar en eufemismes.
   - CLIXÃ‰S DE GÃˆNERE: Resolucions mandroses, diÃ legs forÃ§ats per moure la trama, situacions de perill inversemblants.
   - CANVIS EMOCIONALS PRECIPITATS: Personatges que canvien d'opiniÃ³ o principis molt rÃ pid sense racionalitzar-ho.
   - SÃNDROME 'AS YOU KNOW, BOB': Rebutja si hi ha un diÃ leg on un personatge explica fets que l'altre ja sap. Tota informaciÃ³ s'ha de revelar a travÃ©s de conflicte o subtext.
   - VEUS IDÃˆNTIQUES: Rebutja si tots els personatges parlen amb la mateixa cadÃ¨ncia literÃ ria. Les veus s'han de diferenciar.
   - ARQUETIPS PLANS: Rebutja si un personatge secundari actua sense matÃ­s, contradicciÃ³ moral o complexitat.
2. CORRECCIÃ“ LINGÃœÃSTICA: Detecta faltes d'ortografia, castellanismes flagrants o mala gramÃ tica.

Retorna ÃšNICAMENT un objecte JSON amb aquest format exacte:
{
  "aprovat": true/false,
  "score_global": 0-100,
  "sub_scores": {
    "coherencia": 0-100,
    "veu": 0-100,
    "dialeg": 0-100,
    "prosa": 0-100,
    "catala": 0-100
  },
  "blocking_issues": ["error crÃ­tic 1", "error crÃ­tic 2"],
  "critiques": "Descriu els errors narratius i/o llista les paraules incorrectes i la seva correcciÃ³. Si tot Ã©s literÃ riament correcte, deixa-ho buit."
}`;

  try {
    const raw = await callLLMMulti(
      [{ role: 'user', content: promptAvaluador }],
      'Ets un jutge literari i corrector expert en catalÃ . Retorna Ãºnicament JSON vÃ lid.',
      Object.assign({}, userConfig, { maxTokens: 400, model: models.modelArquitecte }),
      'arquitectura'
    );
    const parsed = parseJsonRobust(raw);
    if (parsed && typeof parsed.aprovat === 'boolean') {
      const scoreGlobalRaw = Number(parsed.score_global);
      const scoreGlobal = Number.isFinite(scoreGlobalRaw) ? Math.max(0, Math.min(100, scoreGlobalRaw)) : (parsed.aprovat ? 86 : 65);
      const sub = parsed.sub_scores && typeof parsed.sub_scores === 'object' ? parsed.sub_scores : {};
      const sanitizeScore = (v, fb) => {
        const n = Number(v);
        return Number.isFinite(n) ? Math.max(0, Math.min(100, n)) : fb;
      };
      return {
        aprovat: parsed.aprovat,
        critiques: typeof parsed.critiques === 'string' ? parsed.critiques : '',
        score_global: scoreGlobal,
        blocking_issues: Array.isArray(parsed.blocking_issues) ? parsed.blocking_issues.map(s => String(s || '').trim()).filter(Boolean) : [],
        sub_scores: {
          coherencia: sanitizeScore(sub.coherencia, scoreGlobal),
          veu: sanitizeScore(sub.veu, scoreGlobal),
          dialeg: sanitizeScore(sub.dialeg, scoreGlobal),
          prosa: sanitizeScore(sub.prosa, scoreGlobal),
          catala: sanitizeScore(sub.catala, scoreGlobal)
        }
      };
    }
  } catch (err) {
    console.warn("Jutge LLM: error a l'avaluaciÃ³, s'aprova temporalment per evitar bloquejos:", err.message);
  }

  return {
    aprovat: true,
    critiques: '',
    score_global: 82,
    blocking_issues: [],
    sub_scores: { coherencia: 82, veu: 82, dialeg: 82, prosa: 82, catala: 82 }
  };
}

async function generarIValidarEscena(promptEscena, systemPrompt, userConfig, opts = {}) {
  const intentsMaxims = Math.max(1, Number(opts.intentsMaxims) || 2);
  const maxTokens = opts.maxTokens || 3000;
  const targetQualitatRaw = Number(opts.targetQualitat ?? userConfig?.targetQualitat ?? USER_CONFIG?.targetQualitat ?? 85);
  const targetQualitat = Math.max(60, Math.min(98, Number.isFinite(targetQualitatRaw) ? targetQualitatRaw : 85));
  let escenaAprovada = false;
  let textEscenaGenerada = '';
  let intents = 0;
  let promptTreball = String(promptEscena || '');
  let millorText = '';
  let millorScore = -1;

  while (!escenaAprovada && intents < intentsMaxims) {
    intents++;
    textEscenaGenerada = await cridaAPI_GenerarText(promptTreball, systemPrompt, userConfig, maxTokens);

    const veredicte = await avaluarQualitatLiteraria(textEscenaGenerada, userConfig);
    const scoreGlobal = Math.max(0, Math.min(100, Number(veredicte.score_global) || (veredicte.aprovat ? 84 : 64)));
    const teBloquejos = Array.isArray(veredicte.blocking_issues) && veredicte.blocking_issues.length > 0;
    if (scoreGlobal > millorScore) {
      millorScore = scoreGlobal;
      millorText = textEscenaGenerada || millorText;
    }

    if (veredicte.aprovat && scoreGlobal >= targetQualitat && !teBloquejos) {
      escenaAprovada = true;
    } else {
      console.log(`El Jutge Literari demana millora (${scoreGlobal}/${targetQualitat}). Reescrivint...`, veredicte.critiques);
      const bloquejosTxt = teBloquejos ? ` Errors crÃ­tics detectats: ${veredicte.blocking_issues.join(' | ')}.` : '';
      promptTreball += `\n\nCRÃTICA DE L'EDITOR: La versiÃ³ anterior ha obtingut ${scoreGlobal}/100 i l'objectiu Ã©s ${targetQualitat}/100.${bloquejosTxt} Problemes detectats: ${veredicte.critiques || 'massa clixÃ©s o prosa plana'}. Reescriu l'escena solucionant AQUESTS problemes especÃ­fics i elevant la qualitat literÃ ria per sobre de ${targetQualitat}/100.`;
    }
  }

  return escenaAprovada ? (textEscenaGenerada || '') : (millorText || textEscenaGenerada || '');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CompressiÃ³ de MemÃ²ria Narrativa (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function comprimirMemoria(finsCapitol, userConfig) {
  const resumsAComprimir = (ESTAT.llibreRegistre.capitols || [])
    .slice(0, finsCapitol)
    .map(c => c ? c.resum_capitol : null)
    .filter(r => r);
  if (resumsAComprimir.length < 3) return;
  const prompt = `Ets un expert en narrativa. A continuaciÃ³ tens els resums dels primers ${finsCapitol} capÃ­tols d'una novelÂ·la. Crea una sinopsi comprimida en prosa fluÃ¯da de 400-500 paraules que capturi els elements essencials: trames principals, desenvolupament dels personatges, moments clau, i l'estat emocional i narratiu en aquest punt de la novelÂ·la.

RESUMS:
${resumsAComprimir.map((r, i) => `Cap. ${i + 1}: ${r}`).join('\n\n')}

Escriu la sinopsi en prosa contÃ­nua, sense llistes ni tÃ­tols. Ha de ser Ãºtil com a context per escriure els capÃ­tols segÃ¼ents.`;
  const msgs = [{ role: 'user', content: prompt }];
  const res = await callLLMMulti(
    msgs,
    'Ets un expert en sÃ­ntesi narrativa.',
    Object.assign({}, userConfig, { maxTokens: 1200 }),
    'arquitectura'
  );
  // Upsert: eliminar entrades del mateix rang o inferior per evitar acumulaciÃ³ infinita
  ESTAT._memoriasComprimides = (ESTAT._memoriasComprimides || []).filter(m => m.finsCap > finsCapitol);
  ESTAT._memoriasComprimides.push({ finsCap: finsCapitol, text: res || '' });
  ESTAT._memoriasComprimides.sort((a, b) => a.finsCap - b.finsCap);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NKG v4: Narrative Knowledge Graph
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function crearNKG() {
  return {
    personatges: {},
    llocs: {},
    objectes: {},
    fets_canonics: [],
    esdeveniments: [],
    relacions: [],
    timeline_accions: [], // Registre d'Accions Consumades (NKG CHRONOS): "C3E2: Maja entra al laboratori"
    timeline_objectes: [], // Registre de moviment d'objectes: C3E2: [Claus] Personatge A -> Personatge B (motiu)
    timeline_personatges: [], // Registre de canvis de personatge: ubicaciÃ³/roba/estat per escena
    beats_gastats: [], // Registre de beats narratius consumits (anti-repeticiÃ³ dramÃ tica)
    ultima_actualitzacio: { capitol: 0, escena: 0 },
    versio: 1
  };
}

function nkgNormalitzarNom(nom) {
  if (!nom) return '';
  return nom.toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/\s+/g, '_').trim();
}

function nkgRegistrarMovimentObjecte(nkg, objecteNom, fromState, toState, capitol, escena, causa = '') {
  if (!nkg || !objecteNom) return;
  const clauObj = nkgNormalitzarNom(objecteNom);
  if (!clauObj) return;

  const fromPos = fromState && fromState.posseidor ? String(fromState.posseidor) : null;
  const fromUbi = fromState && fromState.ubicacio ? String(fromState.ubicacio) : '';
  const toPos   = toState && toState.posseidor ? String(toState.posseidor) : null;
  const toUbi   = toState && toState.ubicacio ? String(toState.ubicacio) : '';
  const noCanvi = (fromPos || '') === (toPos || '') && (fromUbi || '') === (toUbi || '');
  if (noCanvi) return;

  if (!Array.isArray(nkg.timeline_objectes)) nkg.timeline_objectes = [];
  const linia = `C${capitol}E${escena}: [${objecteNom}] ${fromPos || (fromUbi || '(desconegut)')} -> ${toPos || (toUbi || '(desconegut)')}${causa ? ` (${causa})` : ''}`;
  nkg.timeline_objectes.push(linia);
  if (nkg.timeline_objectes.length > 80) nkg.timeline_objectes = nkg.timeline_objectes.slice(-80);

  if (!nkg.objectes[clauObj]) nkg.objectes[clauObj] = { nom: objecteNom, ubicacio: '', posseidor: null, significat_simbolic: '' };
  const obj = nkg.objectes[clauObj];
  obj.nom = obj.nom || objecteNom;
  obj.posseidor = toPos || null;
  obj.ubicacio = toUbi || '';
  if (!Array.isArray(obj.historial_ubicacions)) obj.historial_ubicacions = [];
  obj.historial_ubicacions.push({ capitol, escena, posseidor: obj.posseidor, ubicacio: obj.ubicacio, causa: causa || '' });
  if (obj.historial_ubicacions.length > 40) obj.historial_ubicacions = obj.historial_ubicacions.slice(-40);
}

function nkgSincronitzarInventariPersonatge(nkg, abans, despres, capitol, escena) {
  if (!nkg || !despres || !despres.nom) return;
  const invAbans = Array.isArray(abans && abans.objectes_inventari) ? abans.objectes_inventari : [];
  const invDespres = Array.isArray(despres.objectes_inventari) ? despres.objectes_inventari : [];
  const nomPers = despres.nom;
  const ubiPers = despres.ubicacio || (abans && abans.ubicacio) || '';

  // Tot objecte que queda a inventari passa a estar en possessiÃ³ del personatge a la seva ubicaciÃ³ actual.
  invDespres.forEach(objNom => {
    const clauObj = nkgNormalitzarNom(objNom);
    const existent = nkg.objectes[clauObj] || { nom: objNom, posseidor: null, ubicacio: '', significat_simbolic: '' };
    nkg.objectes[clauObj] = existent;
    nkgRegistrarMovimentObjecte(
      nkg,
      objNom,
      { posseidor: existent.posseidor, ubicacio: existent.ubicacio },
      { posseidor: nomPers, ubicacio: ubiPers },
      capitol,
      escena,
      'sincronitzaciÃ³ inventari'
    );
  });

  // Objectes que ja no sÃ³n a inventari perÃ² no han estat descartats explÃ­citament: marquem ubicaciÃ³ incerta.
  const setDespres = new Set(invDespres.map(n => nkgNormalitzarNom(n)));
  invAbans.forEach(objNom => {
    const clauObj = nkgNormalitzarNom(objNom);
    if (!clauObj || setDespres.has(clauObj) || !nkg.objectes[clauObj]) return;
    const exObj = nkg.objectes[clauObj];
    if (exObj.posseidor && nkgNormalitzarNom(exObj.posseidor) === nkgNormalitzarNom(nomPers)) {
      nkgRegistrarMovimentObjecte(
        nkg,
        objNom,
        { posseidor: exObj.posseidor, ubicacio: exObj.ubicacio },
        { posseidor: null, ubicacio: exObj.ubicacio || ubiPers || 'ubicaciÃ³ no especificada' },
        capitol,
        escena,
        'objecte surt de lâ€™inventari'
      );
    }
  });
}

function nkgRegistrarCanvisPersonatge(nkg, abans, despres, capitol, escena) {
  if (!nkg || !despres || !despres.nom) return;
  if (!Array.isArray(nkg.timeline_personatges)) nkg.timeline_personatges = [];

  const canvis = [];
  const abansUbi = (abans && abans.ubicacio) ? String(abans.ubicacio) : '';
  const despresUbi = (despres && despres.ubicacio) ? String(despres.ubicacio) : '';
  if ((abansUbi || '') !== (despresUbi || '') && despresUbi) {
    canvis.push(`ubicaciÃ³: ${abansUbi || '(desconeguda)'} â†’ ${despresUbi}`);
  }

  const abansRoba = (abans && abans.indumentaria_actual) ? String(abans.indumentaria_actual) : '';
  const despresRoba = (despres && despres.indumentaria_actual) ? String(despres.indumentaria_actual) : '';
  if ((abansRoba || '') !== (despresRoba || '') && despresRoba) {
    canvis.push(`vestimenta: ${abansRoba || '(sense dades)'} â†’ ${despresRoba}`);
  }

  const abansEmo = (abans && abans.estat_emocional) ? String(abans.estat_emocional) : '';
  const despresEmo = (despres && despres.estat_emocional) ? String(despres.estat_emocional) : '';
  if ((abansEmo || '') !== (despresEmo || '') && despresEmo) {
    canvis.push(`emociÃ³: ${abansEmo || '(desconeguda)'} â†’ ${despresEmo}`);
  }

  if (canvis.length === 0) return;

  const linia = `C${capitol}E${escena}: [${despres.nom}] ${canvis.join(' | ')}`;
  nkg.timeline_personatges.push(linia);
  if (nkg.timeline_personatges.length > 120) nkg.timeline_personatges = nkg.timeline_personatges.slice(-120);

  // Historial estructurat dins del personatge
  if (!Array.isArray(despres.historial_ubicacions)) despres.historial_ubicacions = [];
  if (!Array.isArray(despres.historial_indumentaria)) despres.historial_indumentaria = [];

  if ((abansUbi || '') !== (despresUbi || '') && despresUbi) {
    despres.historial_ubicacions.push({ capitol, escena, ubicacio: despresUbi });
    if (despres.historial_ubicacions.length > 60) despres.historial_ubicacions = despres.historial_ubicacions.slice(-60);
  }
  if ((abansRoba || '') !== (despresRoba || '') && despresRoba) {
    despres.historial_indumentaria.push({ capitol, escena, indumentaria_actual: despresRoba });
    if (despres.historial_indumentaria.length > 60) despres.historial_indumentaria = despres.historial_indumentaria.slice(-60);
  }
}


function serialitzarTretsImmutables(trets) {
  if (!trets || typeof trets !== 'object') return '';
  const edat = trets.edat_aproximada || 'No determinat';
  const genere = trets.genere || 'No determinat';
  const rol = trets.rol_narratiu || 'No determinat';
  const relacio = trets.relacio_protagonista || 'No determinada';
  return `[IDENTITAT FIXA â€” NO MODIFICABLE] ${genere}, ${edat}, ${rol}. RelaciÃ³ amb protagonista: ${relacio}. [FI IDENTITAT FIXA]`;
}

async function extreureTretsImmutablesPersonatge(nom, userConfig = USER_CONFIG) {
  const perfilObj = (ESTAT._perfilsPersonatges && ESTAT._perfilsPersonatges[nom]) ? ESTAT._perfilsPersonatges[nom] : null;
  const perfilTxt = perfilObj ? JSON.stringify(perfilObj, null, 2) : '(No disponible)';
  const elencTxt = Array.isArray(ESTAT._elencPersonatges) && ESTAT._elencPersonatges.length > 0
    ? ESTAT._elencPersonatges.join('\n')
    : '(No disponible)';

  const msgs = [{
    role: 'user',
    content: `Extreu els trets immutables del personatge "${nom}".

ELENC DE PERSONATGES:
${elencTxt}

PERFIL DEL PERSONATGE:
${perfilTxt}

Retorna EXCLUSIVAMENT JSON vÃ lid amb aquesta estructura:
{
  "edat_aproximada": "...",
  "genere": "...",
  "rol_narratiu": "...",
  "relacio_protagonista": "..."
}

No incloguis cap camp addicional.`
  }];

  try {
    const models = getModelConfig(userConfig || USER_CONFIG || {});
    const raw = await callLLMMulti(
      msgs,
      "Ets una analista de personatges. Retorna nomÃ©s JSON.",
      Object.assign({}, userConfig || USER_CONFIG || {}, { maxTokens: 500, model: models.modelArquitecte }),
      'arquitectura'
    );
    const parsed = parseJsonRobust(raw) || {};
    return {
      edat_aproximada: String(parsed.edat_aproximada || 'No determinat').trim(),
      genere: String(parsed.genere || 'No determinat').trim(),
      rol_narratiu: String(parsed.rol_narratiu || 'No determinat').trim(),
      relacio_protagonista: String(parsed.relacio_protagonista || 'No determinada').trim()
    };
  } catch (err) {
    console.warn(`Trets immutables: no s'ha pogut extreure ${nom}:`, err.message);
    return {
      edat_aproximada: 'No determinat',
      genere: 'No determinat',
      rol_narratiu: 'No determinat',
      relacio_protagonista: 'No determinada'
    };
  }
}

async function garantirTretsImmutablesPersonatge(nom, userConfig = USER_CONFIG) {
  if (!ESTAT._nkg || !nom) return null;
  const clau = nkgNormalitzarNom(nom);
  if (!clau) return null;
  if (!ESTAT._nkg.personatges[clau]) {
    ESTAT._nkg.personatges[clau] = {
      nom,
      estat_fisic: '',
      estat_emocional: 'neutre',
      indumentaria_actual: '',
      objectes_inventari: [],
      objectes_descartats: [],
      ubicacio: '',
      objectius: [],
      secrets: [],
      viu: true,
      primera_aparicio: 0,
      trets_immutables: null
    };
  }
  const p = ESTAT._nkg.personatges[clau];
  if (p.trets_immutables && typeof p.trets_immutables === 'object') return p.trets_immutables;
  const trets = await extreureTretsImmutablesPersonatge(nom, userConfig);
  p.trets_immutables = trets;
  return trets;
}

async function inicialitzarTraitsImmutables(userConfig = USER_CONFIG) {
  if (!ESTAT._nkg) return;
  if (ESTAT._traitsImmutablesInicialitzats === true) return;

  const nomsNkg = Object.values(ESTAT._nkg.personatges || {}).map(p => p.nom).filter(Boolean);
  const nomsElenc = Array.isArray(ESTAT._elencPersonatges) ? ESTAT._elencPersonatges.filter(Boolean) : [];
  const noms = [...new Set([...nomsNkg, ...nomsElenc])];

  for (const nom of noms) {
    await garantirTretsImmutablesPersonatge(nom, userConfig);
  }

  ESTAT._traitsImmutablesInicialitzats = true;
}

function nkgQueryPersonatge(nom) {
  const nkg = ESTAT._nkg;
  if (!nkg) return null;
  const clau = nkgNormalitzarNom(nom);
  const pers = nkg.personatges[clau];
  if (!pers) return null;

  const rels = nkg.relacions.filter(r =>
    nkgNormalitzarNom(r.origen) === clau || nkgNormalitzarNom(r.desti) === clau
  );
  const objectes = Object.values(nkg.objectes).filter(o =>
    o.posseidor && nkgNormalitzarNom(o.posseidor) === clau
  );
  const events = nkg.esdeveniments
    .filter(e => e.personatges_involucrats.some(p => nkgNormalitzarNom(p) === clau))
    .slice(-3);

  return { ...pers, relacions: rels, objectes_possedits: objectes, ultims_esdeveniments: events };
}

function nkgQueryEscenaContext(escenaSpec) {
  const nkg = ESTAT._nkg;
  if (!nkg) return '';

  const parts = [];
  const persPresents = escenaSpec.personatges || [];

  if (persPresents.length > 0) {
    parts.push('PERSONATGES EN ESCENA:');
    persPresents.forEach(nom => {
      const p = nkgQueryPersonatge(nom);
      if (p) {
        const identitatFixa = serialitzarTretsImmutables(p.trets_immutables);
        if (identitatFixa) parts.push(`â€¢ ${p.nom}: ${identitatFixa}`);
        let desc = `â€¢ ${p.nom}: estat actual=${p.estat_emocional || 'neutre'}`;
        if (p.estat_fisic) desc += ` | FÃ­sic: ${p.estat_fisic}`;
        if (p.indumentaria_actual) desc += ` | Roba: ${p.indumentaria_actual}`;
        if (p.objectes_inventari && p.objectes_inventari.length > 0) desc += ` | Inventari: ${p.objectes_inventari.join(', ')}`;
        if (p.ubicacio) desc += ` | A: ${p.ubicacio}`;
        if (p.objectius && p.objectius.length > 0) desc += ` | Vol: ${p.objectius[0]}`;
        let passiuEmocional = p.passiu_emocional || '';
        if (!passiuEmocional && Array.isArray(p.traumes) && p.traumes.length > 0) passiuEmocional = p.traumes[0];
        if (!passiuEmocional && Array.isArray(p.pors) && p.pors.length > 0) passiuEmocional = p.pors[0];
        if (!passiuEmocional && Array.isArray(p.deutes) && p.deutes.length > 0) passiuEmocional = p.deutes[0];
        if (!passiuEmocional && ESTAT.bibliaNarrativa && Array.isArray(ESTAT.bibliaNarrativa.fitxes_personatges)) {
          const fitxa = ESTAT.bibliaNarrativa.fitxes_personatges.find(f => nkgNormalitzarNom(f.nom || '') === nkgNormalitzarNom(nom));
          if (fitxa) passiuEmocional = fitxa.secrets || fitxa.estat_actual || '';
        }
        if (passiuEmocional) desc += ` | Passiu emocional latent: ${passiuEmocional}`;
        if (p.secrets && p.secrets.length > 0) desc += ` | Amaga: ${p.secrets[0]}`;
        parts.push(desc);

        if (p.relacions) {
          p.relacions.forEach(r => {
            const altreNom = nkgNormalitzarNom(r.origen) === nkgNormalitzarNom(nom) ? r.desti : r.origen;
            if (persPresents.some(pp => nkgNormalitzarNom(pp) === nkgNormalitzarNom(altreNom))) {
              parts.push(`  â†” ${altreNom}: ${r.tipus} (confianÃ§a:${r.confianca}/10, tensiÃ³:${r.tensio}/10)`);
            }
          });
        }
      }
    });
  }

  if (escenaSpec.lloc) {
    const lloc = nkg.llocs[nkgNormalitzarNom(escenaSpec.lloc)];
    if (lloc) {
      parts.push(`\nLLOC: ${lloc.nom} â€” ${lloc.descripcio_sensorial || ''} (${lloc.ambient || ''})`);
    }
  }

  const objectesRellevants = Object.values(nkg.objectes).filter(o => {
    if (o.ubicacio && escenaSpec.lloc && nkgNormalitzarNom(o.ubicacio) === nkgNormalitzarNom(escenaSpec.lloc)) return true;
    if (o.posseidor && persPresents.some(p => nkgNormalitzarNom(p) === nkgNormalitzarNom(o.posseidor))) return true;
    return false;
  });
  if (objectesRellevants.length > 0) {
    parts.push('\nOBJECTES PRESENTS:');
    objectesRellevants.forEach(o => {
      parts.push(`â€¢ ${o.nom}${o.significat_simbolic ? ' â€” ' + o.significat_simbolic : ''}`);
    });
  }

  if (Array.isArray(nkg.timeline_objectes) && nkg.timeline_objectes.length > 0) {
    parts.push('\nÃšLTIMS MOVIMENTS D\'OBJECTES:');
    nkg.timeline_objectes.slice(-5).forEach(m => parts.push(`â€¢ ${m}`));
  }

  if (Array.isArray(nkg.timeline_personatges) && nkg.timeline_personatges.length > 0) {
    parts.push('\nÃšLTIMS CANVIS DE PERSONATGES (ubicaciÃ³/roba):');
    nkg.timeline_personatges.slice(-8).forEach(m => parts.push(`â€¢ ${m}`));
  }

  // NKG CHRONOS: Ã ncora temporal â€” Ãºltima acciÃ³ registrada al timeline
  if (Array.isArray(nkg.timeline_accions) && nkg.timeline_accions.length > 0) {
    const ultimaAccio = nkg.timeline_accions[nkg.timeline_accions.length - 1];
    parts.push(`\nÃšLTIMA ACCIÃ“ REGISTRADA: ${ultimaAccio}`);
  }

  return parts.join('\n');
}

function nkgDetectarContradiccions(nouFet) {
  const nkg = ESTAT._nkg;
  if (!nkg) return [];
  const contradiccions = [];

  nkg.fets_canonics.forEach(() => {
    if (nouFet.personatge) {
      const nomNorm = nkgNormalitzarNom(nouFet.personatge);
      const pers = nkg.personatges[nomNorm];
      if (pers && !pers.viu && nouFet.descripcio && nouFet.descripcio.toLowerCase().includes(pers.nom.toLowerCase())) {
        contradiccions.push(`âš  ${pers.nom} Ã©s mort perÃ² apareix al nou fet`);
      }
    }
  });

  if (nouFet.tipus === 'ubicaciÃ³' && nouFet.personatge) {
    const nomNorm = nkgNormalitzarNom(nouFet.personatge);
    const pers = nkg.personatges[nomNorm];
    if (pers && pers.ubicacio && nouFet.descripcio !== pers.ubicacio) {
      contradiccions.push(`â„¹ ${pers.nom} estava a "${pers.ubicacio}", nou fet el posa a "${nouFet.descripcio}"`);
    }
  }

  return contradiccions;
}

function obtenirContextCapitolEnCurs(capitol, escenaIdx) {
  const capIdx = capitol - 1;
  if (!ESTAT._escenes_generades || !ESTAT._escenes_generades[capIdx] || escenaIdx <= 0) return '';

  const escenesCap = ESTAT._escenes_generades[capIdx];
  const blocs = [];
  for (let i = 0; i < escenaIdx; i++) {
    const txt = escenesCap[i];
    if (!txt) continue;
    const resumCurt = txt.length > 900 ? txt.slice(-900) : txt;
    blocs.push(`Escena ${i + 1}: ${resumCurt}`);
  }

  if (blocs.length === 0) return '';
  return `
CONTINUÃTAT DEL CAPÃTOL EN CURS (NO REPETIR AQUEST CONTINGUT):
${blocs.join('\n\n')}`;
}


function obtenirUltimesEscenes(n, capitolActual, escenaActual) {
  const fragments = [];

  if (ESTAT._escenes_generades && Object.keys(ESTAT._escenes_generades).length > 0) {
    const totesEscenes = [];
    for (const [capIdx, escenes] of Object.entries(ESTAT._escenes_generades)) {
      for (const [escIdx, text] of Object.entries(escenes)) {
        totesEscenes.push({ cap: parseInt(capIdx), esc: parseInt(escIdx), text: text });
      }
    }
    totesEscenes.sort((a, b) => a.cap !== b.cap ? a.cap - b.cap : a.esc - b.esc);

    const anteriors = totesEscenes.filter(e =>
      e.cap < capitolActual - 1 || (e.cap === capitolActual - 1 && e.esc < escenaActual)
    );
    const ultimes = anteriors.slice(-n);
    ultimes.forEach(e => {
      const text = e.text.length > 1600 ? '...' + e.text.slice(-1600) : e.text;
      fragments.push(text);
    });
  } else if (ESTAT._capitols_generats) {
    const capAnterior = capitolActual - 2;
    if (capAnterior >= 0 && ESTAT._capitols_generats[capAnterior]) {
      const text = ESTAT._capitols_generats[capAnterior];
      const ultims = text.split(/\n\n+/).slice(-3).join('\n\n');
      fragments.push(ultims.length > 1600 ? '...' + ultims.slice(-1600) : ultims);
    }
  }

  return fragments.length > 0 ? fragments.join('\n\n---\n\n') : '';
}

function nkgGenerarContextMinim(escenaSpec) {
  const parts = [];

  // CAPA 1: Estat viu del NKG (~200-300 tokens)
  const contextNKG = nkgQueryEscenaContext(escenaSpec);
  if (contextNKG) parts.push(contextNKG);

  // CAPA 2: omesa â€” els capÃ­tols anteriors ja arriben via buildContextCapitolLegacy (evitar duplicaciÃ³)

  // CAPA 3: Ãšltimes 2 escenes literals (~800 tokens)
  const ultimesEscenes = obtenirUltimesEscenes(2, escenaSpec.capitol, escenaSpec.escena || 1);
  if (ultimesEscenes) {
    parts.push('\nTEXT RECENT (mantÃ© continuÃ¯tat de veu i to):\n' + ultimesEscenes);
  }

  // Escaleta de l'escena actual
  if (escenaSpec.escaleta) {
    parts.push('\nESCALETA D\'AQUESTA ESCENA:');
    if (escenaSpec.escaleta.objectiu_dramatic) parts.push(`Objectiu dramÃ tic: ${escenaSpec.escaleta.objectiu_dramatic}`);
    if (escenaSpec.escaleta && (escenaSpec.escaleta.emocio_entrada || escenaSpec.escaleta.emocio_sortida)) {
      parts.push(`TransiciÃ³ emocional: ${escenaSpec.escaleta.emocio_entrada || '?'} â†’ ${escenaSpec.escaleta.emocio_sortida || '?'}`);
    }
    if (escenaSpec.escaleta.beat_narratiu) parts.push(`Beat narratiu: ${escenaSpec.escaleta.beat_narratiu}`);
  }

  // Prefiguracions actives
  const prefs = getPrefiguracionsActives(escenaSpec.capitol - 1);
  if (prefs.aPlantarAra.length > 0) {
    parts.push('\nPREFIGURACIONS A PLANTAR (subtilment):');
    prefs.aPlantarAra.forEach(p => parts.push(`- ${p.element}`));
  }
  if (prefs.aRecollirAra.length > 0) {
    parts.push('\nPREFIGURACIONS A RECOLLIR:');
    prefs.aRecollirAra.forEach(p => parts.push(`- ${p.element}`));
  }

  return parts.join('\n');
}

function nkgInicialitzar() {
  ESTAT._nkg = crearNKG();
  const nkg = ESTAT._nkg;

  // Poblar personatges des de l'elenc
  if (ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0) {
    ESTAT._personatgesSeleccionats.forEach(nom => {
      const clau = nkgNormalitzarNom(nom);
      if (clau) {
        nkg.personatges[clau] = {
          nom: nom,
          estat_fisic: '',
          estat_emocional: 'neutre',
          indumentaria_actual: '',
          objectes_inventari: [],
          objectes_descartats: [],
          ubicacio: '',
          objectius: [],
          secrets: [],
          viu: true,
          primera_aparicio: 0,
          trets_immutables: null
        };
      }
    });
  }

  // Poblar lloc principal des del worldbuilding
  if (ESTAT.localitzacioTriada) {
    const clau = nkgNormalitzarNom(ESTAT.localitzacioTriada);
    const wbText = ESTAT.worldbuilding
      ? (typeof ESTAT.worldbuilding === 'string' ? ESTAT.worldbuilding : JSON.stringify(ESTAT.worldbuilding))
      : '';
    nkg.llocs[clau] = {
      nom: ESTAT.localitzacioTriada,
      descripcio_sensorial: wbText.substring(0, 200),
      ambient: ''
    };
  }

  // Fet canÃ²nic inicial des de l'arc global
  if (ESTAT._arcGlobal) {
    nkg.fets_canonics.push({
      descripcio: `Arc global: ${ESTAT._arcGlobal.substring(0, 200)}`,
      capitol_origen: 0,
      categoria: 'estructura'
    });
  }

  if (!Array.isArray(nkg.beats_gastats)) nkg.beats_gastats = [];

  // Inicialitzar emmagatzematge d'escenes
  ESTAT._escenes_generades = {};

  console.log('NKG inicialitzat:', Object.keys(nkg.personatges).length, 'personatges,', Object.keys(nkg.llocs).length, 'llocs');
}


function nkgAplicarActualitzacions(dades, capitol, escena) {
  const nkg = ESTAT._nkg;
  if (!nkg) return;

  const personatgesActualitzats = dades.personatges || dades.personatges_actualitzats || [];
  if (personatgesActualitzats.length > 0) {
    personatgesActualitzats.forEach(p => {
      const clau = nkgNormalitzarNom(p.nom);
      if (Object.prototype.hasOwnProperty.call(p, 'trets_immutables')) delete p.trets_immutables;
      const abans = nkg.personatges[clau]
        ? {
          nom: nkg.personatges[clau].nom,
          ubicacio: nkg.personatges[clau].ubicacio,
          objectes_inventari: Array.isArray(nkg.personatges[clau].objectes_inventari) ? [...nkg.personatges[clau].objectes_inventari] : []
        }
        : { nom: p.nom, ubicacio: '', objectes_inventari: [] };
      if (!nkg.personatges[clau]) {
        nkg.personatges[clau] = {
          nom: p.nom,
          estat_fisic: '',
          estat_emocional: p.estat_emocional || '',
          indumentaria_actual: p.indumentaria_actual || '',
          objectes_inventari: Array.isArray(p.objectes_inventari) ? p.objectes_inventari : [],
          objectes_descartats: Array.isArray(p.objectes_descartats) ? p.objectes_descartats : [],
          ubicacio: p.ubicacio || '',
          historial_ubicacions: p.ubicacio ? [{ capitol, escena, ubicacio: p.ubicacio }] : [],
          historial_indumentaria: p.indumentaria_actual ? [{ capitol, escena, indumentaria_actual: p.indumentaria_actual }] : [],
          objectius: p.nous_objectius || [],
          secrets: p.nous_secrets || [],
          viu: p.viu !== undefined ? p.viu : true,
          primera_aparicio: capitol,
          trets_immutables: null
        };
      } else {
        const ex = nkg.personatges[clau];
        if (p.estat_emocional) ex.estat_emocional = p.estat_emocional;
        if (p.estat_fisic) ex.estat_fisic = p.estat_fisic;
        if (p.indumentaria_actual) ex.indumentaria_actual = p.indumentaria_actual;
        if (Array.isArray(p.objectes_inventari)) ex.objectes_inventari = p.objectes_inventari;
        if (Array.isArray(p.objectes_descartats) && p.objectes_descartats.length > 0) {
          if (!Array.isArray(ex.objectes_descartats)) ex.objectes_descartats = [];
          ex.objectes_descartats = ex.objectes_descartats.concat(p.objectes_descartats);
          if (ex.objectes_descartats.length > 20) ex.objectes_descartats = ex.objectes_descartats.slice(-20);
        }
        if (p.ubicacio) ex.ubicacio = p.ubicacio;
        if (p.viu !== undefined) ex.viu = p.viu;
        if (p.nous_objectius) {
          p.nous_objectius.forEach(o => { if (!ex.objectius.includes(o)) ex.objectius.push(o); });
          if (ex.objectius.length > 2) ex.objectius = ex.objectius.slice(-2);
        }
        if (p.nous_secrets) {
          p.nous_secrets.forEach(s => { if (!ex.secrets.includes(s)) ex.secrets.push(s); });
        }
        if (p.te_escena_autonoma) {
          if (!ex.autonomia_escenes) ex.autonomia_escenes = [];
          ex.autonomia_escenes.push(capitol);
        }
      }

      const despres = nkg.personatges[clau];
      nkgSincronitzarInventariPersonatge(nkg, abans, despres, capitol, escena);
      nkgRegistrarCanvisPersonatge(nkg, abans, despres, capitol, escena);

      // Registrar descarts explÃ­cits d'objectes amb ubicaciÃ³ si existeix.
      const descarts = Array.isArray(p.objectes_descartats) ? p.objectes_descartats : [];
      descarts.forEach(d => {
        const objNom = d && d.objecte ? d.objecte : '';
        if (!objNom) return;
        const clauObj = nkgNormalitzarNom(objNom);
        const existent = nkg.objectes[clauObj] || { nom: objNom, posseidor: p.nom || null, ubicacio: despres.ubicacio || '', significat_simbolic: '' };
        nkg.objectes[clauObj] = existent;
        nkgRegistrarMovimentObjecte(
          nkg,
          objNom,
          { posseidor: existent.posseidor, ubicacio: existent.ubicacio },
          { posseidor: null, ubicacio: d.ubicacio || despres.ubicacio || '' },
          capitol,
          escena,
          'objecte descartat'
        );
      });
    });
  }

  if (dades.nous_llocs) {
    dades.nous_llocs.forEach(ll => {
      const clau = nkgNormalitzarNom(ll.nom);
      if (!nkg.llocs[clau]) {
        nkg.llocs[clau] = { nom: ll.nom, descripcio_sensorial: ll.descripcio_sensorial || '', ambient: ll.ambient || '' };
      }
    });
  }

  if (dades.nous_objectes) {
    dades.nous_objectes.forEach(o => {
      const clau = nkgNormalitzarNom(o.nom);
      const existent = nkg.objectes[clau] || { nom: o.nom, ubicacio: '', posseidor: null, significat_simbolic: '' };
      nkg.objectes[clau] = existent;
      nkgRegistrarMovimentObjecte(
        nkg,
        o.nom,
        { posseidor: existent.posseidor, ubicacio: existent.ubicacio },
        { posseidor: o.posseidor || null, ubicacio: o.ubicacio || '' },
        capitol,
        escena,
        'objecte nou o actualitzat'
      );
      if (o.significat_simbolic) existent.significat_simbolic = o.significat_simbolic;
    });
  }

  if (Array.isArray(dades.moviments_objectes) && dades.moviments_objectes.length > 0) {
    dades.moviments_objectes.forEach(m => {
      const objNom = m && m.objecte ? m.objecte : '';
      if (!objNom) return;
      const clauObj = nkgNormalitzarNom(objNom);
      const existent = nkg.objectes[clauObj] || { nom: objNom, ubicacio: '', posseidor: null, significat_simbolic: '' };
      nkg.objectes[clauObj] = existent;
      nkgRegistrarMovimentObjecte(
        nkg,
        objNom,
        { posseidor: m.de_posseidor != null ? m.de_posseidor : existent.posseidor, ubicacio: m.de_ubicacio != null ? m.de_ubicacio : existent.ubicacio },
        { posseidor: m.a_posseidor != null ? m.a_posseidor : existent.posseidor, ubicacio: m.a_ubicacio != null ? m.a_ubicacio : existent.ubicacio },
        capitol,
        escena,
        m.causa || 'moviment explÃ­cit'
      );
    });
  }

  if (dades.canvis_relacions) {
    dades.canvis_relacions.forEach(r => {
      const existentIdx = nkg.relacions.findIndex(rel =>
        (nkgNormalitzarNom(rel.origen) === nkgNormalitzarNom(r.personatge_a) && nkgNormalitzarNom(rel.desti) === nkgNormalitzarNom(r.personatge_b)) ||
        (nkgNormalitzarNom(rel.origen) === nkgNormalitzarNom(r.personatge_b) && nkgNormalitzarNom(rel.desti) === nkgNormalitzarNom(r.personatge_a))
      );
      if (existentIdx >= 0) {
        const rel = nkg.relacions[existentIdx];
        if (r.tipus) rel.tipus = r.tipus;
        if (r.confianca !== undefined) rel.confianca = r.confianca;
        if (r.tensio !== undefined) rel.tensio = r.tensio;
        if (r.nota) {
          if (!rel.historial) rel.historial = [];
          rel.historial.push(`Cap.${capitol}: ${r.nota}`);
          if (rel.historial.length > 4) rel.historial = rel.historial.slice(-4);
        }
      } else {
        nkg.relacions.push({
          origen: r.personatge_a,
          desti: r.personatge_b,
          tipus: r.tipus || 'coneix',
          confianca: r.confianca || 5,
          tensio: r.tensio || 0,
          historial: r.nota ? [`Cap.${capitol}: ${r.nota}`] : []
        });
      }
    });
  }

  if (dades.nous_fets_canonics) {
    dades.nous_fets_canonics.forEach(fc => {
      nkg.fets_canonics.push({ descripcio: fc, capitol_origen: capitol, categoria: 'general' });
    });
    if (nkg.fets_canonics.length > 20) nkg.fets_canonics = nkg.fets_canonics.slice(-20);
  }

  if (dades.resum_esdeveniment) {
    nkg.esdeveniments.push({
      capitol: capitol,
      escena: escena,
      descripcio: dades.resum_esdeveniment,
      personatges_involucrats: personatgesActualitzats.map(p => p.nom),
      consequencies: []
    });
    if (nkg.esdeveniments.length > 30) nkg.esdeveniments = nkg.esdeveniments.slice(-30);
  }

  // NKG CHRONOS: registrar accions consumades per al protocol anti-regressiÃ³
  if (Array.isArray(dades.accions_consumades) && dades.accions_consumades.length > 0) {
    if (!Array.isArray(nkg.timeline_accions)) nkg.timeline_accions = [];
    const novesAccions = dades.accions_consumades
      .filter(a => typeof a === 'string' && a.trim().length > 0)
      .map(a => `C${capitol}E${escena}: ${a.trim()}`);
    nkg.timeline_accions.push(...novesAccions);
    // Mantenim les Ãºltimes 20 accions per no saturar el context
    if (nkg.timeline_accions.length > 20) {
      nkg.timeline_accions = nkg.timeline_accions.slice(-20);
    }
  }

  nkg.ultima_actualitzacio = { capitol, escena };
}


async function nkgActualitzarPostEscena(textEscena, capitol, escena, userConfig) {
  const nkg = ESTAT._nkg;
  if (!nkg) return;

  const persConeguts = Object.values(nkg.personatges).map(p => p.nom).join(', ');
  const estatPersistent = Object.values(nkg.personatges).map(p => {
    const inv = Array.isArray(p.objectes_inventari) && p.objectes_inventari.length > 0 ? p.objectes_inventari.join(', ') : '(buit)';
    const desc = Array.isArray(p.objectes_descartats) && p.objectes_descartats.length > 0
      ? p.objectes_descartats.slice(-3).map(o => `${o.objecte || '?'}@${o.ubicacio || '?'}`).join(' | ')
      : '(cap)';
    return `- ${p.nom}: emociÃ³=${p.estat_emocional || 'neutre'} | roba=${p.indumentaria_actual || '(sense dades)'} | inventari=${inv} | descartats=${desc}`;
  }).join('\n');

  const msgs = [{
    role: 'user',
    content: `Analitza aquest fragment de novelÂ·la i extreu-ne la informaciÃ³ narrativa estructurada.

PERSONATGES CONEGUTS: ${persConeguts || '(cap encara)'}

ESTAT PERSISTENT ABANS D'AQUESTA ESCENA (usa'l per mantenir continuÃ¯tat):
${estatPersistent || '(sense estat persistent previ)'}

IMPORTANT: Per omplir aquest JSON, has de llegir el text de la nova escena i tenir en compte l'inventari i la vestimenta que ja tenien els personatges prÃ¨viament. Si un personatge tenia una 'Pistola' a l'inventari i en aquest capÃ­tol no la fa servir ni la llenÃ§a, la 'Pistola' HA DE CONTINUAR dins del seu array \`objectes_inventari\`. NomÃ©s has de modificar la vestimenta, l'inventari o l'emociÃ³ si els esdeveniments d'aquest capÃ­tol ho justifiquen explÃ­citament (per exemple, si el personatge es canvia de roba, perd un objecte, pateix un accident o rep una mala notÃ­cia que n'alteri l'estat d'Ã nim).

TEXT:
${textEscena.substring(0, 3000)}${textEscena.length > 3000 ? '\n[â€¦text truncatâ€¦]' : ''}

Retorna EXCLUSIVAMENT un JSON vÃ lid amb EXACTAMENT aquests camps:
{
  "personatges": [
    {
      "nom": "Nom del personatge",
      "estat_emocional": "DescripciÃ³ concisa del seu estat d'Ã nim a l'acabar l'escena.",
      "ubicacio": "On Ã©s fÃ­sicament el personatge al final de l'escena (lloc concret).",
      "indumentaria_actual": "QuÃ¨ porta posat i en quin estat es troba (ex: 'Abric negre mullat, camisa arrugada').",
      "objectes_inventari": ["Pistola carregada", "Claus del cotxe", "Carta arrugada"],
      "objectes_descartats": [
        {
          "objecte": "Ganivet",
          "ubicacio": "A terra, sota la taula de la cuina"
        }
      ]
    }
  ],
  "accions_consumades": [
    "ha obert la porta del laboratori",
    "ha disparat la pistola cap al sostre",
    "ha llegit el fitxer secret"
  ],
  "moviments_objectes": [
    {
      "objecte": "Claus del cotxe",
      "de_posseidor": "Maja",
      "de_ubicacio": "PassadÃ­s",
      "a_posseidor": "Nil",
      "a_ubicacio": "PassadÃ­s",
      "causa": "les hi entrega desprÃ©s de la discussiÃ³"
    }
  ]
}

El camp "accions_consumades" ha de contenir 3-5 accions fÃ­siques IRREVERSIBLES que han succeÃ¯t en aquesta escena concreta. Cada acciÃ³ ha d'estar en tercera persona passada i ser prou especÃ­fica per poder-se usar com a restricciÃ³ ("ha creuat el portal", "ha firmat el document", "ha matat el guarda"). Si no n'hi ha prou, posa les que hi hagi. NO inventes accions que no surten al text.

El camp "moviments_objectes" Ã©s opcional perÃ² recomanat: inclou els trasllats clars d'objectes (canvi de posseÃ¯dor o de lloc) detectats al text. Si no n'hi ha, retorna [].`
  }];

  const models = getModelConfig(userConfig);
  try {
    const response = await callLLMMulti(
      msgs,
      'Ets un analista narratiu. Extreu NOMÃ‰S informaciÃ³ explÃ­cita del text, no infereixis. IMPORTANT: Per omplir el JSON, conserva inventari i vestimenta prÃ¨via dels personatges i nomÃ©s canvia aquests camps si el text ho justifica explÃ­citament. Respon EXCLUSIVAMENT amb JSON vÃ lid.',
      Object.assign({}, userConfig, { maxTokens: 2000, model: models.modelDraft, _esDraft: true }),
      'generacio'
    );
    const dades = parseJsonRobust(response);
    if (dades) nkgAplicarActualitzacions(dades, capitol, escena);
    else console.warn("NKG: No s'ha pogut parsejar la resposta d'actualitzaciÃ³");
  } catch (err) {
    console.warn('NKG: Error actualitzant post-escena:', err.message);
  }
}


async function generarResumCompacte(finsCapitol, userConfig) {
  const nkg = ESTAT._nkg;
  if (!nkg) return;

  const eventsResum = nkg.esdeveniments
    .filter(e => e.capitol <= finsCapitol)
    .map(e => `Cap.${e.capitol}: ${e.descripcio}`)
    .join('\n');

  const persResum = Object.values(nkg.personatges)
    .map(p => `${p.nom}: ${p.estat_emocional}, a ${p.ubicacio || '?'}`)
    .join('; ');

  if (!eventsResum && !persResum) return;

  const msgs = [{
    role: 'user',
    content: `Genera un resum narratiu compacte de la novelÂ·la fins al capÃ­tol ${finsCapitol}.

ESDEVENIMENTS FINS ARA:
${eventsResum || '(cap registrat)'}

ESTAT ACTUAL DELS PERSONATGES:
${persResum || '(cap registrat)'}

INSTRUCCIONS:
- MÃ xim 400 paraules (ESTRICTE)
- Escriu en prosa fluÃ¯da, no en llista
- Inclou: trama principal, estat dels personatges clau, tensions obertes, girs importants
- NO incloguis detalls sensorials ni cites de diÃ legs
- El resum ha de permetre entendre on som a la novelÂ·la
- Escriu en catalÃ `
  }];

  const models = getModelConfig(userConfig);
  try {
    const response = await callLLMMulti(
      msgs,
      'Ets un editor literari. Genera resums narratius compactes i precisos.',
      Object.assign({}, userConfig, { maxTokens: 800, model: models.modelArquitecte }),
      'arquitectura'
    );
    ESTAT._resumCompacte = response || '';
    console.log('NKG: Resum compacte actualitzat fins al capÃ­tol', finsCapitol);
  } catch (err) {
    console.warn('NKG: Error generant resum compacte:', err.message);
  }
}

async function escriureEscenaDirecta(capitol, escenaIdx, escenaSpec, contextNKG, userConfig) {
  const systemPrompt = buildSystemPromptCapitol();
  const msgs = [{
    role: 'user',
    content: `Escriu l'escena ${escenaIdx + 1} del capÃ­tol ${capitol}.

${contextNKG}

INSTRUCCIONS:
- ${escenaSpec.paraules_objectiu || 700}-${(escenaSpec.paraules_objectiu || 700) + 200} paraules
- Escriu en catalÃ 
- Mostra, no expliquis`
  }];

  const res = await callLLMWithContinuation(msgs, systemPrompt, Object.assign({}, userConfig, { maxTokens: 6000 }), 'generacio');
  return res || '';
}

async function avaluarEsborranyAmbHistoric(idx, esborrany, userConfig) {
  const capitol = idx + 1;
  const models = getModelConfig(userConfig);
  const contextRevisio = buildContextRevisioArquitecta(idx, esborrany);
  const esborranyTallat = String(esborrany || '').slice(0, 14000);

  const promptFactual = [{
    role: 'user',
    content: `Fes una REVISIÃ“ FACTUAL I DE COHERÃˆNCIA del capÃ­tol ${capitol}. Prioritza continuÃ¯tat dura i contradiccions.

${contextRevisio}

ESBORRANY CAPÃTOL ${capitol}:
${esborranyTallat}

Checklist mÃ­nim (obligatori):
1) Objectes que canvien de mÃ , desapareixen o reapareixen sense causa.
2) Contradiccions canÃ²niques amb fets establerts, regles del mÃ³n o timeline.
3) Motivacions inconsistents (accions sense causa psicolÃ²gica creÃ¯ble).
4) IncoherÃ¨ncia de POV/focalitzaciÃ³ i salts no justificats.
5) Repeticions estructurals innecessÃ ries amb capÃ­tols anteriors.

Retorna EXCLUSIVAMENT JSON vÃ lid amb aquest esquema:
{
  "errors_critics": [
    {
      "id": "C1",
      "tipus": "continuÃ¯tat_objectes|canon|timeline|motivacio|pov",
      "severitat": "critica",
      "fragment": "cita exacta curta del text problemÃ tic",
      "diagnosi": "quÃ¨ falla i per quÃ¨",
      "accio": "canvi concret a aplicar",
      "proposta_reescriptura": "opcional, 1-3 frases"
    }
  ],
  "errors_mitjans": [],
  "millores_estil": [],
  "tests_post_rewrite": ["check verificable 1", "check verificable 2"],
  "resum_risc": "1-3 lÃ­nies"
}`
  }];

  const promptLiterari = [{
    role: 'user',
    content: `Fes una REVISIÃ“ LITERÃ€RIA I DE QUALITAT narrativa del capÃ­tol ${capitol}.

${contextRevisio}

ESBORRANY CAPÃTOL ${capitol}:
${esborranyTallat}

Checklist mÃ­nim (obligatori):
1) Personatges secundaris que sonen genÃ¨rics o intercanviables.
2) DiÃ leg expositiu tipus "As you know, Bob".
3) Show-don't-tell insuficient amb etiquetes emocionals explÃ­cites.
4) Ritme (massa explicaciÃ³, poca escena) i transicions febles.
5) Repeticions lÃ¨xiques/temÃ tiques i redundÃ ncia emocional.

Retorna EXCLUSIVAMENT JSON vÃ lid amb el mateix esquema:
{
  "errors_critics": [],
  "errors_mitjans": [
    {
      "id": "M1",
      "tipus": "veu|dialeg|ritme|redundancia|estil",
      "severitat": "mitjana",
      "fragment": "cita exacta curta",
      "diagnosi": "quÃ¨ grinyola",
      "accio": "canvi concret",
      "proposta_reescriptura": "opcional"
    }
  ],
  "millores_estil": [
    {
      "id": "S1",
      "tipus": "prosa|sensorialitat|to",
      "fragment": "cita exacta curta",
      "accio": "millora concreta"
    }
  ],
  "tests_post_rewrite": ["check verificable 1"],
  "resum_risc": "1-3 lÃ­nies"
}`
  }];

  const [rawFactual, rawLiterari] = await Promise.all([
    callLLMMulti(
      promptFactual,
      'Ets una arquitecta narrativa sÃ¨nior. Detectes contradiccions i obligues canvis especÃ­fics amb evidÃ¨ncia textual.',
      Object.assign({}, userConfig, { maxTokens: 2600, model: models.modelArquitecte }),
      'arquitectura'
    ),
    callLLMMulti(
      promptLiterari,
      'Ets una arquitecta narrativa sÃ¨nior. Prioritzes qualitat dramÃ tica i concreciÃ³ accionable amb evidÃ¨ncia textual.',
      Object.assign({}, userConfig, { maxTokens: 2600, model: models.modelArquitecte }),
      'arquitectura'
    )
  ]);

  const revFactual = normalitzarRevisioArquitecta(rawFactual);
  const revLiteraria = normalitzarRevisioArquitecta(rawLiterari);
  const fusionada = fusionarRevisionsArquitecta(revFactual, revLiteraria);
  return JSON.stringify(fusionada, null, 2);
}

function buildContextRevisioArquitecta(idx, esborrany) {
  const parts = [];
  const contextCapitols = buildContextCapitolsComplets(idx, { maxParaules: 7500 });
  if (contextCapitols) parts.push(contextCapitols);

  const registreCtx = buildRegistreContextLegacy(idx);
  if (registreCtx) parts.push(registreCtx);

  const contextCapitol = buildContextCapitolLegacy(idx);
  if (contextCapitol) parts.push('\nCONTEXT CANÃ’NIC DE CAPÃTOL (per contrast de coherÃ¨ncia):\n' + contextCapitol);

  const nkgCtx = buildNkgContextRevisio(idx, esborrany);
  if (nkgCtx) parts.push('\nNKG (VERITAT FACTUAL ACTUAL):\n' + nkgCtx);

  const repsDetectades = detectarRepeticions();
  if (repsDetectades) {
    const bigrames = (repsDetectades.bigrames || []).slice(0, 8).map(([ng]) => ng);
    const trigrames = (repsDetectades.trigrames || []).slice(0, 8).map(([ng]) => ng);
    if (bigrames.length || trigrames.length) {
      parts.push(`\nREPETICIONS LÃˆXIQUES GLOBALS A VIGILAR:\n- Bigrames: ${bigrames.join(', ') || '(cap)'}\n- Trigrames: ${trigrames.join(', ') || '(cap)'}`);
    }
  }

  const repsTematiques = detectarRepeticionsTematiques();
  if (repsTematiques && repsTematiques.length > 0) {
    parts.push('\nREPETICIONS TEMÃ€TIQUES PREEXISTENTS (no reiterar sense capa nova):\n' +
      repsTematiques.map(r => `- ${r.tema} (caps ${r.capitols.join(', ')})`).join('\n'));
  }

  if (idx > 0 && ESTAT._capitols_generats && ESTAT._capitols_generats[idx - 1]) {
    const ultCap = String(ESTAT._capitols_generats[idx - 1]);
    parts.push(`\nREFERÃˆNCIA RÃ€PIDA DEL CAPÃTOL ANTERIOR (tram final):\n${ultCap.slice(-2400)}`);
  }

  parts.push(`\nESBORRANY A REVISAR (${String(esborrany || '').length} carÃ cters).`);
  return parts.join('\n\n');
}

function buildNkgContextRevisio(idx, esborrany) {
  if (!ESTAT._nkg) return '';
  const cap = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols[idx] : null;
  const personatgesCap = cap && Array.isArray(cap.personatges) ? cap.personatges : [];
  const lloc = cap ? (cap.localitzacio || '') : '';

  const base = nkgGenerarContextMinim({
    capitol: idx + 1,
    escena: 1,
    personatges: personatgesCap,
    lloc,
    escaleta: null
  });

  const timelineRecente = (ESTAT._nkg.timeline_accions || []).slice(-10).join('\n');
  const timelinePersonatges = (ESTAT._nkg.timeline_personatges || []).slice(-15).join('\n');
  const objectesRecents = Object.values(ESTAT._nkg.objectes || {})
    .slice(0, 20)
    .map(o => `- ${o.nom || 'objecte'} | posseidor:${o.posseidor || '-'} | ubicacio:${o.ubicacio || '-'} | estat:${o.estat || '-'}`)
    .join('\n');
  const personatgesRecents = Object.values(ESTAT._nkg.personatges || {})
    .slice(0, 24)
    .map(p => {
      const ultUbi = Array.isArray(p.historial_ubicacions) && p.historial_ubicacions.length > 0
        ? p.historial_ubicacions[p.historial_ubicacions.length - 1]
        : null;
      const ultRoba = Array.isArray(p.historial_indumentaria) && p.historial_indumentaria.length > 0
        ? p.historial_indumentaria[p.historial_indumentaria.length - 1]
        : null;
      return `- ${p.nom || 'personatge'} | ubicacio_actual:${p.ubicacio || '-'}${ultUbi ? ` | darrer_canvi_ubicacio:C${ultUbi.capitol}E${ultUbi.escena}` : ''} | roba_actual:${p.indumentaria_actual || '-'}${ultRoba ? ` | darrer_canvi_roba:C${ultRoba.capitol}E${ultRoba.escena}` : ''}`;
    })
    .join('\n');

  const pistaDraft = String(esborrany || '').slice(0, 1200);
  return `${base}\n\nTIMELINE RECENT:\n${timelineRecente || '(sense accions recents)'}\n\nTIMELINE PERSONATGES (ubicaciÃ³/roba):\n${timelinePersonatges || '(sense canvis recents)'}\n\nOBJECTES (control de continuÃ¯tat):\n${objectesRecents || '(sense objectes indexats)'}\n\nPERSONATGES (control de continuÃ¯tat):\n${personatgesRecents || '(sense personatges indexats)'}\n\nPISTA ESBORRANY (detecciÃ³ de divergÃ¨ncies):\n${pistaDraft}`;
}

function normalitzarRevisioArquitecta(raw) {
  const parsed = parseJsonRobust(raw) || {};
  const out = {
    errors_critics: Array.isArray(parsed.errors_critics) ? parsed.errors_critics : [],
    errors_mitjans: Array.isArray(parsed.errors_mitjans) ? parsed.errors_mitjans : [],
    millores_estil: Array.isArray(parsed.millores_estil) ? parsed.millores_estil : [],
    tests_post_rewrite: Array.isArray(parsed.tests_post_rewrite) ? parsed.tests_post_rewrite : [],
    resum_risc: String(parsed.resum_risc || '').trim()
  };

  const sanejarItem = (it, fallbackSeverity) => ({
    id: String(it?.id || '').trim(),
    tipus: String(it?.tipus || 'general').trim(),
    severitat: String(it?.severitat || fallbackSeverity || 'mitjana').trim(),
    fragment: String(it?.fragment || '').trim(),
    diagnosi: String(it?.diagnosi || '').trim(),
    accio: String(it?.accio || '').trim(),
    proposta_reescriptura: String(it?.proposta_reescriptura || '').trim()
  });

  out.errors_critics = out.errors_critics.map(it => sanejarItem(it, 'critica')).filter(it => it.accio || it.diagnosi || it.fragment);
  out.errors_mitjans = out.errors_mitjans.map(it => sanejarItem(it, 'mitjana')).filter(it => it.accio || it.diagnosi || it.fragment);
  out.millores_estil = out.millores_estil.map(it => sanejarItem(it, 'baixa')).filter(it => it.accio || it.fragment);
  out.tests_post_rewrite = out.tests_post_rewrite.map(t => String(t || '').trim()).filter(Boolean);
  return out;
}

function fusionarRevisionsArquitecta(a, b) {
  const key = it => `${it.tipus}|${it.fragment}|${it.accio}`.toLowerCase();
  const dedupe = arr => {
    const seen = new Set();
    const out = [];
    arr.forEach(it => {
      const k = key(it);
      if (seen.has(k)) return;
      seen.add(k);
      out.push(it);
    });
    return out;
  };

  return {
    errors_critics: dedupe([...(a.errors_critics || []), ...(b.errors_critics || [])]),
    errors_mitjans: dedupe([...(a.errors_mitjans || []), ...(b.errors_mitjans || [])]),
    millores_estil: dedupe([...(a.millores_estil || []), ...(b.millores_estil || [])]),
    tests_post_rewrite: dedupe(
      [...(a.tests_post_rewrite || []), ...(b.tests_post_rewrite || [])].map(t => ({ tipus: 'test', fragment: '', accio: t, severitat: 'baixa', diagnosi: '', proposta_reescriptura: '', id: '' }))
    ).map(it => it.accio),
    resum_risc: [a.resum_risc, b.resum_risc].filter(Boolean).join(' | ')
  };
}

function serialitzarCorreccionsArquitecta(correccionsRaw) {
  const rev = normalitzarRevisioArquitecta(typeof correccionsRaw === 'string' ? correccionsRaw : JSON.stringify(correccionsRaw || {}));
  const lines = [];
  if (rev.errors_critics.length > 0) {
    lines.push('ERRORS CRÃTICS (obligatori resoldre tots):');
    rev.errors_critics.forEach((e, i) => {
      lines.push(`${i + 1}. [${e.tipus}] Fragment: "${e.fragment || '(sense cita)'}"`);
      if (e.diagnosi) lines.push(`   - Diagnosi: ${e.diagnosi}`);
      if (e.accio) lines.push(`   - AcciÃ³: ${e.accio}`);
      if (e.proposta_reescriptura) lines.push(`   - Reescriptura suggerida: ${e.proposta_reescriptura}`);
    });
  }
  if (rev.errors_mitjans.length > 0) {
    lines.push('\nERRORS MITJANS (resoldre si no trenca el flux):');
    rev.errors_mitjans.forEach((e, i) => {
      lines.push(`${i + 1}. [${e.tipus}] Fragment: "${e.fragment || '(sense cita)'}"`);
      if (e.diagnosi) lines.push(`   - Diagnosi: ${e.diagnosi}`);
      if (e.accio) lines.push(`   - AcciÃ³: ${e.accio}`);
    });
  }
  if (rev.millores_estil.length > 0) {
    lines.push('\nMILLORES D\'ESTIL (prioritat baixa):');
    rev.millores_estil.forEach((e, i) => {
      lines.push(`${i + 1}. ${e.accio || e.diagnosi || e.fragment}`);
    });
  }
  if (rev.tests_post_rewrite.length > 0) {
    lines.push('\nTESTS POST-REWRITE (autocheck):');
    rev.tests_post_rewrite.forEach((t, i) => lines.push(`${i + 1}. ${t}`));
  }
  if (rev.resum_risc) lines.push(`\nRESUM DE RISC: ${rev.resum_risc}`);
  return lines.join('\n').trim() || String(correccionsRaw || '');
}

async function validarReescripturaArquitecta(idx, textComplet, correccionsRaw, userConfig) {
  const capitol = idx + 1;
  const models = getModelConfig(userConfig);
  const correccions = serialitzarCorreccionsArquitecta(correccionsRaw);
  const prompt = [{
    role: 'user',
    content: `Verifica si el CAPÃTOL ${capitol} reescrit ha resolt les correccions de l'arquitecta. Sigues estricta i aporta evidÃ¨ncia textual.

CORRECCIONS ORIGINALS:
${correccions.slice(0, 8000)}

TEXT REESCRIT:
${String(textComplet || '').slice(0, 14000)}

Retorna EXCLUSIVAMENT JSON:
{
  "pendent_critic": [{"fragment":"cita","accio":"quÃ¨ falta","motiu":"per quÃ¨"}],
  "pendent_mitja": [{"fragment":"cita","accio":"quÃ¨ falta","motiu":"per quÃ¨"}],
  "noves_alertes": [{"severitat":"critica|mitjana","fragment":"cita","accio":"arreglar"}],
  "veredicte": "ok|retry"
}`
  }];

  const raw = await callLLMMulti(
    prompt,
    'Ets una arquitecta QA de narrativa. NomÃ©s aproves quan no queden errors crÃ­tics i no hi ha regressions.',
    Object.assign({}, userConfig, { maxTokens: 2200, model: models.modelArquitecte }),
    'arquitectura'
  );

  const parsed = parseJsonRobust(raw) || {};
  const pendCritic = Array.isArray(parsed.pendent_critic) ? parsed.pendent_critic : [];
  const pendMitja = Array.isArray(parsed.pendent_mitja) ? parsed.pendent_mitja : [];
  const noves = Array.isArray(parsed.noves_alertes) ? parsed.noves_alertes : [];
  const hasCritic = pendCritic.length > 0 || noves.some(n => String(n?.severitat || '').toLowerCase() === 'critica');
  const hasMedium = pendMitja.length > 0;
  return {
    raw,
    parsed,
    ok: !hasCritic && !hasMedium,
    hasCritic,
    pendents: { pendCritic, pendMitja, noves }
  };
}

async function generarProsaDefinitiva(idx, esborrany, correccions, userConfig) {
  const capitol = idx + 1;
  const cap = ESTAT._estructuraCapitols[idx] || {};
  const contextCapitol = buildContextCapitol(idx);
  const systemPrompt = buildSystemPromptCapitol();

  const msgs = [{
    role: 'user',
    content: `Aquest Ã©s el teu esborrany i aquestes sÃ³n les correccions de l'Arquitecta.

INSTRUCCIÃ“ PRINCIPAL (OBLIGATÃ’RIA):
Utilitza aquest esborrany com a BASE FONAMENTAL. Has de mantenir la seva atmosfera, escenes i arc narratiu intactes.
Aplica les CORRECCIONS de l'Arquitecta ÃšNICAMENT per millorar-lo, arreglar incoherÃ¨ncies o omplir forats,
perÃ² no suprimeixis el que ja Ã©s bo. MantÃ©n el to literari i el ritme pausat quan calgui.

CAPÃTOL ${capitol}: ${cap.titol || ''}

CONTEXT:
${contextCapitol}

ESBORRANY BASE:
${String(esborrany || '').slice(0, 13000)}

CORRECCIONS ARQUITECTA (aplica nomÃ©s les necessÃ ries):
${String(correccions || '').slice(0, 4200)}

CORRECCIONS OBLIGATÃ’RIES:
${serialitzarCorreccionsArquitecta(correccions).slice(0, 7000)}

Retorna nomÃ©s la versiÃ³ final del capÃ­tol, sense metadades ni notes.`
  }];

  const models = getModelConfig(userConfig);
  return await callLLMOneShotPlusCompletion(
    msgs,
    systemPrompt,
    Object.assign({}, userConfig, { maxTokens: 14000, model: models.modelGeneracio }),
    'generacio'
  );
}
function construirMissioCapitol(idx) {
  const cap = (ESTAT._estructuraCapitols && ESTAT._estructuraCapitols[idx]) || {};
  const escaletaCap = (ESTAT._escaletes || []).find(e => e.capitol === idx + 1);
  const totalCaps = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols.length : 0;
  const esUltim = idx >= totalCaps - 1;
  const esAvantFinal = !esUltim && idx >= totalCaps - 2;
  const tensio = (ESTAT._corbaTensio || []).find(t => t.capitol === idx + 1);
  const snapshotAnterior = idx > 0 ? (ESTAT._snapshotsFinals || {})[idx - 1] : null;
  const paraulesObjectiu = (ESTAT._controlLongitud && ESTAT._controlLongitud.objectiu) ? ESTAT._controlLongitud.objectiu : 3500;

  const lines = [];

  // Objectiu dramÃ tic del capÃ­tol
  const objectiu = cap.fil || cap.fil_principal || cap.resum || '';
  if (objectiu) lines.push(`OBJECTIU DRAMÃ€TIC: ${objectiu}`);

  // TransiciÃ³ emocional del protagonista
  if (snapshotAnterior && snapshotAnterior.estat_emocional) {
    lines.push(`ESTAT EMOCIONAL DE PARTIDA: "${snapshotAnterior.estat_emocional}". El protagonista ha de sortir d'aquest capÃ­tol en un estat DIFERENT â€” no cal que millori, perÃ² ha de canviar. Un personatge que entra i surt igual ha perdut el capÃ­tol.`);
  }

  // Escena clau i longitud objectiu
  if (escaletaCap && Array.isArray(escaletaCap.escenes) && escaletaCap.escenes.length > 0) {
    const escenes = escaletaCap.escenes;
    const escenaClau = escenes.find(e => e.beat_narratiu === 'introspecciÃ³' || e.beat_narratiu === 'acciÃ³') || escenes[Math.floor(escenes.length / 2)];
    if (escenaClau && escenaClau.nom) {
      lines.push(`ESCENA CLAU (la que NO pots descuidar): "${escenaClau.nom}" â€” ${escenaClau.funcio_narrativa || ''}. Aquesta escena ha de tenir pes, detall i durada proporcionals.`);
    }
    const paraulesPerEscena = Math.round(paraulesObjectiu / escenes.length);
    lines.push(`LONGITUD: ~${paraulesObjectiu} paraules en ${escenes.length} escenes (~${paraulesPerEscena} paraules per escena). No truncis cap escena: desenvolupa-la fins a la seva resoluciÃ³ natural.`);
  } else {
    lines.push(`LONGITUD: ~${paraulesObjectiu} paraules. Desenvolupa cada escena fins a la seva resoluciÃ³ natural, sense truncar.`);
  }

  // InstrucciÃ³ d'obertura
  lines.push(`PRIMERA FRASE: ComenÃ§a in media res â€” amb acciÃ³, tensiÃ³ o veu que enganxi immediatament. PROHIBIT: descriure el temps atmosfÃ¨ric, narrar el despertar d'un son, o obrir amb una frase genÃ¨rica ("Era un dia...", "El sol sortia..."). La primera frase ha de posar el lector dins l'escena sense avÃ­s.`);

  // InstrucciÃ³ de tancament dinÃ mica
  if (esUltim) {
    lines.push(`TANCAMENT: Ã‰s el capÃ­tol final. DÃ³na tancament emocional i narratiu a tots els fils oberts. L'Ãºltima frase ha de ser una ressonÃ ncia â€” una imatge, un gest, un silenci â€” no una explicaciÃ³. Evita els epÃ­legs explicatius.`);
  } else if (esAvantFinal) {
    lines.push(`TANCAMENT: Ã‰s el capÃ­tol penÃºltim. Acaba amb mÃ xima urgÃ¨ncia narrativa: tot ha d'apuntar al final inevitable. El lector ha de sentir que no pot parar.`);
  } else if (tensio && Number(tensio.nivell) >= 7) {
    lines.push(`TANCAMENT (tensiÃ³ ${tensio.nivell}/10): Acaba en cliffhanger emocional o fÃ­sic. Una decisiÃ³, una revelaciÃ³, una porta que s'obre o es tanca. El lector no pot deixar el llibre aquÃ­.`);
  } else {
    lines.push(`TANCAMENT: Acaba amb un canvi d'estat visible: alguna cosa ha canviat per al protagonista, perÃ² alguna cosa nova s'obre. La darrera imatge ha de tenir ressonÃ ncia visual o emocional.`);
  }

  return lines.join('\n');
}

async function escriureCapitolDirecte(idx, contextCapitol, userConfig) {
  const capitol = idx + 1;
  const cap = ESTAT._estructuraCapitols[idx] || {};
  const systemPrompt = buildSystemPromptCapitol();
  const blocPsico = construirBlocPlaPsicologicPerPrompt(capitol, 0);
  const missio = construirMissioCapitol(idx);
  const msgs = [{
    role: 'user',
    content: `Escriu la versiÃ³ final del capÃ­tol ${capitol} de la novelÂ·la en catalÃ  literari.

TÃTOL: ${cap.titol || ''}

â”â”â” CONTEXT I PLANIFICACIÃ“ â”â”â”
${contextCapitol}
${blocPsico}
â”â”â” MISSIÃ“ ESPECÃFICA D'AQUEST CAPÃTOL (llegeix-la ABANS d'escriure) â”â”â”
${missio}

â”â”â” ESCRIU ARA â”â”â”
Retorna Ãºnicament el text narratiu del capÃ­tol. Cap nota, cap metadada, cap comentari del sistema.`
  }];

  const models = getModelConfig(userConfig);
  return await callLLMOneShotPlusCompletion(
    msgs,
    systemPrompt,
    Object.assign({}, userConfig, { maxTokens: 14000, model: models.modelGeneracio }),
    'generacio'
  );
}

async function extreureDadesRegistreIAvaluarSistema(idx, textCapitol, esRevisioSistema, userConfig) {
  // Context de capÃ­tols previs per a la revisiÃ³ cronolÃ²gica
  let contextRevisio = '';
  if (esRevisioSistema) {
    const resumsAnteriors = (ESTAT.llibreRegistre.capitols || [])
      .slice(0, idx)
      .map((c, i) => {
        if (!c) return null;
        const pers = Array.isArray(c.estat_personatges)
          ? c.estat_personatges.map(p => `${p.nom} (${p.ubicacio || '?'}, ${p.estat_actual || '?'})`).join(', ')
          : (Array.isArray(c.personatges) ? c.personatges.map(p => `${p.nom} (${p.ubicacio || '?'}, ${p.estat || '?'})`).join(', ') : '');
        const fils = Array.isArray(c.fils_oberts) ? c.fils_oberts.slice(0, 3).join(' | ') : '';
        return `Cap.${i + 1}: ${c.resum_capitol || '(sense resum)'} | Personatges: ${pers || 'â€”'} | Fils oberts: ${fils || 'â€”'}`;
      })
      .filter(Boolean)
      .join('\n');

    const timelineNKG = (ESTAT._nkg && Array.isArray(ESTAT._nkg.timeline_accions) && ESTAT._nkg.timeline_accions.length > 0)
      ? '\nTIMELINE NKG (accions recents en ordre cronolÃ²gic):\n- ' + ESTAT._nkg.timeline_accions.slice(-12).join('\n- ')
      : '';

    contextRevisio = `

TASCA B: REVISIÃ“ DE CONSISTÃˆNCIA CRONOLÃ’GICA I COHERÃˆNCIA NARRATIVA
Tens accÃ©s als resums de tots els capÃ­tols escrits fins ara. Analitza el text del CapÃ­tol ${idx + 1} en relaciÃ³ amb la novelÂ·la completa i detecta:

1. CRONOLOGIA: Hi ha salts temporals injustificats? Algun personatge apareix en dos llocs alhora? Hi ha accions que contradiuen la seqÃ¼Ã¨ncia establerta? Algun objecte o fet canvia de posiciÃ³/estat sense causa narrativa?
2. COHERÃˆNCIA D'ARC: Els arcs de personatge progressen de manera consistent o hi ha regressions inexplicades? Es mantenen les motivacions? Es compleixen les conseqÃ¼Ã¨ncies d'accions anteriors?
3. QUALITAT DE COHERÃˆNCIA: Puntua la coherÃ¨ncia global d'aquest punt de la novelÂ·la (1-10) i explica els punts febles principals.
4. MILLORES PROPOSADES: Basant-te exclusivament en les inconsistÃ¨ncies i debilitats detectades (no en preferÃ¨ncies literÃ ries), proposa millores concretes per als capÃ­tols segÃ¼ents.

RESUMS CAPÃTOLS ANTERIORS:
${resumsAnteriors || '(primer checkpoint, sense capÃ­tols previs suficients)'}${timelineNKG}`;
  }

  const msgs = [{
    role: 'user',
    content: `Ets l'Arquitecta del sistema. Garanteixes la integritat del Llibre de Registre (NKG) i la coherÃ¨ncia interna de la novelÂ·la.

TASCA A: ACTUALITZACIÃ“ DE REGISTRE
Extreu del segÃ¼ent capÃ­tol:
1. OBJECTES: Nous objectes introduÃ¯ts, canvis d'estat o de possessiÃ³.
2. PERSONATGES: UbicaciÃ³ exacta, estat actual, i nous fets canÃ²nics confirmats.
3. ESCENES I TRAMES: Resum executiu i progrÃ©s dels fils narratius.
4. CAMP OBLIGATORI: No deixis cap camp buit; si no hi ha dades, posa "Cap detectat" o "Sense canvis".${contextRevisio}

CAPÃTOL ${idx + 1}:
${textCapitol.substring(0, 14000)}

Retorna EXCLUSIVAMENT JSON amb aquesta estructura:
{
  "actualitzacio_nkg": {
    "resum_capitol": "Resum executiu extens de 4-6 frases...",
    "personatges": [{"nom": "...", "ubicacio": "...", "estat": "..."}],
    "objectes": [{"nom": "...", "estat": "...", "posseidor": "..."}],
    "trames": {"fils_actualitzats": ["..."], "nous_fils": ["..."]},
    "riscos_continuitat": ["..."],
    "claus_prompt_seguent": ["...", "..."]
  }${esRevisioSistema ? `,
  "revisio_sistema": {
    "inconsistencies_cronologiques": ["DescripciÃ³ concreta de cada inconsistÃ¨ncia detectada, o 'Cap detectada'"],
    "qualitat_coherencia": {
      "puntuacio": 7,
      "diagnostic": "AvaluaciÃ³ global de la coherÃ¨ncia narrativa fins aquest punt...",
      "punts_febles": ["punt feble 1", "punt feble 2"]
    },
    "millores_proposades": [
      {"capitol_afectat": "cap X o 'generals'", "problema": "...", "proposta": "...", "prioritat": "alta|mitja|baixa"}
    ],
    "alerta_critica": "Breu alerta si hi ha una inconsistÃ¨ncia cronolÃ²gica crÃ­tica que cal corregir immediatament, o buit si tot Ã©s correcte"
  }` : ''}
}`
  }];

  const models = getModelConfig(userConfig);
  const tokensDesitjats = esRevisioSistema ? 3200 : 1800;
  const raw = await callLLMMulti(
    msgs,
    "Ets l'Arquitecta de Dades i Sistemes. Retorna nomÃ©s JSON.",
    Object.assign({}, userConfig, { maxTokens: capsMaxTokens(models.modelArquitecte, tokensDesitjats), model: models.modelArquitecte }),
    'arquitectura'
  );
  const dades = parseJsonRobust(raw) || { actualitzacio_nkg: {} };
  if (esRevisioSistema && dades.revisio_sistema) {
    ESTAT._revisionsCodiSistema = ESTAT._revisionsCodiSistema || [];
    ESTAT._revisionsCodiSistema.push({ capitol: idx + 1, revisio: JSON.stringify(dades.revisio_sistema) });
  }
  return dades;
}

async function generarCapitolNKG(idx, userConfig) {
  const capitol = idx + 1;
  const loaderEl = document.getElementById('loader-11-text');
  const contextCapitol = buildContextCapitol(idx);

  if (loaderEl) loaderEl.textContent = `âœï¸ Escrivint directament el capÃ­tol ${capitol}...`;
  let textComplet = await escriureCapitolDirecte(idx, contextCapitol, userConfig);
  textComplet = netejarTabulacionsInicials(textComplet || '');

  const infoInjectadaEsbos = `CAPÃTOL ${capitol}
CONTEXT CAPÃTOL:
${contextCapitol}
`;
  const infoInjectadaRevisioOpus = `NovelÂ·la fins ara (fragments):
${(ESTAT._capitols_generats || []).slice(0, idx).filter(Boolean).map((t, i) => `--- CAPÃTOL ${i + 1} ---\n${String(t).slice(-1800)}`).join('\n\n') || '(encara no hi ha capÃ­tols previs)'}`;
  const correccionsArquitecta = '';

  if (!textComplet || !textComplet.trim()) {
    throw new Error(`No s'ha pogut generar el capÃ­tol ${capitol} en mode directe.`);
  }

  // NKG s'actualitza explÃ­citament a generarCapitol desprÃ©s del bucle de revisiÃ³
  return { response: textComplet, esborrany: textComplet, correccionsArquitecta, infoInjectadaEsbos, infoInjectadaRevisioOpus };
}

function renderitzarNKG() {
  const nkg = ESTAT._nkg;
  if (!nkg) return '<p style="color:var(--text2)">NKG no inicialitzat</p>';

  let html = '<div>';

  html += `<h4 style="color:var(--accent2);margin-bottom:8px;">ğŸ“‹ Personatges (${Object.keys(nkg.personatges).length})</h4>`;
  Object.values(nkg.personatges).forEach(p => {
    const color = p.viu ? 'var(--success)' : '#dc3545';
    html += `<div style="border-left:3px solid ${color};padding-left:8px;margin:4px 0;font-size:.85rem;">`;
    html += `<strong>${escHtml(p.nom)}</strong>`;
    if (p.estat_emocional) html += ` â€” ${escHtml(p.estat_emocional)}`;
    if (p.ubicacio) html += ` | ğŸ“ ${escHtml(p.ubicacio)}`;
    if (p.objectius && p.objectius.length > 0) html += `<br>ğŸ¯ ${escHtml(p.objectius.join(', '))}`;
    html += '</div>';
  });

  if (nkg.relacions.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:12px 0 8px;">ğŸ”— Relacions (${nkg.relacions.length})</h4>`;
    nkg.relacions.forEach(r => {
      html += `<div style="font-size:.82rem;padding:2px 0;">${escHtml(r.origen)} â†” ${escHtml(r.desti)}: ${escHtml(r.tipus)} (âš¡${r.tensio}/10)</div>`;
    });
  }

  const eventsRecents = nkg.esdeveniments.slice(-5);
  if (eventsRecents.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:12px 0 8px;">ğŸ“… Esdeveniments recents</h4>`;
    eventsRecents.forEach(e => {
      html += `<div style="font-size:.82rem;padding:2px 0;">Cap.${e.capitol}: ${escHtml(e.descripcio)}</div>`;
    });
  }

  html += '</div>';
  return html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DetecciÃ³ de Repeticions (anÃ lisi local, sense LLM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function detectarRepeticions() {
  const capitolsAmbText = ESTAT._capitols_generats.filter(t => t && t.length > 0);
  if (capitolsAmbText.length < 3) return null;

  function getNgrams(text, n) {
    const paraules = text.toLowerCase().replace(/[.,;:!?Â«Â»""''()\[\]]/g, ' ').split(/\s+/).filter(p => p.length > 2);
    const ngrams = {};
    for (let i = 0; i <= paraules.length - n; i++) {
      const ng = paraules.slice(i, i + n).join(' ');
      ngrams[ng] = (ngrams[ng] || 0) + 1;
    }
    return ngrams;
  }

  // Bigrames i trigrames per capÃ­tol
  const bigramesPerCapitol = capitolsAmbText.map(t => getNgrams(t, 2));
  const trigramesPerCapitol = capitolsAmbText.map(t => getNgrams(t, 3));

  // Paraules de stop (comunes en catalÃ /castellÃ /anglÃ¨s)
  const stopWords = new Set(['que', 'del', 'les', 'els', 'una', 'uns', 'unes', 'per', 'amb', 'com', 'tot', 'tots', 'tota', 'totes', 'mÃ©s', 'molt', 'perÃ²', 'quan', 'fins', 'des', 'pel', 'als', 'sense', 'sobre', 'entre', 'cap', 'seu', 'seva', 'seus', 'seves', 'era', 'eren', 'havia', 'havien', 'ser', 'estar', 'han', 'has', 'hem']);

  function filtrarNgrams(ngramsList) {
    // Compta en quants capÃ­tols apareix cada ngram
    const comptador = {};
    ngramsList.forEach(ngrams => {
      Object.keys(ngrams).forEach(ng => {
        const paraules = ng.split(' ');
        // Filtra si totes les paraules sÃ³n stop words
        if (paraules.every(p => stopWords.has(p))) return;
        comptador[ng] = (comptador[ng] || 0) + 1;
      });
    });
    return Object.entries(comptador)
      .filter(([, c]) => c >= 3)
      .sort((a, b) => b[1] - a[1]);
  }

  const bigramesRepetits = filtrarNgrams(bigramesPerCapitol);
  const trigramesRepetits = filtrarNgrams(trigramesPerCapitol);

  if (bigramesRepetits.length === 0 && trigramesRepetits.length === 0) return null;
  return { bigrames: bigramesRepetits, trigrames: trigramesRepetits };
}

function detectarRepeticionsTematiques() {
  const nkg = ESTAT._nkg;
  if (!nkg || !nkg.esdeveniments || nkg.esdeveniments.length < 5) return null;

  // Agrupar esdeveniments per tipus de revelaciÃ³
  const revelacions = nkg.esdeveniments.filter(e =>
    /descobr|revel|adona[r']?.*compte|s'assabent|comprÃ¨n|entÃ©n/i.test(e.descripcio)
  );

  // Detectar revelacions repetides (mateix personatge + mateixa temÃ tica)
  const grups = {};
  revelacions.forEach(r => {
    const personatgesClau = (r.personatges_involucrats || []).sort().join('+');
    const tema = r.descripcio.toLowerCase()
      .replace(/[^a-zA-ZÃ Ã¨Ã©Ã­Ã²Ã³ÃºÃ¼Ã§Ã€ÃˆÃ‰ÃÃ’Ã“ÃšÃœÃ‡\s]/g, '')
      .split(/\s+/).filter(p => p.length > 3).slice(0, 5).join('\n');
    const clau = `${personatgesClau}::${tema}`;
    if (!grups[clau]) grups[clau] = [];
    grups[clau].push(r);
  });

  const repetides = Object.entries(grups)
    .filter(([, rs]) => rs.length >= 2)
    .map(([clau, rs]) => ({
      tema: clau,
      cops: rs.length,
      capitols: rs.map(r => r.capitol)
    }));

  return repetides.length > 0 ? repetides : null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MILLORA 6: VEU SEMILLA â€” Analitzar estil de referÃ¨ncia (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function manualEstilMassaCurt(manual) {
  if (!manual || typeof manual !== 'object') return true;
  const camps = ['longitud_frases', 'estil_dialeg', 'sensorialitat', 'ritme', 'vocabulari', 'punt_de_vista'];
  const presents = camps.filter(c => manual[c] != null && String(manual[c]).trim().length > 20);
  const charsTotals = presents.reduce((acc, c) => acc + String(manual[c]).trim().length, 0);
  return presents.length < 4 || charsTotals < 260;
}

async function analitzarVeuSemilla(textReferencia, userConfig) {
  const promptBase = `Ets un expert en estil literari. Analitza el fragment de text d'un autor de referÃ¨ncia i genera un MANUAL D'ESTIL concret i accionable per a un escriptor.

FRAGMENT DE REFERÃˆNCIA:
${textReferencia.substring(0, 4000)}

IMPORTANT:
- Cada camp textual ha de tenir com a mÃ­nim 2 frases i ser especÃ­fic.
- No retallis idees a mitja frase.
- Evita resumir en una sola lÃ­nia.

Retorna EXCLUSIVAMENT JSON (sense cap altre text) amb el format:
{
  "longitud_frases": "descripciÃ³ concreta (ex: frases curtes 8-12 paraules, entremesclades amb perÃ­odes llargs)",
  "estil_dialeg": "com es construeixen els diÃ legs (ex: acotacions mÃ­nimes, diÃ leg tallat per acciÃ³)",
  "sensorialitat": "quins sentits predominen i com s'usen (ex: tÃ ctil i visual, metÃ fores kinÃ¨stiques)",
  "ritme": "patrÃ³ rÃ­tmic (ex: acceleraciÃ³ a l'acciÃ³ amb frases curtes, pauses reflexives amb subordinades)",
  "vocabulari": "registre i trets lexicals (ex: colÂ·loquial amb arcaismes puntuals, evita adjectius abstractes)",
  "punt_de_vista": "focalitzaciÃ³ i distÃ ncia narrativa",
  "trets_distinctius": ["tret 1", "tret 2", "tret 3"]
}`;

  const prompt = [{ role: 'user', content: promptBase }];
  const models = getModelConfig(userConfig);

  const res = await callLLMMulti(prompt, 'Ets un crÃ­tic literari expert en anÃ lisi estilÃ­stica. Analitza amb precisiÃ³ quirÃºrgica.',
    Object.assign({}, userConfig, { maxTokens: 2500, model: models.modelArquitecte }), 'arquitectura');

  let manual = parseJsonRobust(res) || parseManualEstilFallback(res);
  if (!manualEstilMassaCurt(manual)) return manual;

  const promptRetry = [{
    role: 'user',
    content: promptBase + '\n\nReescriu la resposta amb MÃ‰S DETALL i assegura que tots els camps estiguin complets i no tallats.'
  }];

  const resRetry = await callLLMMulti(promptRetry, 'Ets un crÃ­tic literari expert en anÃ lisi estilÃ­stica. Analitza amb precisiÃ³ quirÃºrgica.',
    Object.assign({}, userConfig, { maxTokens: 2200 }), 'arquitectura');

  manual = parseJsonRobust(resRetry) || parseManualEstilFallback(resRetry);
  return manual;
}

function parseManualEstilFallback(text) {
  if (!text || typeof text !== 'string') return null;

  const clean = text
    .replace(/```(?:json)?/gi, '')
    .replace(/```/g, '')
    .replace(/\r/g, '')
    .trim();

  const manual = {};
  const fieldMap = {
    longitud_frases: ['longitud_frases', 'longitud de frases'],
    estil_dialeg: ['estil_dialeg', 'estil de dialeg', 'estil de diÃ leg', 'dialeg', 'diÃ leg'],
    sensorialitat: ['sensorialitat'],
    ritme: ['ritme'],
    vocabulari: ['vocabulari'],
    punt_de_vista: ['punt_de_vista', 'punt de vista']
  };

  const lines = clean.split('\n').map(l => l.trim()).filter(Boolean);
  for (const line of lines) {
    const normalized = line
      .replace(/^[-*â€¢\d.)\s]+/, '')
      .replace(/^\*\*(.*?)\*\*$/, '$1')
      .trim();

    const m = normalized.match(/^([^:]+):\s*(.+)$/);
    if (!m) continue;

    const rawKey = m[1].trim().replace(/^"|"$/g, '').replace(/^'|'$/g, '');
    const key = rawKey.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').trim();
    const value = m[2].trim().replace(/^"|"$/g, '').replace(/^'|'$/g, '').replace(/,$/, '').trim();
    if (!value) continue;

    for (const [target, aliases] of Object.entries(fieldMap)) {
      if (aliases.includes(key)) {
        manual[target] = value;
        break;
      }
    }
  }

  const trets = [];
  const tretsBlock = clean.match(/(?:trets?_distinctius|trets? distintius)\s*:\s*([\s\S]{0,500})/i);
  if (tretsBlock) {
    const rawTrets = tretsBlock[1].trim();
    const arrayMatch = rawTrets.match(/^\[(.*)\]$/s);
    if (arrayMatch) {
      arrayMatch[1]
        .split(',')
        .map(v => v.replace(/^\s*["']?|["']?\s*$/g, '').trim())
        .filter(Boolean)
        .slice(0, 6)
        .forEach(t => trets.push(t));
    } else {
      const tretsLines = rawTrets
        .split('\n')
        .map(l => l.replace(/^[-*â€¢\d.)\s]+/, '').replace(/[",]$/g, '').trim())
        .filter(Boolean)
        .slice(0, 6);
      trets.push(...tretsLines);
    }
  }

  if (trets.length === 0) {
    lines
      .filter(l => /^[-*â€¢]/.test(l) || /^\d+[.)]/.test(l))
      .map(l => l.replace(/^[-*â€¢\d.)\s]+/, '').trim())
      .filter(Boolean)
      .slice(0, 3)
      .forEach(t => trets.push(t));
  }

  if (trets.length > 0) manual.trets_distinctius = trets;

  return Object.keys(manual).length > 0 ? manual : null;
}

async function processarVeuSemilla() {
  const textarea = document.getElementById('veuSemilla');
  const resultDiv = document.getElementById('veuSemilla-result');
  if (!textarea || !resultDiv) return;

  const text = textarea.value.trim();
  if (text.length < 200) {
    resultDiv.style.color = 'var(--danger)';
    resultDiv.textContent = 'âš ï¸ Enganxa almenys 200 carÃ cters de text de referÃ¨ncia.';
    return;
  }

  resultDiv.style.color = 'var(--text2)';
  resultDiv.textContent = 'ğŸ”µ Opus analitzant estil de referÃ¨nciaâ€¦';

  try {
    const manual = await analitzarVeuSemilla(text, USER_CONFIG);
    if (manual) {
      ESTAT._veuSemilla = text;
      ESTAT._manualEstil = manual;

      const CAMPS_CONEGUTS = ['trets_distinctius', 'longitud_frases', 'estil_dialeg', 'sensorialitat', 'ritme', 'vocabulari', 'punt_de_vista'];

      let tretsHtml = '';
      if (manual.trets_distinctius != null) {
        const trets = Array.isArray(manual.trets_distinctius)
          ? manual.trets_distinctius
          : String(manual.trets_distinctius).split(/[,Â·\n]+/).map(t => t.trim()).filter(Boolean);
        if (trets.length > 0) {
          tretsHtml = `<div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:12px">${trets.map(t => `<span style="background:var(--surface2);border:1px solid var(--border);border-radius:16px;padding:2px 10px;font-size:.82rem;color:var(--text2)">${escHtml(t)}</span>`).join('\n')}</div>`;
        }
      }

      const ETIQUETES = { longitud_frases: 'Longitud de frases', estil_dialeg: 'Estil de diÃ leg', sensorialitat: 'Sensorialitat', ritme: 'Ritme', vocabulari: 'Vocabulari', punt_de_vista: 'Punt de vista' };
      let campsHtml = '';
      for (const [clau, etiqueta] of Object.entries(ETIQUETES)) {
        if (manual[clau] != null) {
          campsHtml += `<div style="margin-bottom:8px"><span style="font-size:.78rem;font-weight:600;color:var(--accent2);text-transform:uppercase;letter-spacing:.04em">${etiqueta}</span><div style="font-size:.88rem;color:var(--text);margin-top:2px">${escHtml(String(manual[clau]))}</div></div>`;
        }
      }

      const extresHtml = Object.keys(manual)
        .filter(k => !CAMPS_CONEGUTS.includes(k) && manual[k] != null)
        .map(k => `<div style="margin-bottom:8px"><span style="font-size:.78rem;font-weight:600;color:var(--accent2);text-transform:uppercase;letter-spacing:.04em">${escHtml(k)}</span><div style="font-size:.88rem;color:var(--text);margin-top:2px">${escHtml(String(manual[k]))}</div></div>`)
        .join('\n');

      resultDiv.style.color = '';
      resultDiv.innerHTML = `<div style="background:var(--surface2);border:1px solid var(--border);border-radius:10px;padding:16px;margin-top:8px"><div style="font-weight:600;color:var(--success);margin-bottom:10px">âœ… Manual d'estil generat</div>${tretsHtml}${campsHtml}${extresHtml}</div>`;
    } else {
      resultDiv.style.color = 'var(--danger)';
      resultDiv.textContent = 'âš ï¸ No s\'ha pogut analitzar l\'estil. Intenta-ho de nou.';
    }
  } catch (err) {
    resultDiv.style.color = 'var(--danger)';
    resultDiv.textContent = `âš ï¸ Error: ${err.message}`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MILLORA 8: DETECTOR DE VEU PLANA â€” anÃ lisi programÃ tica (0 LLM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function detectarTellingEmocional(text) {
  if (!text) return [];
  const patrons = [
    /\b(sentia|se sentia|estava|es trobava|es va sentir|va sentir-se)\s+(trist[ae]?|content[ae]?|enfadat|enfadada|nerviÃ³s|nerviosa|espantat|espantada|feliÃ§|angoixat|angoixada|frustrat|frustrada|confÃ³s|confosa|avergonyit|avergonyida|culpable|satisfe[ct]|alleujat|alleujada|eufÃ²ric|eufÃ²rica|deprimit|deprimida|sol[ae]?|abandonat|abandonada)/gi,
    /\b(una (ona|onada|rampa|punxada|fiblada) de? (por|rÃ bia|tristesa|angoixa|pÃ nic|alegria|culpa|vergonya))/gi,
    /\b(el cor li|el cor se li|li va fer|li feia)\s+(un salt|un nus|mal|por|pena)/gi,
    /\b(amb (por|rÃ bia|tristesa|alegria|vergonya|culpa))\b/gi
  ];
  const matches = [];
  patrons.forEach(p => {
    let m;
    while ((m = p.exec(text)) !== null) {
      matches.push(m[0]);
    }
  });
  return matches;
}

function analitzarVarianciaVeu(text) {
  if (!text || text.length < 50) return null;

  // Segmentar en frases
  const frases = text.split(/[.!?]+/).map(f => f.trim()).filter(f => f.length > 5);
  if (frases.length < 3) return null;

  const longituds = frases.map(f => f.split(/\s+/).length);
  const mitja = longituds.reduce((a, b) => a + b, 0) / longituds.length;
  const variancia = longituds.reduce((a, b) => a + Math.pow(b - mitja, 2), 0) / longituds.length;
  const cv = mitja > 0 ? Math.sqrt(variancia) / mitja : 0;

  // Frases consecutives de longitud similar (diferÃ¨ncia <= 2 paraules)
  let consecutivesSimilars = 0;
  for (let i = 1; i < longituds.length; i++) {
    if (Math.abs(longituds[i] - longituds[i - 1]) <= 2) consecutivesSimilars++;
  }
  const ratioConsecutives = longituds.length > 1 ? consecutivesSimilars / (longituds.length - 1) : 0;

  // Starts repetitius (primers 2 mots)
  const starts = frases.map(f => f.split(/\s+/).slice(0, 2).join('\n').toLowerCase());
  const startCounts = {};
  starts.forEach(s => { startCounts[s] = (startCounts[s] || 0) + 1; });
  const startsRepetits = Object.values(startCounts).filter(c => c >= 2).reduce((a, b) => a + b, 0);
  const ratioStarts = frases.length > 0 ? startsRepetits / frases.length : 0;

  // Adverbis en -ment
  const adverbis = (text.match(/\b\w+ment\b/gi) || []).length;
  const adverbisPerfrase = frases.length > 0 ? adverbis / frases.length : 0;

  // Comparacions explÃ­cites "com un/a"
  const comparacions_com = (text.match(/\bcom un[a]?\b/gi) || []).length;

  // ProporciÃ³ de diÃ leg (per senyals tipogrÃ fics)
  const dialogLines = (text.match(/[Â«Â»"â€”]/g) || []).length;
  const ratioDialeg = text.length > 0 ? dialogLines / (text.length / 100) : 0;

  // Densitat adjectival: adjectius / substantius estimats
  const sufixosAdjectiu = /\b\w+(?:osa|Ã³s|ant|ent|ble|iva|iu|al|ar|ic|ica|oses|osos|als|ars|ics|iques|ants|ents|bles|ives|ius)\b/gi;
  const sufixosVerb = /\b\w+(?:ar|er|ir|re|ava|aven|ava|ia|ies|Ã |aran|eran|iran|at|ada|ats|ades|ant)\b/gi;
  const paraules = text.split(/\s+/).filter(p => p.length > 3);
  const nombreAdjectius = (text.match(sufixosAdjectiu) || []).length;
  const nombreVerbs = (text.match(sufixosVerb) || []).length;
  const nombreSubstantius = Math.max(1, paraules.length - nombreAdjectius - nombreVerbs);
  const densitat_adjectival = nombreAdjectius / nombreSubstantius;

  // Densitat sensorial: paraules sensorials per cada 100 paraules
  const PARAULES_SENSORIALS = new Set([
    'olor','pudor','fragÃ ncia','aroma','efluvi','pestilÃ¨ncia','flaire','perfum','tufor',
    'llum','foscor','claror','penombra','resplendor','enlluernament','fosca','lluminositat',
    'fred','calor','humitat','sequedat','escalfor','glaÃ§or','tibiesa','ardor',
    'soroll','silenci','xiulet','murmuri','cruixit','estrÃ¨pit','renou','brunzit','retruny',
    'textura','aspre','suau','rugÃ³s','llis','viscÃ³s','tou','dur','sedÃ³s','escabrÃ³s',
    'dolÃ§','amarg','Ã cid','salat','acre','salitre','gasoil','metÃ lÂ·lic','picant',
    'vibraciÃ³','pols','boira','vapor','brisa','teranyina','freda','cÃ lida','pesada',
    'tÃ¨nue','brillant','opac','mat','translÃºcid','fosc','clar'
  ]);
  const totalParaules = Math.max(1, text.split(/\s+/).filter(p => p.length > 1).length);
  const nombreSensorials = text.toLowerCase().split(/\s+/).filter(p =>
    PARAULES_SENSORIALS.has(p.replace(/[.,;:!?Â«Â»""''()\[\]]/g, ''))
  ).length;
  const densitat_sensorial = (nombreSensorials / totalParaules) * 100;

  return { cv, mitja, ratioConsecutives, ratioStarts, adverbisPerfrase, adverbisTotal: adverbis, comparacions_com, ratioDialeg, nFrases: frases.length, densitat_adjectival, densitat_sensorial };
}

function generarInstruccionsVariancia(metriques) {
  if (!metriques) return '';

  const instruccions = [];

  if (metriques.cv < 0.25) {
    instruccions.push('alterna frases curtes (3-5 paraules) amb frases llargues (15+ paraules) per trencar la monotonia rÃ­tmica');
  }
  if (metriques.ratioConsecutives > 0.6) {
    instruccions.push('evita que 3 frases seguides tinguin la mateixa longitud; trenca el paralÂ·lelisme');
  }
  if (metriques.ratioStarts > 0.3) {
    instruccions.push('varia els inicis de frase (no repeteixis el mateix subjecte o connector)');
  }
  if (metriques.adverbisPerfrase > 0.5) {
    instruccions.push('substitueix adverbis en -ment per verbs mÃ©s precisos');
  }
  if (metriques.cv < 0.2 && metriques.ratioConsecutives > 0.65 && metriques.ratioDialeg < 0.7) {
    instruccions.push("to quirÃºrgic detectat: trenca la monotonia amb diÃ legs fragmentats, interrupcions i un parÃ graf d'introspecciÃ³ emocional pura que mostri vulnerabilitat sense explicar-la");
  }
  if (metriques.densitat_adjectival !== undefined && metriques.densitat_adjectival > 0.6) {
    instruccions.push("PODA D'ADJECTIUS: MÃ xim 1 adjectiu per substantiu. Substitueix adjectius per verbs precisos o accions. Exemple: en lloc de 'la porta pesada i rovellada' â†’ 'la porta va grinyolar'");
  }
  if (metriques.densitat_sensorial !== undefined && metriques.densitat_sensorial > 3) {
    instruccions.push("SATURACIÃ“ SENSORIAL: Aquesta escena ja tÃ© prou detalls sensorials. Prioritza acciÃ³ i diÃ leg. Reserva les descripcions sensorials per a 1-2 moments clau de l'escena, no per a cada frase");
  }

  return instruccions.join('; ');
}

function renderitzarAnalisiVeu(capitolIdx) {
  const text = ESTAT._capitols_generats ? ESTAT._capitols_generats[capitolIdx] : null;
  if (!text) return '';

  const m = analitzarVarianciaVeu(text);
  if (!m) return '';

  const cvPct = Math.round(m.cv * 100);
  const cvColor = m.cv >= 0.35 ? 'var(--success)' : m.cv >= 0.2 ? '#ffc107' : 'var(--danger)';
  const consec = Math.round(m.ratioConsecutives * 100);
  const adv = m.adverbisPerfrase.toFixed(2);

  return `<div style="margin-top:12px;padding:10px;background:var(--surface2);border-radius:8px;font-size:.82rem;">
  <strong style="color:var(--accent2);">ğŸ“Š AnÃ lisi de Veu â€” CapÃ­tol ${capitolIdx + 1}</strong>
  <div style="margin-top:6px;display:grid;grid-template-columns:1fr 1fr;gap:4px;">
    <span>VariÃ ncia de ritme (CV):</span><span style="color:${cvColor};font-weight:600">${cvPct}% ${m.cv >= 0.35 ? 'âœ“' : m.cv >= 0.2 ? '~' : 'âš '}</span>
    <span>Frases consecutives similars:</span><span style="color:${consec > 60 ? 'var(--danger)' : 'var(--text)'}">${consec}%</span>
    <span>Adverbis per frase:</span><span style="color:${m.adverbisPerfrase > 0.5 ? 'var(--danger)' : 'var(--text)'}">${adv}</span>
    <span>Longitud mitja:</span><span>${Math.round(m.mitja)} paraules</span>
  </div>
</div>`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MILLORA 7: MICRO-REESCRIPTURA PER BLOCS (Opus + Sonnet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function microReescripturaBlocOpus(blocIniciIdx, blocFinalIdx, userConfig) {
  const capitolsBloc = [];
  for (let i = blocIniciIdx; i <= blocFinalIdx; i++) {
    if (ESTAT._capitols_generats && ESTAT._capitols_generats[i]) {
      capitolsBloc.push({ idx: i, text: ESTAT._capitols_generats[i] });
    }
  }
  if (capitolsBloc.length === 0) return;

  // PAS 1: Opus diagnostica els passatges febles
  const textsPerDiagnosi = capitolsBloc.map(c =>
    `=== CapÃ­tol ${c.idx + 1} ===\n${c.text.substring(0, 2000)}`
  ).join('\n\n');

  const promptDiagnosi = [{
    role: 'user',
    content: `Analitza els capÃ­tols i identifica exactament 3-5 passatges febles (telling, clixÃ©s, prosa plana, diÃ leg genÃ¨ric) o ERRORS DE FORMAT (com ara solapament de diÃ legs de diferents personatges en un mateix parÃ graf).

${textsPerDiagnosi}

Retorna EXCLUSIVAMENT JSON:
{
  "passatges": [
    {
      "capitol_idx": 0,
      "text_original": "fragment exacte de mÃ xim 150 paraules",
      "problema": "descripciÃ³ breu del problema",
      "instruccio": "instrucciÃ³ especÃ­fica per reescriure'l"
    }
  ]
}`
  }];

  const models = getModelConfig(userConfig);
  let diagnosi;
  try {
    const res = await callLLMMulti(promptDiagnosi,
      'Ets un editor literari professional. Sigues precÃ­s i exigent. Respon EXCLUSIVAMENT amb JSON vÃ lid.',
      Object.assign({}, userConfig, { maxTokens: 1500, model: models.modelArquitecte }), 'arquitectura');
    diagnosi = parseJsonRobust(res);
  } catch (err) {
    console.warn('Micro-reescriptura: diagnosi fallida:', err.message);
    return;
  }

  if (!diagnosi || !diagnosi.passatges || diagnosi.passatges.length === 0) return;

  // PAS 2: Sonnet reescriu cada passatge identificat
  let goldenActualitzat = false;
  for (const passatge of diagnosi.passatges) {
    const capIdx = passatge.capitol_idx;
    if (!ESTAT._capitols_generats || !ESTAT._capitols_generats[capIdx] || !passatge.text_original) continue;

    const promptReescriptura = [{
      role: 'user',
      content: `Reescriu aquest passatge aplicant la instrucciÃ³. MantÃ©n la mateixa longitud aproximada i la continuÃ¯tat narrativa.

PASSATGE ORIGINAL:
${passatge.text_original}

PROBLEMA: ${passatge.problema}
INSTRUCCIÃ“: ${passatge.instruccio}

Retorna NOMÃ‰S el text reescrit, sense cap explicaciÃ³ ni metadades.`
    }];

    try {
      const reescrit = await callLLMMulti(promptReescriptura,
        'Ets un escriptor literari expert en revisiÃ³ de prosa. Reescriu amb precisiÃ³ quirÃºrgica.',
        Object.assign({}, userConfig, { maxTokens: 1500, model: models.modelGeneracio }), 'generacio');

      if (reescrit && reescrit.length > 50) {
        const capActual = ESTAT._capitols_generats[capIdx];
        const textOrigNorm = passatge.text_original.substring(0, 100);
        if (capActual.includes(textOrigNorm)) {
          ESTAT._capitols_generats[capIdx] = capActual.replace(passatge.text_original, reescrit);
        }

        // Actualitzar golden passage si el reescrit tÃ© la longitud adequada
        if (!goldenActualitzat) {
          const nParaules = reescrit.split(/\s+/).length;
          if (nParaules >= 150 && nParaules <= 250) {
            if (ESTAT._goldenPassageCapitol < 0 || capIdx >= ESTAT._goldenPassageCapitol) {
              ESTAT._goldenPassage = reescrit.substring(0, 1200);
              ESTAT._goldenPassageCapitol = capIdx;
              goldenActualitzat = true;
            }
          }
        }
      }
    } catch (err) {
      console.warn(`Micro-reescriptura: error al passatge del capÃ­tol ${capIdx}:`, err.message);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALCULADORA DE COST I QUALITAT â€” v5.1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function calcularEstimacioNovella() {
  const models = getModelConfig();
  const numCaps = ESTAT._nombreCapitols || 12;
  const escenesMitjana = 6.5;
  const totalEscenes = Math.round(numCaps * escenesMitjana);

  const regDraft = MODEL_REGISTRY[models.modelDraft];
  const regGen   = MODEL_REGISTRY[models.modelGeneracio];
  const regArq   = MODEL_REGISTRY[models.modelArquitecte];
  if (!regDraft || !regGen || !regArq) return null;

  // â”€â”€â”€ COST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const factor = numCaps / 12;
  const tD = ROLS_MODEL.draft.tokens_estimats;
  const tG = ROLS_MODEL.generacio.tokens_estimats;
  const tA = ROLS_MODEL.arquitecte.tokens_estimats;

  const costDraft = (tD.input * factor * regDraft.input_per_m / 1000000) +
                    (tD.output * factor * regDraft.output_per_m / 1000000);
  const costGen   = (tG.input * factor * regGen.input_per_m / 1000000) +
                    (tG.output * factor * regGen.output_per_m / 1000000);
  const costArq   = (tA.input * factor * regArq.input_per_m / 1000000) +
                    (tA.output * factor * regArq.output_per_m / 1000000);
  const costTotal = costDraft + costGen + costArq;

  // â”€â”€â”€ QUALITAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const totalTok = (tD.input + tD.output) + (tG.input + tG.output) + (tA.input + tA.output);
  const pesDraft = (tD.input + tD.output) / totalTok;
  const pesGen   = (tG.input + tG.output) / totalTok;
  const pesArq   = (tA.input + tA.output) / totalTok;

  const qDraft = regDraft.qualitat[ROLS_MODEL.draft.clau_qualitat];
  const qGen   = regGen.qualitat[ROLS_MODEL.generacio.clau_qualitat];
  const qArq   = regArq.qualitat[ROLS_MODEL.arquitecte.clau_qualitat];

  const qGlobal = Math.round(
    qDraft * pesDraft * 0.7 +
    qGen   * pesGen   * 1.4 +
    qArq   * pesArq   * 0.9
  );

  let penalitzacioCatala = 0;
  if (regGen.proveidor !== 'anthropic')   penalitzacioCatala += 5;
  if (regDraft.proveidor !== 'anthropic') penalitzacioCatala += 2;
  if (regArq.proveidor !== 'anthropic')   penalitzacioCatala += 3;

  const qualitatFinal = Math.max(40, qGlobal - penalitzacioCatala);
  const estrelles = qualitatFinal >= 85 ? 5 : qualitatFinal >= 78 ? 4 :
                    qualitatFinal >= 70 ? 3 : qualitatFinal >= 60 ? 2 : 1;
  const ratioQP = qualitatFinal / (costTotal || 0.01);
  const etiquetaRatio = ratioQP > 25 ? 'ğŸ† Excepcional' : ratioQP > 18 ? 'âœ… Molt bo' :
                        ratioQP > 12 ? 'ğŸ‘ Bo' : ratioQP > 8 ? 'âš ï¸ Car' : 'ğŸ’¸ Molt car';

  return {
    modelDraft: regDraft.nomCurt, modelGeneracio: regGen.nomCurt, modelArquitecte: regArq.nomCurt,
    costDraft: costDraft.toFixed(2), costGeneracio: costGen.toFixed(2),
    costArquitecte: costArq.toFixed(2), costTotal: costTotal.toFixed(2),
    qualitatDraft: qDraft, qualitatGeneracio: qGen, qualitatArquitecte: qArq,
    qualitatGlobal: qualitatFinal, penalitzacioCatala, estrelles, etiquetaRatio,
    capitols: numCaps, escenes: totalEscenes, paraulesEstimades: totalEscenes * 530,
    avisos: generarAvisos(models, regDraft, regGen, regArq)
  };
}

function generarAvisos(models, regDraft, regGen, regArq) {
  const avisos = [];
  if (regGen.proveidor !== 'anthropic')
    avisos.push(`âš ï¸ ${regGen.nomCurt} genera prosa en catalÃ  menys natural que els models Claude.`);
  if (regArq.proveidor !== 'anthropic')
    avisos.push(`â„¹ï¸ ${regArq.nomCurt} pot interpretar pitjor instruccions en catalÃ  als prompts d'arquitectura.`);
  if (regDraft.context_max < 200000)
    avisos.push(`âš ï¸ ${regDraft.nomCurt} tÃ© context limitat (${Math.round(regDraft.context_max/1000)}K). Pot afectar escenes amb molt context NKG.`);
  if (regDraft.input_per_m > regGen.input_per_m)
    avisos.push(`ğŸ’¡ El model de draft (${regDraft.nomCurt}) Ã©s mÃ©s car que el de generaciÃ³ (${regGen.nomCurt}). Considera intercanviar-los.`);
  if (regGen.qualitat.prosa < 70)
    avisos.push(`âš ï¸ ${regGen.nomCurt} tÃ© qualitat de prosa limitada (${regGen.qualitat.prosa}/100). La novelÂ·la necessitarÃ  mÃ©s ediciÃ³ humana.`);
  const proveidors = new Set([regDraft.proveidor, regGen.proveidor, regArq.proveidor]);
  if (proveidors.size > 1)
    avisos.push(`â„¹ï¸ CombinaciÃ³ multi-proveÃ¯dor (${[...proveidors].join(', ')}). Assegura't de tenir claus API per a tots.`);
  return avisos;
}

// Backward-compatible alias (cridat des de la fase d'estructura)
function estimarCostNovella() { return calcularEstimacioNovella(); }
function mostrarEstimacioCost() {
  const est = calcularEstimacioNovella();
  if (!est) return '';
  const veuLine = '';
  return `ğŸ“Š ${est.capitols} capÃ­tols Â· ~${est.escenes} escenes Â· ~${est.paraulesEstimades.toLocaleString()} paraules\nğŸ’° $${est.costTotal} ${est.etiquetaRatio} Â· Qualitat: ${est.qualitatGlobal}/100 ${'â˜…'.repeat(est.estrelles)}${'â˜†'.repeat(5-est.estrelles)}\n   Draft: $${est.costDraft} Â· GeneraciÃ³: $${est.costGeneracio} Â· Arquitectura: $${est.costArquitecte}`;
}

// â”€â”€ UI: Funcions del panell de models â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function poblarSelectorsModels() {
  const selectors = {
    'selectModelDraft': 'draft',
    'selectModelGen':   'generacio',
    'selectModelArq':   'arquitecte'
  };
  Object.entries(selectors).forEach(([selectId, rol]) => {
    const select = document.getElementById(selectId);
    if (!select) return;
    select.innerHTML = '';
    Object.entries(MODEL_REGISTRY).forEach(([modelId, info]) => {
      const qualitat = info.qualitat[ROLS_MODEL[rol].clau_qualitat];
      const option = document.createElement('option');
      option.value = modelId;
      option.textContent = `${info.nomCurt} â€” $${info.input_per_m}/$${info.output_per_m}/M â€” Q:${qualitat}`;
      select.appendChild(option);
    });
  });
  const models = getModelConfig();
  const selDraft = document.getElementById('selectModelDraft');
  const selGen   = document.getElementById('selectModelGen');
  const selArq   = document.getElementById('selectModelArq');
  if (selDraft) selDraft.value = models.modelDraft;
  if (selGen)   selGen.value   = models.modelGeneracio;
  if (selArq)   selArq.value   = models.modelArquitecte;
  actualitzarEstimacio();
}

function actualitzarEstimacio() {
  const est = calcularEstimacioNovella();
  if (!est) return;

  const qDraftEl = document.getElementById('qualitatDraft');
  const qGenEl   = document.getElementById('qualitatGen');
  const qArqEl   = document.getElementById('qualitatArq');
  if (qDraftEl) qDraftEl.innerHTML = renderBarraQualitat(est.qualitatDraft, '$' + est.costDraft);
  if (qGenEl)   qGenEl.innerHTML   = renderBarraQualitat(est.qualitatGeneracio, '$' + est.costGeneracio);
  if (qArqEl)   qArqEl.innerHTML   = renderBarraQualitat(est.qualitatArquitecte, '$' + est.costArquitecte);

  const panell = document.getElementById('panellEstimacio');
  if (panell) {
    const estrellesHTML = 'â˜…'.repeat(est.estrelles) + 'â˜†'.repeat(5 - est.estrelles);
    panell.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;">
        <div><strong style="font-size:1.3em;">$${est.costTotal}</strong><span style="color:#666;margin-left:8px;">${est.etiquetaRatio}</span></div>
        <div><span style="color:#f5a623;font-size:1.2em;">${estrellesHTML}</span><span style="margin-left:6px;">Qualitat: ${est.qualitatGlobal}/100</span></div>
      </div>
      <div style="margin-top:8px;color:#666;font-size:0.85em;">
        ${est.capitols} capÃ­tols Â· ~${est.escenes} escenes Â· ~${est.paraulesEstimades.toLocaleString()} paraules${est.penalitzacioCatala > 0 ? ` Â· <span style="color:#e67e22;">-${est.penalitzacioCatala}pts catalÃ </span>` : ''}
      </div>
      <div style="margin-top:6px;font-size:0.8em;color:#888;">
        Draft: $${est.costDraft} Â· GeneraciÃ³: $${est.costGeneracio} Â· Arquitectura: $${est.costArquitecte}
      </div>`;
  }

  const panellAvisos = document.getElementById('panellAvisos');
  if (panellAvisos) {
    panellAvisos.innerHTML = est.avisos.length > 0
      ? est.avisos.map(a => `<div style="padding:4px 0;border-bottom:1px solid #eee;">${a}</div>`).join('\n')
      : '';
  }

  // Actualitzar tambÃ© el div de l'estructura (si Ã©s visible)
  const costEl = document.getElementById('estimacio-cost');
  if (costEl && costEl.textContent) costEl.textContent = mostrarEstimacioCost();
}

function renderBarraQualitat(qualitat, cost) {
  const color = qualitat >= 85 ? '#28a745' : qualitat >= 75 ? '#5cb85c' :
                qualitat >= 65 ? '#f0ad4e' : '#d9534f';
  const ample = Math.min(100, qualitat);
  return `<div style="display:flex;align-items:center;gap:6px;"><div style="flex:1;background:#e9ecef;border-radius:4px;height:8px;overflow:hidden;"><div style="width:${ample}%;background:${color};height:100%;border-radius:4px;"></div></div><span style="font-size:0.8em;min-width:30px;">${qualitat}</span><span style="font-size:0.75em;color:#999;">${cost}</span></div>`;
}

function guardarClausAPI() {
  const anthropic = document.getElementById('anthropicApiKey')?.value?.trim();
  const gemini    = document.getElementById('geminiApiKey')?.value?.trim();
  const openai    = document.getElementById('openaiApiKey')?.value?.trim();
  if (anthropic) ESTAT._anthropicApiKey = anthropic;
  if (gemini)    ESTAT._geminiApiKey    = gemini;
  if (openai)    ESTAT._openaiApiKey    = openai;
  actualitzarModelsDisponibles();
}

function actualitzarModelsDisponibles() {
  const teAnthropic = !!(ESTAT._anthropicApiKey || (USER_CONFIG && USER_CONFIG.provider === 'anthropic' && USER_CONFIG.apiKey));
  const teGemini    = !!(ESTAT._geminiApiKey || (USER_CONFIG && (USER_CONFIG.provider === 'gemini' || USER_CONFIG.provider === 'google') && USER_CONFIG.apiKey));
  const teOpenai    = !!(ESTAT._openaiApiKey || (USER_CONFIG && USER_CONFIG.provider === 'openai' && USER_CONFIG.apiKey));

  document.querySelectorAll('#panellModels select option').forEach(option => {
    const model = MODEL_REGISTRY[option.value];
    if (!model) return;
    const disponible =
      (model.proveidor === 'anthropic' && teAnthropic) ||
      (model.proveidor === 'google'    && teGemini) ||
      (model.proveidor === 'openai'    && teOpenai);
    option.disabled = !disponible;
    if (!disponible && !option.textContent.includes('(sense clau)')) {
      option.textContent += ' (sense clau)';
    } else if (disponible) {
      option.textContent = option.textContent.replace(' (sense clau)', '');
    }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MODE MANUSCRIT INTEGRAT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let manuscritCapitolActiu = 0;
let manuscritRangSeleccionat = null;

// Capturar la selecciÃ³ de text abans que es perdi en fer clic a l'input
document.addEventListener('selectionchange', () => {
  const sel = window.getSelection();
  const editor = document.getElementById('manuscrit-editor');
  if (sel.rangeCount > 0 && editor && editor.contains(sel.anchorNode)) {
    manuscritRangSeleccionat = sel.getRangeAt(0);
  }
});

function obrirManuscrit() {
  const sidebar = document.getElementById('manuscrit-sidebar');
  if (!ESTAT._capitols_generats || ESTAT._capitols_generats.filter(Boolean).length === 0) {
    toast("No hi ha capÃ­tols generats encara.");
    return;
  }

  let htmlSidebar = '';
  ESTAT._capitols_generats.forEach((cap, i) => {
    if (!cap) return;
    htmlSidebar += `<button class="btn btn-ghost" style="text-align:left; padding:8px; font-size:.85rem; border:1px solid transparent; ${i === manuscritCapitolActiu ? 'background:var(--surface2); color:var(--accent2); font-weight:600;' : ''}" id="btn-manu-cap-${i}" onclick="carregarCapitolManuscrit(${i})">CapÃ­tol ${i + 1}</button>`;
  });
  sidebar.innerHTML = htmlSidebar;

  carregarCapitolManuscrit(manuscritCapitolActiu || 0);
  document.getElementById('modal-manuscrit').classList.remove('hidden');
}

function tancarManuscrit() {
  guardarManuscritActual();
  document.getElementById('modal-manuscrit').classList.add('hidden');
  renderLlistaCapitols(); // Refresca la UI per si hi ha hagut canvis
}

function carregarCapitolManuscrit(idx) {
  if (manuscritCapitolActiu !== idx) guardarManuscritActual();
  manuscritCapitolActiu = idx;
  const editor = document.getElementById('manuscrit-editor');
  const text = ESTAT._capitols_generats[idx] || '';

  // Converteix els salts de lÃ­nia a parÃ grafs per a ediciÃ³ correcta
  editor.innerHTML = text.split(/\n\n+/).filter(p => p.trim().length > 0).map(p => `<p>${escHtml(p.trim())}</p>`).join('\n');

  // Actualitza sidebar UI
  const sidebar = document.getElementById('manuscrit-sidebar');
  Array.from(sidebar.children).forEach((btn, i) => {
    if (i === idx) {
      btn.style.background = 'var(--surface2)';
      btn.style.color = 'var(--accent2)';
      btn.style.fontWeight = '600';
    } else {
      btn.style.background = 'transparent';
      btn.style.color = 'var(--text2)';
      btn.style.fontWeight = 'normal';
    }
  });
}

function guardarManuscritActual() {
  const editor = document.getElementById('manuscrit-editor');
  if (!editor || ESTAT._capitols_generats.length === 0) return;

  // Recupera el text (respectant parÃ grafs HTML)
  let nouText = '';
  const pars = editor.querySelectorAll('p, div');
  if (pars.length > 0) {
    nouText = Array.from(pars).map(p => p.textContent.trim()).filter(t => t).join('\n\n');
  } else {
    nouText = editor.innerText.trim();
  }

  if (nouText) ESTAT._capitols_generats[manuscritCapitolActiu] = netejarTabulacionsInicials(nouText);
}

async function reescriureSeleccioManuscrit(event) {
  const instruccio = document.getElementById('manuscrit-instruccio').value.trim();

  if (!manuscritRangSeleccionat || manuscritRangSeleccionat.toString().trim() === '') {
    toast("Primer subratlla el text que vols reescriure dins l'editor.");
    return;
  }
  if (!instruccio) {
    toast("Escriu com vols que l'IA millori el text.");
    return;
  }

  const textSeleccionat = manuscritRangSeleccionat.toString().trim();
  const btn = event.target;
  const txtOriginalBtn = btn.textContent;
  btn.textContent = 'â³ ...';
  btn.disabled = true;

  try {
    const prompt = `Reescriu Ãºnicament aquest fragment literari seguint ESTRICTAMENT aquesta instrucciÃ³: "${instruccio}".

FRAGMENT ORIGINAL:
"${textSeleccionat}"

Retorna NOMÃ‰S el text reescrit, en prosa fluÃ¯da, sense cometes afegides ni explicacions.`;
    const msgs = [{ role: 'user', content: prompt }];
    const models = getModelConfig(USER_CONFIG);

    const reescrit = await callLLMMulti(
      msgs,
      'Ets un editor literari ajudant a millorar un manuscrit. Retorna nomÃ©s el text net en catalÃ .',
      Object.assign({}, USER_CONFIG, { maxTokens: 1000, model: models.modelGeneracio }),
      'generacio'
    );

    if (reescrit && reescrit.trim()) {
      // SubstituÃ¯m el text al rang guardat
      manuscritRangSeleccionat.deleteContents();
      manuscritRangSeleccionat.insertNode(document.createTextNode(reescrit.trim()));

      guardarManuscritActual();
      toast("âœ¨ Fragment reescrit!");
      document.getElementById('manuscrit-instruccio').value = '';
      manuscritRangSeleccionat = null; // Reset
    }
  } catch (err) {
    toast("Error de l'IA: " + err.message);
  } finally {
    btn.textContent = txtOriginalBtn;
    btn.disabled = false;
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INFORME POST-MORTEM (AVALUACIÃ“ META)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarInformePostMortem() {
  const wrap = document.getElementById('post-mortem-wrap');
  const content = document.getElementById('post-mortem-content');
  const btn = document.querySelector('button[onclick="generarInformePostMortem()"]');

  if (!ESTAT._capitols_generats || ESTAT._capitols_generats.length === 0) {
    toast("No hi ha cap novelÂ·la generada per avaluar.");
    return;
  }

  wrap.classList.remove('hidden');
  content.innerHTML = `<span style="color:var(--text2);">â³ Opus estÃ  analitzant l'estructura i la qualitat de l'obra per generar l'informe tÃ¨cnic. AixÃ² pot trigar un minut...</span>`;
  btn.disabled = true;

  // Recopilem una mostra representativa per no saturar el context:
  // L'estructura, els personatges, el capÃ­tol 1 i l'Ãºltim capÃ­tol.
  const numCaps = ESTAT._capitols_generats.length;
  const cap1 = ESTAT._capitols_generats[0] || '';
  const capFinal = ESTAT._capitols_generats[numCaps - 1] || '';

  const dadesAnalisi = `
TÃTOL: ${ESTAT.titol_novella || 'Sense tÃ­tol'}
ESTRUCTURA: ${JSON.stringify(ESTAT._estructuraCapitols)}
LLISTA PERSONATGES: ${ESTAT._llistaProtagonistes ? ESTAT._llistaProtagonistes.join(', ') : 'N/A'}
-- MOSTRA CAPÃTOL 1 --
${cap1.substring(0, 1500)}...
-- MOSTRA CAPÃTOL FINAL --
${capFinal.substring(0, 1500)}...
`;

  const prompt = `Ets el Model Arquitecte (Claude Opus), el cervell darrere d'aquesta aplicaciÃ³ generadora de novelÂ·les.
Acabes de finalitzar la generaciÃ³ d'una novelÂ·la. AquÃ­ tens les dades estructurals i mostres del primer i Ãºltim capÃ­tol:

${dadesAnalisi}

La teva tasca Ã©s fer un INFORME POST-MORTEM META adreÃ§at al desenvolupador de l'aplicaciÃ³. No vull que reescriguis la novelÂ·la. Vull que avaluÃ¯s el *sistema*.
Format de la teva resposta (en catalÃ  i amb format Markdown net):

1. **DiagnÃ²stic Literari:** QuÃ¨ ha funcionat bÃ© en la histÃ²ria i quins defectes tÃ­pics de l'IA has notat (ex: personatges plans, pÃ¨rdua de ritme, clixÃ©s al final)?
2. **DiagnÃ²stic TÃ¨cnic:** Basat en el resultat, on creus que els algorismes de l'aplicaciÃ³ (el "Narrative Knowledge Graph", la corba de tensiÃ³, els prompts d'estil de veu) han fallat o s'han quedat curts?
3. **Propostes de Codi:** DÃ³na 2 o 3 consells concrets de com el desenvolupador podria canviar el codi de l'aplicaciÃ³ o els *prompts* de sistema per solucionar aquests defectes i millorar les futures generacions.

Sigues crÃ­tic, directe i molt tÃ¨cnic.`;

  try {
    const models = getModelConfig(USER_CONFIG);
    const msgs = [{ role: 'user', content: prompt }];
    const res = await callLLMMulti(
      msgs,
      'Ets un Arquitecte de Software i Editor Literari SÃ¨nior.',
      Object.assign({}, USER_CONFIG, { maxTokens: 1500, model: models.modelArquitecte }),
      'arquitectura'
    );

    if (typeof efecteEscripturaHTML === 'function') {
      const htmlConvertit = res.replace(/\n\n/g, '<br><br>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      efecteEscripturaHTML('post-mortem-content', htmlConvertit, 5);
    } else {
      content.innerText = res;
    }
    toast('âœ… Informe Post-Mortem generat!');
  } catch (err) {
    content.innerHTML = `<span style="color:var(--error);">Error en generar l'informe: ${err.message}</span>`;
  } finally {
    btn.disabled = false;
  }
}

// â”€â”€ InicialitzaciÃ³ del selector de models en carregar la pÃ gina â”€â”€
document.addEventListener('DOMContentLoaded', function() {
  // Aplicar preset econÃ²mic per defecte i poblar selectors
  aplicarPreset('economic');
  actualitzarConfigProvider();
  if (typeof poblarSelectorsModels === 'function') poblarSelectorsModels();
  if (typeof guardarClausAPI === 'function') guardarClausAPI();

  // Comprovar si hi ha algun projecte guardat a localStorage
  comprovarProjecteGuardat();
});

</script>
</body>
</html>
