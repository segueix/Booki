<!DOCTYPE html>
<html lang="ca">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Conte IA</title>
<style>
  :root {
    --bg:       #0f0f13;
    --surface:  #1a1a24;
    --surface2: #22222f;
    --border:   #2e2e42;
    --accent:   #7c6af7;
    --accent2:  #a78bfa;
    --text:     #e8e8f0;
    --text2:    #9898b0;
    --success:  #4ade80;
    --warning:  #fbbf24;
    --radius:   12px;
    --font:     'Segoe UI', system-ui, sans-serif;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--font);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 24px 16px 60px;
  }

  /* â”€â”€ Header â”€â”€ */
  header {
    width: 100%;
    max-width: 860px;
    text-align: center;
    margin-bottom: 32px;
  }
  header h1 {
    font-size: 2rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 6px;
  }
  header p { color: var(--text2); font-size: .95rem; }

  /* â”€â”€ Progress bar â”€â”€ */
  #progress-wrap {
    width: 100%;
    max-width: 860px;
    margin-bottom: 28px;
  }
  .progress-steps {
    display: flex;
    gap: 6px;
    align-items: center;
    overflow-x: auto;
    padding-bottom: 4px;
  }
  .step-pill {
    flex-shrink: 0;
    padding: 5px 14px;
    border-radius: 99px;
    font-size: .75rem;
    font-weight: 600;
    background: var(--surface2);
    color: var(--text2);
    border: 1px solid var(--border);
    transition: all .3s;
  }
  .step-pill.done   { background: #2a2a3d; color: var(--accent2); border-color: var(--accent); }
  .step-pill.active { background: var(--accent); color: #fff; border-color: var(--accent); }
  .step-arrow { color: var(--border); font-size: .8rem; flex-shrink: 0; }

  /* â”€â”€ Card â”€â”€ */
  .card {
    width: 100%;
    max-width: 860px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 28px;
    margin-bottom: 20px;
  }
  .card h2 {
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 18px;
    color: var(--accent2);
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .card h2 .icon { font-size: 1.4rem; }

  /* â”€â”€ Select â”€â”€ */
  select {
    width: 100%;
    padding: 12px 16px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-size: 1rem;
    font-family: var(--font);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8'%3E%3Cpath fill='%239898b0' d='M6 8L0 0h12z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 16px center;
    padding-right: 40px;
  }
  select:focus { outline: none; border-color: var(--accent); }

  input[type=text],
  input[type=password] {
    width: 100%;
    padding: 12px 16px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-size: .95rem;
    font-family: var(--font);
  }
  input[type=text]:focus,
  input[type=password]:focus { outline: none; border-color: var(--accent); }

  .field-label {
    display: block;
    font-size: .85rem;
    color: var(--text2);
    margin: 14px 0 8px;
  }

  /* â”€â”€ Botons â”€â”€ */
  .btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 11px 24px;
    border-radius: 8px;
    font-size: .95rem;
    font-weight: 600;
    cursor: pointer;
    border: none;
    transition: all .2s;
    font-family: var(--font);
  }
  .btn-primary   { background: var(--accent); color: #fff; }
  .btn-primary:hover { background: #6b5be0; transform: translateY(-1px); }
  .btn-secondary { background: var(--surface2); color: var(--text); border: 1px solid var(--border); }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent2); }
  .btn-ghost { background: transparent; color: var(--text2); border: 1px solid var(--border); }
  .btn-ghost:hover { color: var(--text); border-color: var(--text2); }
  .btn:disabled { opacity: .4; cursor: not-allowed; transform: none !important; }
  .btn-row { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 20px; }

  /* â”€â”€ Pills de selecciÃ³ (estil narratiu) â”€â”€ */
  .opts-row {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 4px;
  }
  .opt-pill {
    flex: 1;
    min-width: 130px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 2px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    text-align: center;
    font-size: .88rem;
    font-weight: 600;
    transition: all .2s;
    line-height: 1.4;
    user-select: none;
  }
  .opt-pill small {
    display: block;
    font-weight: 400;
    color: var(--text2);
    font-size: .75rem;
    margin-top: 4px;
  }
  .opt-pill:hover   { border-color: var(--accent); }
  .opt-pill.chosen  { border-color: var(--accent); background: #1e1b38; color: var(--accent2); }
  .opt-pill.chosen small { color: var(--accent2); }

  /* â”€â”€ Llista de premisses â”€â”€ */
  .premise-list { display: flex; flex-direction: column; gap: 10px; }
  .premise-item {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 2px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    transition: all .2s;
  }
  .premise-item:hover  { border-color: var(--accent); }
  .premise-item.chosen { border-color: var(--accent); background: #1e1b38; }
  .premise-item input[type=radio] { margin-top: 2px; accent-color: var(--accent); flex-shrink: 0; }
  .premise-item label { cursor: pointer; line-height: 1.5; font-size: .95rem; }

  /* â”€â”€ Badge Recomanat â”€â”€ */
  .badge-recomanat {
    display: inline-block;
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    color: #fff;
    font-size: .68rem;
    font-weight: 700;
    padding: 2px 9px;
    border-radius: 99px;
    text-transform: uppercase;
    letter-spacing: .07em;
    margin-right: 8px;
    vertical-align: middle;
    flex-shrink: 0;
  }

  /* â”€â”€ Loader â”€â”€ */
  .loader-wrap {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    padding: 32px 0;
    color: var(--text2);
    font-size: .9rem;
  }
  .loader-wrap.visible { display: flex; }
  .spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin .8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* â”€â”€ Toast â”€â”€ */
  #toast {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%) translateY(80px);
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 12px 24px;
    border-radius: 99px;
    font-size: .9rem;
    transition: transform .3s;
    z-index: 9999;
    pointer-events: none;
  }
  #toast.show { transform: translateX(-50%) translateY(0); }

  /* â”€â”€ Reader del conte â”€â”€ */
  .conte-reader {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 40px 48px;
    font-family: 'Georgia', 'Times New Roman', serif;
    font-size: 1.05rem;
    line-height: 1.9;
    color: var(--text);
    max-height: 72vh;
    overflow-y: auto;
  }
  .conte-reader p {
    margin-bottom: 1.1em;
    text-indent: 1.8em;
  }
  .conte-reader p:first-child { text-indent: 0; }
  @media (max-width: 600px) {
    .conte-reader { padding: 24px 20px; font-size: .97rem; }
  }
  .conte-wordcount {
    font-size: .78rem;
    color: var(--text2);
    margin-top: 10px;
    text-align: right;
  }

  /* â”€â”€ Millora â”€â”€ */
  .millora-row {
    display: flex;
    gap: 10px;
    margin-top: 14px;
  }
  .millora-row input {
    flex: 1;
    padding: 10px 14px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-size: .9rem;
    font-family: var(--font);
  }
  .millora-row input:focus { outline: none; border-color: var(--accent); }
  .millora-row input::placeholder { color: var(--text2); }

  /* â”€â”€ Export â”€â”€ */
  .export-link {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    color: var(--accent2);
    text-decoration: none;
    font-size: .9rem;
    font-weight: 600;
    padding: 8px 16px;
    border: 1px solid var(--accent);
    border-radius: 8px;
    transition: all .2s;
  }
  .export-link:hover { background: #1e1b38; }

  /* â”€â”€ Worldbuilding multi-select â”€â”€ */
  .world-item {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 2px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    transition: all .2s;
  }
  .world-item:hover  { border-color: var(--accent); }
  .world-item.chosen { border-color: var(--accent); background: #1e1b38; }
  .world-item input[type=checkbox] { margin-top: 3px; accent-color: var(--accent); flex-shrink: 0; width: 16px; height: 16px; cursor: pointer; }
  .world-item label { cursor: pointer; line-height: 1.5; font-size: .95rem; }

  /* â”€â”€ Resultat worldbuilding â”€â”€ */
  .worldbuilding-result {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 28px 32px;
    font-size: .95rem;
    line-height: 1.85;
    color: var(--text);
  }
  .worldbuilding-result .world-bloc {
    margin-bottom: 22px;
  }
  .worldbuilding-result .world-bloc:last-child {
    margin-bottom: 0;
  }
  .worldbuilding-result .world-bloc-titol {
    color: var(--accent2);
    font-weight: 700;
    font-size: 1rem;
    margin-bottom: 6px;
  }
  .worldbuilding-result .world-bloc-desc {
    color: var(--text);
    padding-left: 12px;
    border-left: 2px solid var(--border);
  }

  /* â”€â”€ Estils de parla (fase 9) â”€â”€ */
  .veu-result {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  .veu-card {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 22px 26px;
  }
  .veu-card-nom {
    color: var(--accent2);
    font-weight: 700;
    font-size: 1.05rem;
    margin-bottom: 14px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border);
  }
  .veu-card-camps {
    display: flex;
    flex-direction: column;
    gap: 10px;
    font-size: .92rem;
    line-height: 1.6;
  }
  .veu-camp-label {
    color: var(--text2);
    font-size: .75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .07em;
    margin-bottom: 3px;
  }
  .veu-camp-val {
    color: var(--text);
    padding-left: 10px;
    border-left: 2px solid var(--border);
  }
  .veu-exemple {
    margin-top: 4px;
    padding: 10px 16px;
    background: var(--surface);
    border-radius: 8px;
    font-family: 'Georgia', serif;
    font-style: italic;
    color: var(--accent2);
    font-size: .95rem;
    line-height: 1.65;
    border-left: 3px solid var(--accent);
  }

  /* â”€â”€ SecciÃ³ amagada â”€â”€ */
  .hidden { display: none !important; }

  /* â”€â”€ Badges de model (Sonnet / Opus) â”€â”€ */
  .badge-model {
    display: inline-flex;
    align-items: center;
    padding: 2px 10px;
    border-radius: 99px;
    font-size: .68rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .06em;
    vertical-align: middle;
    margin-left: 8px;
  }
  .badge-sonnet { background: rgba(124,106,247,.2); color: var(--accent2); border: 1px solid var(--accent); }
  .badge-opus   { background: rgba(96,165,250,.15); color: #93c5fd;        border: 1px solid #60a5fa; }

  /* â”€â”€ Modal overlay (Llibre de Registre) â”€â”€ */
  .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.78);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }
  .modal-overlay.hidden { display: none !important; }
  .modal-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 28px;
    max-width: 680px;
    width: 100%;
    max-height: 82vh;
    overflow-y: auto;
  }

  /* â”€â”€ Llista de capÃ­tols â”€â”€ */
  .capitol-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 9px 14px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: .85rem;
    transition: all .2s;
  }
  .capitol-item.actiu { border-color: var(--accent); background: #1e1b38; }
  .capitol-item.fet   { border-color: var(--success); }
  .capitol-num   { font-weight: 700; color: var(--text2); min-width: 26px; font-size: .8rem; flex-shrink: 0; }
  .capitol-titol { flex: 1; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .capitol-item.actiu .capitol-titol { color: var(--accent2); font-weight: 600; }
  .capitol-item.fet   .capitol-num   { color: var(--success); }
  .capitol-copy { background:none; border:none; color:var(--text2); cursor:pointer; padding:2px 6px; border-radius:4px; font-size:.85rem; opacity:.55; transition:opacity .15s; flex-shrink:0; }
  .capitol-copy:hover { opacity:1; color:var(--accent2); }

  /* â”€â”€ Panel de revisiÃ³ (Opus) â”€â”€ */
  .review-panel {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 18px 22px;
    margin-top: 14px;
  }

  /* â”€â”€ Checkbox gran de configuraciÃ³ â”€â”€ */
  .checkbox-row {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 14px 16px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    cursor: pointer;
    margin-top: 14px;
    transition: border-color .2s;
  }
  .checkbox-row:hover { border-color: var(--accent); }
  .checkbox-row input[type=checkbox] {
    width: 18px; height: 18px;
    accent-color: var(--accent);
    flex-shrink: 0;
    cursor: pointer;
    margin-top: 2px;
  }
  .checkbox-row label { cursor: pointer; line-height: 1.5; }

  /* â”€â”€ Camps de config per proveÃ¯dor â”€â”€ */
  .config-section { margin-top: 4px; }
</style>
</head>
<body>

<header>
  <h1>ğŸ“– Conte IA</h1>
  <p>Crea el teu conte pas a pas amb intelÂ·ligÃ¨ncia artificial</p>
</header>

<!-- CONFIGURACIÃ“ INICIAL -->
<div class="card" id="card-config">
  <h2><span class="icon">âš™ï¸</span> ConfiguraciÃ³</h2>

  <label class="field-label" for="config-provider">ProveÃ¯dor</label>
  <select id="config-provider" onchange="actualitzarConfigProvider()">
    <option value="anthropic">Anthropic (Claude) â€” Sistema dual Sonnet + Opus</option>
    <option value="openai">OpenAI (GPT-4o)</option>
    <option value="gemini">Google (Gemini 1.5)</option>
  </select>

  <!-- Camps especÃ­fics Anthropic (model dual) -->
  <div id="config-anthropic-fields" class="config-section">
    <label class="field-label" for="config-model-generacio">
      Model de generaciÃ³ <span style="color:var(--text2);font-size:.78rem;">â€” escriptura creativa</span>
    </label>
    <input type="text" id="config-model-generacio" value="claude-sonnet-4-6" placeholder="claude-sonnet-4-6">

    <label class="field-label" for="config-model-arquitectura">
      Model d'arquitectura <span style="color:var(--text2);font-size:.78rem;">â€” disseny i revisiÃ³</span>
    </label>
    <input type="text" id="config-model-arquitectura" value="claude-opus-4-6" placeholder="claude-opus-4-6">

    <div class="checkbox-row" onclick="document.getElementById('config-flux-automatic').click()">
      <input type="checkbox" id="config-flux-automatic" onclick="event.stopPropagation()">
      <label for="config-flux-automatic">
        <strong>Flux automÃ tic</strong> â€” Opus revisa cada capÃ­tol i Sonnet el corregeix si cal
        <small style="display:block;color:var(--text2);font-size:.78rem;margin-top:2px;">Si estÃ  desactivat, la revisiÃ³ Ã©s manual (botons per capÃ­tol)</small>
      </label>
    </div>

    <!-- Panell de selecciÃ³ de models flexible v5.1 -->
    <div id="panellModels" style="margin-top:14px;padding:14px;border:1px solid var(--border);border-radius:8px;">
      <h3 style="margin:0 0 10px;font-size:1em;">âš™ï¸ ConfiguraciÃ³ de Models</h3>

      <div style="margin-bottom:10px;">
        <label style="font-weight:bold;font-size:.85em;">Presets rÃ pids:</label>
        <div style="display:flex;gap:6px;margin-top:4px;flex-wrap:wrap;">
          <button onclick="aplicarPreset('economic')"   class="btn" style="padding:3px 8px;font-size:.78rem;" title="Haiku+Sonnet+Sonnet">ğŸ’° EconÃ²mic</button>
          <button onclick="aplicarPreset('equilibrat')" class="btn" style="padding:3px 8px;font-size:.78rem;" title="Sonnet+Sonnet+Sonnet">âš–ï¸ Equilibrat</button>
          <button onclick="aplicarPreset('premium')"    class="btn" style="padding:3px 8px;font-size:.78rem;" title="Sonnet+Sonnet+Opus">ğŸ‘‘ Premium</button>
          <button onclick="aplicarPreset('maxim')"      class="btn" style="padding:3px 8px;font-size:.78rem;" title="Sonnet+Opus+Opus">ğŸ”¬ MÃ xim</button>
          <button onclick="aplicarPreset('barat_gpt')"  class="btn" style="padding:3px 8px;font-size:.78rem;" title="GPT-5.2 per tot">ğŸ¤– GPT-5.2</button>
          <button onclick="aplicarPreset('gemini')"     class="btn" style="padding:3px 8px;font-size:.78rem;" title="Gemini 3 Pro per tot">ğŸŒ Gemini 3</button>
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-bottom:10px;">
        <div>
          <label style="font-size:.82em;font-weight:bold;">ğŸ“ Draft / ExtracciÃ³</label>
          <p style="font-size:.73em;color:var(--text2);margin:2px 0 4px;">Esquelets, fets NKG</p>
          <select id="selectModelDraft" onchange="setModelPerRol('draft', this.value)" style="width:100%;font-size:.78rem;"></select>
          <div id="qualitatDraft" style="font-size:.78em;margin-top:3px;"></div>
        </div>
        <div>
          <label style="font-size:.82em;font-weight:bold;">âœï¸ GeneraciÃ³ LiterÃ ria</label>
          <p style="font-size:.73em;color:var(--text2);margin:2px 0 4px;">Prosa, expansiÃ³</p>
          <select id="selectModelGen" onchange="setModelPerRol('generacio', this.value)" style="width:100%;font-size:.78rem;"></select>
          <div id="qualitatGen" style="font-size:.78em;margin-top:3px;"></div>
        </div>
        <div>
          <label style="font-size:.82em;font-weight:bold;">ğŸ—ï¸ Arquitecte / Revisor</label>
          <p style="font-size:.73em;color:var(--text2);margin:2px 0 4px;">Estructura, diagnÃ²stic</p>
          <select id="selectModelArq" onchange="setModelPerRol('arquitecte', this.value)" style="width:100%;font-size:.78rem;"></select>
          <div id="qualitatArq" style="font-size:.78em;margin-top:3px;"></div>
        </div>
      </div>

      <div id="panellEstimacio" style="background:var(--surface2);border-radius:6px;padding:10px;font-size:.88em;"></div>
      <div id="panellAvisos" style="margin-top:6px;font-size:.82em;"></div>
    </div>
  </div>

  <!-- Camp Ãºnic per a OpenAI / Gemini -->
  <div id="config-single-model-field" class="config-section hidden">
    <label class="field-label" for="config-model-single">Model</label>
    <input type="text" id="config-model-single" placeholder="gpt-4o" value="gpt-4o">
  </div>

  <label class="field-label" for="anthropicApiKey">ğŸ”‘ Anthropic API Key</label>
  <input type="password" id="anthropicApiKey" placeholder="sk-ant-...">

  <label class="field-label" for="geminiApiKey" style="margin-top:6px;">ğŸ”‘ Google Gemini API Key <span style="color:var(--text2);font-size:.78rem;">(opcional â€” per a models Gemini)</span></label>
  <input type="password" id="geminiApiKey" placeholder="AIza...">

  <label class="field-label" for="openaiApiKey" style="margin-top:6px;">ğŸ”‘ OpenAI API Key <span style="color:var(--text2);font-size:.78rem;">(opcional â€” per a models GPT)</span></label>
  <input type="password" id="openaiApiKey" placeholder="sk-...">

  <div class="btn-row">
    <button class="btn btn-primary" onclick="guardarIComencar()">Guardar i ComenÃ§ar</button>
  </div>
</div>

<!-- Progress -->
<div id="progress-wrap" class="hidden">
  <div class="progress-steps" id="steps-bar">
    <div class="step-pill active" data-step="0">GÃ¨nere</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="1">Premissa</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="2">Estil</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="3">Protagonista</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="4">LocalitzaciÃ³</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="5">Final</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="6">Escriptura</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="7">MÃ³n</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="8">Personatges</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="9">Veus</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="9.5">Trames</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="10">Estructura</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="10.5">Escaleta</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="11">CapÃ­tols</div>
    <div class="step-arrow">â€º</div>
    <div class="step-pill" data-step="12">Control d'Arcs</div>
  </div>
</div>

<!-- FASE 0: SelecciÃ³ de gÃ¨nere -->
<div class="card hidden" id="fase-0">
  <h2><span class="icon">ğŸ­</span> Tria el gÃ¨nere</h2>
  <label class="field-label" for="sel-tematica">Tipus de conte</label>
  <select id="sel-tematica">
    <option value="">â€” Selecciona un autor â€”</option>
    <option value="conte negre nÃ²rdic (Stieg Larsson)">Stieg Larsson â€” Noir, misteri i crÃ­tica social</option>
    <option value="conte fantÃ stic Ã¨pic (J.R.R. Tolkien)">J.R.R. Tolkien â€” Fantasia Ã¨pica</option>
    <option value="conte de ciÃ¨ncia-ficciÃ³ distÃ²pica (Philip K. Dick)">Philip K. Dick â€” Distopia, paranoia i drogues</option>
    <option value="conte de misticisme xamÃ nic (Carlos Castaneda)">Carlos Castaneda â€” Misticisme xamÃ nic</option>
  </select>
  <div class="btn-row">
    <button class="btn btn-primary" onclick="iniciarFase1()">âœ¨ Generar premisses</button>
  </div>
</div>

<!-- FASE 1: SelecciÃ³ de premissa -->
<div class="card hidden" id="fase-1">
  <h2><span class="icon">ğŸ’¡</span> Tria la premissa</h2>
  <div class="loader-wrap" id="loader-1">
    <div class="spinner"></div>
    <span>Generant 10 premissesâ€¦</span>
  </div>
  <div id="llista-premisses" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase1" onclick="iniciarFase2()">ğŸ¨ Triar estil narratiu</button>
  </div>
</div>

<!-- FASE 2: Estil narratiu (sense crida a LLM) -->
<div class="card hidden" id="fase-2">
  <h2><span class="icon">ğŸ¨</span> Estil narratiu</h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:4px;">Defineix el to, la perspectiva i la longitud del conte.</p>

  <label class="field-label">To i atmosfera</label>
  <select id="sel-to">
    <option value="">â€” Tria el to â€”</option>
    <option value="misteri i suspens creixent">Misteri i suspens</option>
    <option value="terror psicolÃ²gic i claustrofÃ²bic">Terror psicolÃ²gic</option>
    <option value="realisme mÃ gic poÃ¨tic">Realisme mÃ gic</option>
    <option value="humor negre i irÃ²nic">Humor negre</option>
    <option value="melancolia i bittersweet">Melancolia / bittersweet</option>
    <option value="thriller emocional d'alta tensiÃ³">Thriller emocional</option>
    <option value="tendresa i vulnerabilitat">Tendresa i vulnerabilitat</option>
    <option value="absurd i kafkiÃ ">Absurd / kafkiÃ </option>
    <option value="meravella i mÃ gia continguda">MÃ gia i meravella</option>
    <option value="rÃ bia i tensiÃ³ social">RÃ bia i tensiÃ³ social</option>
  </select>

  <label class="field-label">Perspectiva narrativa</label>
  <div class="opts-row" id="opts-perspectiva">
    <div class="opt-pill" data-group="perspectiva" data-val="primera persona (narrador protagonista)" onclick="triarPill(this)">
      1a persona
      <small>Jo narrador</small>
    </div>
    <div class="opt-pill" data-group="perspectiva" data-val="tercera persona limitada (focalitzaciÃ³ Ãºnica en el protagonista)" onclick="triarPill(this)">
      3a persona
      <small>FocalitzaciÃ³ Ãºnica</small>
    </div>
    <div class="opt-pill" data-group="perspectiva" data-val="segona persona (el lector Ã©s el protagonista)" onclick="triarPill(this)">
      2a persona
      <small>Tu ets el protagonista</small>
    </div>
  </div>

  <label class="field-label">Longitud del conte</label>
  <div class="opts-row" id="opts-paraules">
    <div class="opt-pill" data-group="paraules" data-val="500" onclick="triarPill(this)">
      Microconte
      <small>~500 paraules</small>
    </div>
    <div class="opt-pill" data-group="paraules" data-val="1500" onclick="triarPill(this)">
      Conte curt
      <small>~1.500 paraules</small>
    </div>
    <div class="opt-pill" data-group="paraules" data-val="3000" onclick="triarPill(this)">
      Conte llarg
      <small>~3.000 paraules</small>
    </div>
  </div>

  <!-- Veu Semilla (opcional) -->
  <div style="margin-top:20px;padding-top:16px;border-top:1px solid var(--border);">
    <label class="field-label">Veu de ReferÃ¨ncia (opcional) <span style="font-weight:400;color:var(--text2)">â€” Enganxa 2-3 pÃ gines d'un autor que t'agradi</span></label>
    <textarea id="veuSemilla" style="width:100%;min-height:120px;background:var(--surface2);border:1px solid var(--border);border-radius:8px;color:var(--text);padding:12px;font-size:.88rem;resize:vertical;" placeholder="Opcional: enganxa un fragment d'un autor de referÃ¨ncia (mÃ­nim 200 carÃ cters). Opus analitzarÃ  el seu estil i en generarÃ  un manual per guiar l'escriptura."></textarea>
    <button class="btn btn-secondary" style="margin-top:8px;" onclick="processarVeuSemilla()">ğŸ­ Analitzar estil de referÃ¨ncia <span class="badge-model badge-opus">Opus</span></button>
    <div id="veuSemilla-result" style="margin-top:8px;font-size:.83rem;color:var(--success);"></div>
  </div>
  <div class="btn-row">
    <button class="btn btn-primary" onclick="iniciarFase3()">ğŸ‘¤ Triar protagonista</button>
  </div>
</div>

<!-- FASE 3: Protagonista -->
<div class="card hidden" id="fase-3">
  <h2><span class="icon">ğŸ‘¤</span> Tria el protagonista</h2>
  <div class="loader-wrap" id="loader-3">
    <div class="spinner"></div>
    <span>Generant protagonistesâ€¦</span>
  </div>
  <div id="llista-personatges" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase3" onclick="iniciarFase4()">ğŸ“ Triar la localitzaciÃ³</button>
  </div>
</div>

<!-- FASE 4: Localitzacions -->
<div class="card hidden" id="fase-4">
  <h2><span class="icon">ğŸ“</span> Tria la localitzaciÃ³</h2>
  <div class="loader-wrap" id="loader-4">
    <div class="spinner"></div>
    <span>Generant 5 localitzacionsâ€¦</span>
  </div>
  <div id="llista-localitzacions" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase4" onclick="iniciarFase5()">ğŸ Triar el final</button>
  </div>
</div>

<!-- FASE 5: Finals -->
<div class="card hidden" id="fase-5">
  <h2><span class="icon">ğŸ</span> Tria el final</h2>
  <div class="loader-wrap" id="loader-5">
    <div class="spinner"></div>
    <span>Generant 5 finals possiblesâ€¦</span>
  </div>
  <div id="llista-finals" class="premise-list"></div>
  <div class="btn-row">
    <button class="btn btn-primary hidden" id="btn-fase5" onclick="iniciarEscriptura()">âœï¸ Escriure el conte</button>
  </div>
</div>

<!-- FASE 6: Escriptura -->
<div class="card hidden" id="fase-6">
  <h2><span class="icon">âœï¸</span> El teu conte</h2>
  <div class="loader-wrap" id="loader-6">
    <div class="spinner"></div>
    <span id="loader-6-text">Escrivint el conteâ€¦</span>
  </div>
  <div id="conte-wrap" class="hidden">
    <div class="conte-reader" id="conte-cos"></div>
    <div class="conte-wordcount" id="conte-wordcount"></div>

    <!-- Millora -->
    <div class="millora-row">
      <input type="text" id="millora-input" placeholder="Vols millorar alguna cosa? (ex: Â«fes l'ending mÃ©s abrupteÂ»)">
      <button class="btn btn-secondary" onclick="handleMillorarConte()">âœ¨ Millorar</button>
    </div>

    <div class="btn-row">
      <button class="btn btn-secondary" onclick="regenerarConte()">ğŸ”„ Regenerar</button>
      <button class="btn btn-secondary" onclick="exportarDoc()">ğŸ“„ Descarregar HTML</button>
      <button class="btn btn-primary"   onclick="iniciarFase7()">ğŸŒ Expandir a novelÂ·la</button>
    </div>
    <div id="export-link-wrap" class="hidden" style="margin-top:14px;"></div>
  </div>
</div>

<!-- FASE 7: Worldbuilding -->
<div class="card hidden" id="fase-7">
  <h2><span class="icon">ğŸŒ</span> ExpansiÃ³ del mÃ³n</h2>
  <div class="loader-wrap" id="loader-7">
    <div class="spinner"></div>
    <span id="loader-7-text">Analitzant el conte per proposar elements de mÃ³nâ€¦</span>
  </div>

  <div id="world-selector" class="hidden">
    <p style="color:var(--text2);font-size:.9rem;margin-bottom:16px;">Selecciona els elements que vols expandir a la bÃ­blia de mÃ³n. Els <span style="color:var(--accent2);font-weight:600;">Recomanats</span> ja estan marcats:</p>
    <div id="llista-world" class="premise-list"></div>
    <div class="btn-row">
      <button class="btn btn-primary" onclick="expandirElementsSeleccionats()">ğŸŒ Expandir seleccionats</button>
    </div>
  </div>

  <div id="world-result-wrap" class="hidden">
    <div class="worldbuilding-result" id="world-result-cos"></div>
    <div class="btn-row" style="margin-top:20px;">
      <button class="btn btn-secondary" onclick="tornarASeleccioWorld()">â† Tornar a la selecciÃ³</button>
      <button class="btn btn-primary"   onclick="iniciarFase8()">ğŸ‘¥ Crear elenc de personatges</button>
    </div>
  </div>
</div>


<!-- FASE 8: Elenc de personatges -->
<div class="card hidden" id="fase-8">
  <h2><span class="icon">ğŸ‘¥</span> Elenc de personatges</h2>
  <div class="loader-wrap" id="loader-8">
    <div class="spinner"></div>
    <span id="loader-8-text">Proposant el cast de personatgesâ€¦</span>
  </div>

  <div id="elenc-selector" class="hidden">
    <p style="color:var(--text2);font-size:.9rem;margin-bottom:16px;">Selecciona els personatges que formaran part de la novelÂ·la. Els <span style="color:var(--accent2);font-weight:600;">Recomanats</span> ja estan marcats:</p>
    <div id="llista-elenc" class="premise-list"></div>
    <div class="btn-row">
      <button class="btn btn-primary" onclick="generarEstilsParla()">ğŸ—£ï¸ Definir estils de parla</button>
    </div>
  </div>
</div>

<!-- FASE 9: Estils de parla -->
<div class="card hidden" id="fase-9">
  <h2><span class="icon">ğŸ—£ï¸</span> Estils de parla</h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Perfil de veu i registre narratiu per a cada personatge de l'elenc.</p>
  <div class="loader-wrap" id="loader-9">
    <div class="spinner"></div>
    <span>Definint la veu de cada personatgeâ€¦</span>
  </div>

  <div id="estils-result" class="hidden">
    <div class="veu-result" id="estils-cos"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-secondary" onclick="tornarAElenc()">â† Tornar a l'elenc</button>
      <button class="btn btn-primary" onclick="iniciarFaseTrames()">ğŸ•¸ï¸ Dissenyar Trames <span class="badge-model badge-opus">Opus</span></button>
    </div>
  </div>
</div>

<!-- FASE 9.5: Disseny de Trames (Opus) -->
<div class="card hidden" id="fase-9-5">
  <h2><span class="icon">ğŸ•¸ï¸</span> Disseny de Trames <span class="badge-model badge-opus">Opus</span></h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Opus dissenya la trama principal i les subtrames abans d'estructurar els capÃ­tols.</p>
  <div class="loader-wrap" id="loader-9-5">
    <div class="spinner" style="border-top-color:#60a5fa;"></div>
    <span id="loader-9-5-text">ğŸ”µ Opus dissenyant les tramesâ€¦</span>
  </div>
  <div id="trames-result" class="hidden">
    <div id="trames-cos"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-primary" onclick="iniciarFase10()">ğŸ“ Crear Estructura <span class="badge-model badge-opus">Opus</span></button>
    </div>
  </div>
</div>

<!-- FASE 10: Estructura de la novelÂ·la (Opus) -->
<div class="card hidden" id="fase-10">
  <h2><span class="icon">ğŸ“</span> Estructura de la novelÂ·la <span class="badge-model badge-opus">Opus</span></h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Opus dissenya l'arquitectura narrativa completa â€” capÃ­tols, arcs i fils â€” a partir de tot el material generat.</p>
  <div class="loader-wrap" id="loader-10">
    <div class="spinner" style="border-top-color:#60a5fa;"></div>
    <span id="loader-10-text">ğŸ”µ Opus dissenyant l'estructuraâ€¦</span>
  </div>
  <div id="estructura-wrap" class="hidden">
    <div id="estructura-cos"></div>
    <div id="estimacio-cost" style="white-space:pre;font-family:monospace;font-size:.82rem;color:var(--text2);background:var(--surface2);border-radius:8px;padding:12px 16px;margin:16px 0;border-left:3px solid var(--accent2);display:block;"></div>
    <div class="btn-row" style="margin-top:24px;">
      <button class="btn btn-primary" onclick="iniciarFaseEscaleta()">ğŸ“– Escriure capÃ­tols <span class="badge-model badge-sonnet">Sonnet</span></button>
    </div>
  </div>
</div>

<!-- FASE 10.5: Escaleta per Escenes (Opus) -->
<div class="card hidden" id="fase-10-5">
  <h2>ğŸ“‹ Fase 10.5 â€” Escaleta per Escenes</h2>
  <p>Opus genera l'escaleta detallada per escenes de tots els capÃ­tols, incloent objectiu de paraules i funciÃ³ narrativa de cada escena.</p>
  <div class="loader-wrap" id="loader-10-5"><span class="spinner"></span><span id="loader-10-5-text">Generant escaletaâ€¦</span></div>
  <div id="escaleta-result"></div>
  <button class="btn hidden" id="btn-fase11" onclick="iniciarFase11()">Continuar â†’ Escriptura</button>
</div>

<!-- FASE 11: Escriptura de capÃ­tols (Sonnet + registre) -->
<div class="card hidden" id="fase-11">
  <h2><span class="icon">ğŸ“–</span> Escriptura de capÃ­tols</h2>

  <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:14px;flex-wrap:wrap;gap:8px;">
    <div id="capitol-progress-text" style="color:var(--text2);font-size:.88rem;"></div>
    <button class="btn btn-ghost" style="padding:7px 14px;font-size:.82rem;" onclick="obrirLlibreRegistre()">ğŸ““ Llibre de Registre</button>
    <button class="btn btn-ghost" style="padding:7px 14px;font-size:.82rem;" onclick="obrirBiblia()">ğŸ“š BÃ­blia Narrativa</button>
  </div>

  <div id="capitol-llista" style="display:flex;flex-direction:column;gap:6px;margin-bottom:20px;max-height:260px;overflow-y:auto;"></div>

  <div class="loader-wrap" id="loader-11">
    <div class="spinner"></div>
    <span id="loader-11-text">ğŸŸ£ Sonnet escrivint el capÃ­tolâ€¦</span>
  </div>

  <div id="capitol-actual-wrap" class="hidden">
    <div id="capitol-actual-titol" style="font-size:1.05rem;font-weight:700;color:var(--accent2);margin-bottom:14px;padding-bottom:10px;border-bottom:1px solid var(--border);"></div>
    <div class="conte-reader" id="capitol-actual-cos"></div>
    <div class="conte-wordcount" id="capitol-actual-wordcount"></div>
    <div id="revisio-panel" class="hidden review-panel"></div>
    <div class="btn-row" id="capitol-accions" style="margin-top:16px;"></div>
  </div>

  <div id="btn-control-arcs-wrap" class="hidden" style="margin-top:24px;padding-top:20px;border-top:1px solid var(--border);">
    <p style="color:var(--text2);font-size:.88rem;margin-bottom:14px;text-align:center;">Tots els capÃ­tols estan escrits.</p>

    <!-- RevisiÃ³ Global (loader) -->
    <div id="revisio-global-loader" class="hidden" style="display:flex;align-items:center;gap:10px;color:var(--text2);font-size:.88rem;margin-bottom:16px;padding:14px;background:var(--surface2);border-radius:8px;">
      <div class="spinner" style="border-top-color:#60a5fa;width:24px;height:24px;border-width:2px;"></div>
      <span>ğŸ”µ Opus fent revisiÃ³ global transversalâ€¦</span>
    </div>

    <!-- Resultats de la RevisiÃ³ Global -->
    <div id="revisio-global-result" class="hidden" style="margin-bottom:16px;"></div>

    <!-- Botons de reescriptura suggerits per Opus -->
    <div id="revisio-global-reescriptures" style="margin-bottom:16px;display:flex;gap:10px;flex-wrap:wrap;"></div>

    <!-- Botons de flux -->
    <div style="text-align:center;display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
      <button class="btn btn-primary hidden" id="btn-control-arcs" onclick="iniciarFase12()">ğŸ“‹ Control d'Arcs Narratius <span class="badge-model badge-opus">Opus</span></button>
      <button class="btn btn-secondary" onclick="descarregarNovella()">ğŸ“– Descarregar NovelÂ·la</button>
    </div>
  </div>
</div>

<!-- FASE 12: Control d'Arcs Narratius (Opus - light) -->
<div class="card hidden" id="fase-12">
  <h2><span class="icon">ğŸ“‹</span> Control d'Arcs Narratius <span class="badge-model badge-opus">Opus</span></h2>
  <p style="color:var(--text2);font-size:.9rem;margin-bottom:18px;">Opus avalua la novelÂ·la a partir dels resums â€” sense llegir el text complet â€” per estalviar tokens.</p>
  <div class="loader-wrap" id="loader-12">
    <div class="spinner" style="border-top-color:#60a5fa;"></div>
    <span>ğŸ”µ Opus analitzant els arcs narratiusâ€¦</span>
  </div>
  <div id="arcs-result" class="hidden">
    <div id="arcs-cos"></div>
    <div class="btn-row" style="margin-top:20px;">
      <button class="btn btn-primary hidden" id="btn-epileg" onclick="escriureEpileg()">âœ¨ Escriure EpÃ­leg Resolutiu <span class="badge-model badge-sonnet">Sonnet</span></button>
    </div>
  </div>
  <div id="epileg-loader-wrap" class="hidden" style="padding:20px 0;border-top:1px solid var(--border);margin-top:20px;">
    <div style="display:flex;align-items:center;gap:10px;color:var(--text2);font-size:.88rem;margin-bottom:14px;">
      <div class="spinner" style="width:24px;height:24px;border-width:2px;"></div>
      <span>ğŸŸ£ Sonnet escrivint l'epÃ­legâ€¦</span>
    </div>
  </div>
  <div id="epileg-cos" class="hidden" style="margin-top:20px;padding-top:20px;border-top:1px solid var(--border);">
    <h3 style="font-size:1rem;font-weight:600;color:var(--accent2);margin-bottom:14px;">EpÃ­leg</h3>
    <div class="conte-reader" id="epileg-text"></div>
    <div class="btn-row" style="margin-top:20px;">
      <button class="btn btn-primary" onclick="descarregarNovella()">ğŸ“– Descarregar NovelÂ·la Completa</button>
    </div>
  </div>
</div>

<!-- Modal: Llibre de Registre -->
<div class="modal-overlay hidden" id="modal-registre">
  <div class="modal-box">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px;">
      <h3 style="font-size:1.1rem;font-weight:600;color:var(--accent2);">ğŸ““ Llibre de Registre</h3>
      <button class="btn btn-ghost" style="padding:6px 14px;" onclick="tancarModalRegistre()">âœ• Tancar</button>
    </div>
    <div id="registre-cos"></div>
  </div>
</div>

<!-- Modal: BÃ­blia Narrativa -->
<div class="modal-overlay hidden" id="modal-biblia">
  <div class="modal-box" style="max-width:760px;">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px;">
      <h3 style="font-size:1.1rem;font-weight:600;color:var(--accent2);">ğŸ“š BÃ­blia Narrativa</h3>
      <button class="btn btn-ghost" style="padding:6px 14px;" onclick="tancarModalBiblia()">âœ• Tancar</button>
    </div>
    <div id="biblia-cos"></div>
  </div>
</div>

<div id="toast"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     FRONTEND â€” utilitats i lÃ²gica de navegaciÃ³
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITATS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function escHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function showCard(id)  { document.getElementById(id).classList.remove('hidden'); }
function hideCard(id)  { document.getElementById(id).classList.add('hidden'); }
function showLoader(n) { document.getElementById('loader-' + n).classList.add('visible'); }
function hideLoader(n) { document.getElementById('loader-' + n).classList.remove('visible'); }
function showBtn(id)   { document.getElementById(id).classList.remove('hidden'); }

function toast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 3200);
}

function updateProgress(fase) {
  document.querySelectorAll('.step-pill').forEach(el => {
    const s = parseFloat(el.dataset.step);
    el.classList.remove('active', 'done');
    if (s < fase)  el.classList.add('done');
    if (s === fase) el.classList.add('active');
  });
}

function compteParaules(text) {
  return text.trim().split(/\s+/).filter(w => w.length > 0).length;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ESTAT GLOBAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let USER_CONFIG = null;

const ESTAT = {
  fase:             0,
  tematica:         '',
  history:          [],
  premissaTriada:   '',
  _premissaLista:   [],
  _premissaIdx:     undefined,
  estil: {
    to:          '',
    perspectiva: '',
    paraules:    1500,
    desc:        ''
  },
  _llistaProtagonistes:  [],
  _idxProtagonista:      null,
  protagonistaTriat:     '',
  _llistaLocalitzacions: [],
  _idxLocalitzacio:      null,
  localitzacioTriada:    '',
  _llistaFinals:         [],
  _idxFinal:             null,
  finalTriat:            '',
  // Escriptura per parts
  _historyBeforeEscriptura: [],
  _totalParts:              1,
  _partActual:              1,
  _partsTexts:              [],
  conteText:                '',
  // Worldbuilding
  worldbuilding:            null,
  // Elenc de personatges (fase 8)
  _elencPersonatges:        [],
  // Estils de parla (fase 9)
  _personatgesSeleccionats: [],
  estilsParla:              null,
  // NovelÂ·la (fases 10-12)
  estructuraNovella:        null,
  _estructuraCapitols:      [],
  _capitolActual:           0,
  _capitols_generats:       [],
  _revisioInstruccions:     {},
  _controlArcs:             null,
  epileg:                   null,
  // NovelÂ·la: dades de l'estructura JSON
  _arcGlobal:               '',
  _temesCentrals:           [],
  _prefiguracions:          [],
  _corbaTensio:             [],
  _revisioGlobal:           null,
  _ajustosRumb:             null,
  // BÃ­blia Narrativa Persistent (sistema 1)
  bibliaNarrativa: {
    regles_mon:         [],
    llocs_importants:   [],
    objectes_clau:      [],
    fitxes_personatges: [],
    timeline:           [],
    xarxa_relacions:    [],
    fets_canonics:      []
  },
  // Trames i subtrames (sistema 2)
  trames: {
    trama_principal: null,
    subtrames:        [],
    mapa_entrellacat: []
  },
  llibreRegistre: {
    capitols:          [],
    estat_personatges: [],
    fils_oberts:       [],
    fils_tancats:      []
  },
  _escaletes: [],
  _memoriasComprimides: [],
  _goldenPassage: null,
  _goldenPassageCapitol: -1,
  // NKG (Narrative Knowledge Graph) â€” v4
  _nkg: null,
  _resumCompacte: '',
  _escenes_generades: {},
  // Veu Semilla â€” v4 (fase 6)
  _veuSemilla: null,
  _manualEstil: null,
  // CapÃ­tols adaptatius (v5)
  _nombreCapitols: 12,
  _justificacioCapitols: '',
  // Models per rol (v5.1 â€” selector flexible)
  _modelDraft:      'claude-haiku-4-5-20251001',
  _modelGeneracio:  'claude-sonnet-4-6',
  _modelArquitecte: 'claude-sonnet-4-6',
  // Claus API per proveÃ¯dor (v5.1)
  _anthropicApiKey: '',
  _geminiApiKey:    '',
  _openaiApiKey:    '',
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIGURACIÃ“
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MODEL_DEFAULTS = {
  anthropic: { generacio: 'claude-sonnet-4-6', arquitectura: 'claude-opus-4-6' },
  openai:    { single: 'gpt-4o' },
  gemini:    { single: 'gemini-1.5-pro' }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  REGISTRE DE MODELS â€” v5.1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MODEL_REGISTRY = {
  'claude-haiku-4-5-20251001': {
    nom: 'Claude Haiku 4.5', nomCurt: 'Haiku 4.5',
    proveidor: 'anthropic',
    input_per_m: 1.00, output_per_m: 5.00,
    context_max: 200000,
    qualitat: { draft: 72, prosa: 62, arquitectura: 65, extraccio: 78 },
    velocitat: 'molt_rapida',
    notes: 'RÃ pid i barat. Bo per tasques mecÃ niques. Prosa plana.'
  },
  'claude-sonnet-4-6': {
    nom: 'Claude Sonnet 4.6', nomCurt: 'Sonnet 4.6',
    proveidor: 'anthropic',
    input_per_m: 3.00, output_per_m: 15.00,
    context_max: 1000000,
    qualitat: { draft: 82, prosa: 84, arquitectura: 86, extraccio: 88 },
    velocitat: 'rapida',
    notes: 'Millor rÃ tio qualitat/preu. Quasi Opus a 1/5 del preu. Prosa molt bona.'
  },
  'claude-opus-4-6': {
    nom: 'Claude Opus 4.6', nomCurt: 'Opus 4.6',
    proveidor: 'anthropic',
    input_per_m: 5.00, output_per_m: 25.00,
    context_max: 1000000,
    qualitat: { draft: 85, prosa: 88, arquitectura: 93, extraccio: 90 },
    velocitat: 'moderada',
    notes: 'MÃ xima intelÂ·ligÃ¨ncia. Millor per judicis literaris subtils i arquitectura complexa.'
  },
  'gemini-3-pro-preview': {
    nom: 'Gemini 3 Pro Preview', nomCurt: 'Gemini 3 Pro',
    proveidor: 'google',
    input_per_m: 2.00, output_per_m: 12.00,
    context_max: 1000000,
    qualitat: { draft: 78, prosa: 75, arquitectura: 80, extraccio: 82 },
    velocitat: 'rapida',
    notes: 'Bon raonament, context llarg. Prosa en catalÃ  menys natural que Claude.'
  },
  'gpt-5.2': {
    nom: 'GPT-5.2', nomCurt: 'GPT-5.2',
    proveidor: 'openai',
    input_per_m: 1.75, output_per_m: 14.00,
    context_max: 400000,
    qualitat: { draft: 80, prosa: 78, arquitectura: 82, extraccio: 85 },
    velocitat: 'rapida',
    notes: 'Fort en raonament i codi. CatalÃ  acceptable perÃ² no natiu. Preu competitiu.'
  }
};

const ROLS_MODEL = {
  draft: {
    nom: 'Draft / ExtracciÃ³',
    descripcio: 'Esquelets narratius (Pas 1 dual-pass), extracciÃ³ fets NKG, correccions rÃ pides',
    clau_qualitat: 'draft',
    tokens_estimats: { input: 156000, output: 102000 }
  },
  generacio: {
    nom: 'GeneraciÃ³ LiterÃ ria',
    descripcio: 'ExpansiÃ³ literÃ ria (Pas 2 dual-pass), reescriptura de passatges, conte original',
    clau_qualitat: 'prosa',
    tokens_estimats: { input: 130000, output: 95000 }
  },
  arquitecte: {
    nom: 'Arquitecte / Revisor',
    descripcio: 'Estructura, escaleta, resum compacte, micro-reescriptura diagnÃ²stic, revisiÃ³ global, veu semilla',
    clau_qualitat: 'arquitectura',
    tokens_estimats: { input: 95000, output: 38000 }
  }
};

// Model hÃ­brid v5.1: llegeix de ESTAT._model* (selector flexible per rol)
function getModelConfig(userConfig) {
  // Prioritat: ESTAT._model* > userConfig.model* > defaults
  const cfg = userConfig || {};
  return {
    modelDraft:      ESTAT._modelDraft      || cfg.modelDraft      || cfg.modelHaiku      || 'claude-haiku-4-5-20251001',
    modelGeneracio:  ESTAT._modelGeneracio  || cfg.modelGeneracio  || cfg.model           || 'claude-sonnet-4-6',
    modelArquitecte: ESTAT._modelArquitecte || cfg.modelArquitecte || cfg.modelArquitectura || cfg.model || 'claude-sonnet-4-6'
  };
}

function setModelPerRol(rol, modelId) {
  if (!MODEL_REGISTRY[modelId]) { console.warn(`Model desconegut: ${modelId}`); return; }
  switch (rol) {
    case 'draft':      ESTAT._modelDraft      = modelId; break;
    case 'generacio':  ESTAT._modelGeneracio  = modelId; break;
    case 'arquitecte': ESTAT._modelArquitecte = modelId; break;
  }
  actualitzarEstimacio();
}

function aplicarPreset(preset) {
  const presets = {
    'economic':   { draft: 'claude-haiku-4-5-20251001', generacio: 'claude-sonnet-4-6', arquitecte: 'claude-sonnet-4-6' },
    'equilibrat': { draft: 'claude-sonnet-4-6',         generacio: 'claude-sonnet-4-6', arquitecte: 'claude-sonnet-4-6' },
    'premium':    { draft: 'claude-sonnet-4-6',         generacio: 'claude-sonnet-4-6', arquitecte: 'claude-opus-4-6'  },
    'maxim':      { draft: 'claude-sonnet-4-6',         generacio: 'claude-opus-4-6',   arquitecte: 'claude-opus-4-6'  },
    'barat_gpt':  { draft: 'gpt-5.2',                  generacio: 'gpt-5.2',           arquitecte: 'gpt-5.2'          },
    'gemini':     { draft: 'gemini-3-pro-preview',      generacio: 'gemini-3-pro-preview', arquitecte: 'gemini-3-pro-preview' }
  };
  const p = presets[preset];
  if (!p) return;
  ESTAT._modelDraft      = p.draft;
  ESTAT._modelGeneracio  = p.generacio;
  ESTAT._modelArquitecte = p.arquitecte;
  const selDraft = document.getElementById('selectModelDraft');
  const selGen   = document.getElementById('selectModelGen');
  const selArq   = document.getElementById('selectModelArq');
  if (selDraft) selDraft.value = p.draft;
  if (selGen)   selGen.value   = p.generacio;
  if (selArq)   selArq.value   = p.arquitecte;
  actualitzarEstimacio();
}

// Alias backward compatible
function aplicarPresetModels(preset) { aplicarPreset(preset); }

function actualitzarConfigProvider() {
  const provider = document.getElementById('config-provider').value;

  // Ara mostrem els camps de sistema dual per a TOTS els proveÃ¯dors
  document.getElementById('config-anthropic-fields').classList.remove('hidden');
  document.getElementById('config-single-model-field').classList.add('hidden');

  const genInput = document.getElementById('config-model-generacio');
  const arqInput = document.getElementById('config-model-arquitectura');

  // Actualitzem els valors per defecte recomanats segons el proveÃ¯dor
  if (provider === 'anthropic') {
    genInput.value = 'claude-sonnet-4-6';
    arqInput.value = 'claude-opus-4-6';
  } else if (provider === 'gemini') {
    genInput.value = 'gemini-1.5-flash';
    arqInput.value = 'gemini-1.5-pro';
  } else if (provider === 'openai') {
    genInput.value = 'gpt-4o-mini';
    arqInput.value = 'gpt-4o';
  }
}

// MantÃ© compatibilitat si algÃº cridava l'antiga funciÃ³
function actualitzarModelDefault() { actualitzarConfigProvider(); }

function guardarIComencar() {
  const provider = document.getElementById('config-provider').value;
  if (!provider) { toast('Selecciona un proveÃ¯dor.'); return; }

  const anthropicKey = document.getElementById('anthropicApiKey')?.value?.trim() || '';
  const geminiKey    = document.getElementById('geminiApiKey')?.value?.trim();
  const openaiKey    = document.getElementById('openaiApiKey')?.value?.trim();

  let apiKey = '';
  if (provider === 'anthropic') apiKey = anthropicKey;
  if (provider === 'gemini')    apiKey = geminiKey;
  if (provider === 'openai')    apiKey = openaiKey;

  if (!apiKey) { toast("Introdueix una API key per al proveÃ¯dor seleccionat."); return; }

  if (anthropicKey) ESTAT._anthropicApiKey = anthropicKey;
  if (geminiKey)    ESTAT._geminiApiKey    = geminiKey;
  if (openaiKey)    ESTAT._openaiApiKey    = openaiKey;

  const modelGeneracio    = document.getElementById('config-model-generacio').value.trim();
  const modelArquitectura = document.getElementById('config-model-arquitectura').value.trim();
  const fluxAutomatic     = document.getElementById('config-flux-automatic').checked;

  if (!modelGeneracio)    { toast('Introdueix el model de generaciÃ³.'); return; }
  if (!modelArquitectura) { toast("Introdueix el model d'arquitectura."); return; }

  // AQUESTA Ã‰S LA CLAU: Sobreescriure l'ESTAT intern perquÃ¨ oblidi Claude
  ESTAT._modelGeneracio  = modelGeneracio;
  ESTAT._modelArquitecte = modelArquitectura;
  ESTAT._modelDraft      = modelGeneracio; 

  USER_CONFIG = {
    provider,
    apiKey,
    modelGeneracio,
    modelArquitectura,
    modelDraft: modelGeneracio,
    modelArquitecte: modelArquitectura,
    fluxAutomatic
  };

  poblarSelectorsModels();
  actualitzarModelsDisponibles();

  hideCard('card-config');
  document.getElementById('progress-wrap').classList.remove('hidden');
  showCard('fase-0');
  toast('ConfiguraciÃ³ guardada.');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 0 â†’ FASE 1: Premisses
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase1() {
  const sel = document.getElementById('sel-tematica').value;
  if (!sel) { toast('Selecciona primer un gÃ¨nere.'); return; }
  if (!USER_CONFIG) { toast('Primer configura el model.'); return; }

  ESTAT.tematica = sel;
  ESTAT.history  = [];
  ESTAT.fase     = 1;
  updateProgress(1);
  showCard('fase-1');
  showLoader(1);

  try {
    const res = await fase1_premisses(sel, [], USER_CONFIG);
    ESTAT.history = res.history;
    hideLoader(1);
    renderPremisses(res.response);
  } catch (err) {
    hideLoader(1);
    toast('Error: ' + err.message);
  }
}

// â”€â”€â”€ Render genÃ¨ric amb badge "Recomanat" (radio / single-select) â”€â”€â”€
function renderLlistaAmbRecomanat(text, wrapId, listaKey, idxKey, btnId) {
  const wrap  = document.getElementById(wrapId);
  const lines = text.split('\n').filter(l => /^\d+\./.test(l.trim()));
  if (lines.length === 0) {
    wrap.innerHTML = `<pre style="white-space:pre-wrap;font-size:.9rem;">${escHtml(text)}</pre>`;
    ESTAT[listaKey] = [];
    return;
  }
  const list = lines.map(l => l.replace(/^\d+\.\s*/, '').trim());
  // Guardar sense "(Recomanat)" per usar als prompts
  ESTAT[listaKey] = list.map(item => item.replace(/\s*\(Recomanat\)\s*/i, '').trim());
  ESTAT[idxKey]   = null;

  let autoIdx = null;
  wrap.innerHTML = list.map((item, i) => {
    const esRecomanat = /\(Recomanat\)/i.test(item);
    const textNet     = item.replace(/\s*\(Recomanat\)\s*/i, '').trim();
    if (esRecomanat) autoIdx = i;
    const badge = esRecomanat ? `<span class="badge-recomanat">Recomanat</span>` : '';
    return `<div class="premise-item" id="${wrapId}-item-${i}" onclick="triarItem('${wrapId}','${idxKey}',${i},this)">
      <input type="radio" name="${wrapId}-radio" id="${wrapId}-r-${i}">
      <label for="${wrapId}-r-${i}">${badge}${escHtml(textNet)}</label>
    </div>`;
  }).join('');

  // Auto-seleccionar el recomanat
  if (autoIdx !== null) {
    const el = document.getElementById(`${wrapId}-item-${autoIdx}`);
    if (el) {
      el.classList.add('chosen');
      el.querySelector('input').checked = true;
      ESTAT[idxKey] = autoIdx;
    }
  }
  showBtn(btnId);
}

function triarItem(wrapId, idxKey, idx, el) {
  document.querySelectorAll(`#${wrapId} .premise-item`).forEach(e => e.classList.remove('chosen'));
  el.classList.add('chosen');
  el.querySelector('input').checked = true;
  ESTAT[idxKey] = idx;
}

function renderPremisses(text) {
  renderLlistaAmbRecomanat(text, 'llista-premisses', '_premissaLista', '_premissaIdx', 'btn-fase1');
}

function triarPremissa(idx, el) { triarItem('llista-premisses', '_premissaIdx', idx, el); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 1 â†’ FASE 2: Estil (sense API)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function iniciarFase2() {
  const idx = ESTAT._premissaIdx;
  if (idx === undefined || idx === null) { toast('Tria una premissa primer.'); return; }
  ESTAT.premissaTriada = ESTAT._premissaLista[idx];
  ESTAT.fase = 2;
  updateProgress(2);
  showCard('fase-2');
}

// Pills de selecciÃ³ (estil)
function triarPill(el) {
  const group = el.dataset.group;
  document.querySelectorAll(`.opt-pill[data-group="${group}"]`).forEach(p => p.classList.remove('chosen'));
  el.classList.add('chosen');
  const val = el.dataset.val;
  if (group === 'perspectiva') ESTAT.estil.perspectiva = val;
  if (group === 'paraules')    ESTAT.estil.paraules    = parseInt(val);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 2 â†’ FASE 3: Protagonista
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase3() {
  const to          = document.getElementById('sel-to').value;
  const perspectiva = ESTAT.estil.perspectiva;
  const paraules    = ESTAT.estil.paraules;

  if (!to)          { toast('Tria el to del conte.'); return; }
  if (!perspectiva) { toast('Tria la perspectiva narrativa.'); return; }
  if (!paraules)    { toast('Tria la longitud del conte.'); return; }

  ESTAT.estil.to  = to;
  ESTAT.estil.desc = `to "${to}", ${perspectiva}, ${paraules} paraules aproximades`;

  ESTAT.fase = 3;
  updateProgress(3);
  showCard('fase-3');
  showLoader(3);

  try {
    const res = await fase3_personatges(ESTAT.premissaTriada, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    hideLoader(3);
    renderProtagonistes(res.response);
  } catch (err) {
    hideLoader(3);
    toast('Error: ' + err.message);
  }
}

function renderProtagonistes(text) {
  renderLlistaAmbRecomanat(text, 'llista-personatges', '_llistaProtagonistes', '_idxProtagonista', 'btn-fase3');
}

function triarProtagonista(idx, el) { triarItem('llista-personatges', '_idxProtagonista', idx, el); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 3 â†’ FASE 4: Localitzacions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase4() {
  const idx = ESTAT._idxProtagonista;
  if (idx === null || idx === undefined || !ESTAT._llistaProtagonistes[idx]) {
    toast('Tria un protagonista primer.');
    return;
  }
  ESTAT.protagonistaTriat = ESTAT._llistaProtagonistes[idx];
  ESTAT.fase = 4;
  updateProgress(4);
  showCard('fase-4');
  showLoader(4);

  try {
    const res = await fase_localitzacions(ESTAT.protagonistaTriat, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    hideLoader(4);
    renderLlistaAmbRecomanat(res.response, 'llista-localitzacions', '_llistaLocalitzacions', '_idxLocalitzacio', 'btn-fase4');
  } catch (err) {
    hideLoader(4);
    toast('Error: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 4 â†’ FASE 5: Finals
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase5() {
  const idx = ESTAT._idxLocalitzacio;
  if (idx === null || idx === undefined || !ESTAT._llistaLocalitzacions[idx]) {
    toast('Tria una localitzaciÃ³ primer.');
    return;
  }
  ESTAT.localitzacioTriada = ESTAT._llistaLocalitzacions[idx];
  ESTAT.fase = 5;
  updateProgress(5);
  showCard('fase-5');
  showLoader(5);

  try {
    const res = await fase4_finals(ESTAT.localitzacioTriada, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    hideLoader(5);
    renderLlistaAmbRecomanat(res.response, 'llista-finals', '_llistaFinals', '_idxFinal', 'btn-fase5');
  } catch (err) {
    hideLoader(5);
    toast('Error: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 5 â†’ FASE 6: Escriptura per parts
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function iniciarEscriptura() {
  const idx = ESTAT._idxFinal;
  if (idx === null || idx === undefined || !ESTAT._llistaFinals[idx]) {
    toast('Tria un final primer.');
    return;
  }
  ESTAT.finalTriat = ESTAT._llistaFinals[idx];

  const p = ESTAT.estil.paraules;
  ESTAT._totalParts  = p <= 600 ? 1 : p <= 1800 ? 2 : 4;
  ESTAT._partActual  = 1;
  ESTAT._partsTexts  = [];
  ESTAT._historyBeforeEscriptura = [...ESTAT.history];

  ESTAT.fase = 6;
  updateProgress(6);
  showCard('fase-6');
  hideCard('conte-wrap');
  document.getElementById('export-link-wrap').classList.add('hidden');

  escriureSeguentPart();
}

async function escriureSeguentPart() {
  const part      = ESTAT._partActual;
  const total     = ESTAT._totalParts;
  const perPart   = Math.round(ESTAT.estil.paraules / total);
  const loaderTxt = total === 1
    ? 'Escrivint el conteâ€¦'
    : `Escrivint part ${part} de ${total}â€¦`;

  showLoader(6);
  document.getElementById('loader-6-text').textContent = loaderTxt;

  try {
    const res = await escriureContePart(part, total, perPart, ESTAT.finalTriat, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history = res.history;
    ESTAT._partsTexts.push(res.response);
    hideLoader(6);

    if (ESTAT._partActual < ESTAT._totalParts) {
      ESTAT._partActual++;
      await escriureSeguentPart();
    } else {
      const conteComplet = ESTAT._partsTexts.join('\n\n');
      ESTAT.conteText    = conteComplet;
      mostrarConte(conteComplet);
    }
  } catch (err) {
    hideLoader(6);
    toast('Error a la part ' + part + ': ' + err.message);
  }
}

function mostrarConte(text) {
  const cos  = document.getElementById('conte-cos');
  const pars = text.split(/\n\n+/).filter(p => p.trim().length > 0);
  cos.innerHTML = pars.map(p => `<p>${escHtml(p.trim())}</p>`).join('');

  const wc = compteParaules(text);
  document.getElementById('conte-wordcount').textContent = `${wc.toLocaleString('ca')} paraules`;

  showCard('conte-wrap');
  setTimeout(() => {
    document.getElementById('fase-6').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ACCIONS SOBRE EL CONTE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function regenerarConte() {
  if (!confirm('Vols regenerar el conte? El text actual es perdrÃ .')) return;
  ESTAT.history     = [...ESTAT._historyBeforeEscriptura];
  ESTAT._partActual = 1;
  ESTAT._partsTexts = [];
  hideCard('conte-wrap');
  escriureSeguentPart();
}

async function handleMillorarConte() {
  const instruccio = document.getElementById('millora-input').value.trim();
  if (!instruccio) { toast('Escriu una instrucciÃ³ de millora.'); return; }
  if (!ESTAT.conteText) { toast('Primer genera el conte.'); return; }

  hideCard('conte-wrap');
  showLoader(6);
  document.getElementById('loader-6-text').textContent = 'Aplicant la milloraâ€¦';

  try {
    const res = await millorarConte(instruccio, ESTAT.conteText, ESTAT.estil.desc, ESTAT.history, USER_CONFIG, ESTAT.tematica);
    ESTAT.history   = res.history;
    ESTAT.conteText = res.response;
    hideLoader(6);
    document.getElementById('millora-input').value = '';
    mostrarConte(res.response);
    toast('Millora aplicada.');
  } catch (err) {
    hideLoader(6);
    showCard('conte-wrap');
    toast('Error: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPORT LOCAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function exportarDoc() {
  if (!ESTAT.conteText) { toast('No hi ha cap conte per exportar.'); return; }
  const titol = ESTAT.premissaTriada
    ? ESTAT.premissaTriada.substring(0, 55) + (ESTAT.premissaTriada.length > 55 ? 'â€¦' : '')
    : 'Conte IA';
  exportarADoc(titol, ESTAT.conteText);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 6 â†’ FASE 7: Worldbuilding
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase7() {
  if (!ESTAT.conteText) { toast('Primer genera el conte.'); return; }

  ESTAT.fase = 7;
  updateProgress(7);
  showCard('fase-7');
  document.getElementById('world-selector').classList.add('hidden');
  document.getElementById('world-result-wrap').classList.add('hidden');
  showLoader(7);
  document.getElementById('loader-7-text').textContent = 'Analitzant el conte per proposar elements de mÃ³nâ€¦';

  try {
    const res = await fase7_worldbuilding(ESTAT.conteText, ESTAT.tematica, ESTAT.estil.desc, ESTAT.history, USER_CONFIG);
    ESTAT.history = res.history;
    hideLoader(7);
    renderLlistaWorldbuilding(res.response);
  } catch (err) {
    hideLoader(7);
    toast('Error: ' + err.message);
  }
}

function renderLlistaWorldbuilding(text) {
  const wrap  = document.getElementById('llista-world');
  const lines = text.split('\n').filter(l => /^\d+\./.test(l.trim()));

  if (lines.length === 0) {
    wrap.innerHTML = `<pre style="white-space:pre-wrap;font-size:.9rem;">${escHtml(text)}</pre>`;
    document.getElementById('world-selector').classList.remove('hidden');
    return;
  }

  const list = lines.map(l => l.replace(/^\d+\.\s*/, '').trim());

  wrap.innerHTML = list.map((item, i) => {
    const esRecomanat = /\(Recomanat\)/i.test(item);
    const textNet     = item.replace(/\s*\(Recomanat\)\s*/i, '').trim();
    const displayHtml = escHtml(textNet).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    const badge       = esRecomanat ? `<span class="badge-recomanat">Recomanat</span>` : '';
    const checkedAttr = esRecomanat ? 'checked' : '';
    const chosenClass = esRecomanat ? 'chosen' : '';
    return `<div class="world-item ${chosenClass}" id="world-item-${i}" data-text="${escHtml(textNet)}" onclick="toggleWorldItem(${i}, this)">
      <input type="checkbox" id="world-cb-${i}" ${checkedAttr} onclick="event.stopPropagation();" onchange="syncWorldItem(${i})">
      <label for="world-cb-${i}">${badge}${displayHtml}</label>
    </div>`;
  }).join('');

  document.getElementById('world-selector').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-7').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function toggleWorldItem(idx, el) {
  const cb = document.getElementById('world-cb-' + idx);
  cb.checked = !cb.checked;
  el.classList.toggle('chosen', cb.checked);
}

function syncWorldItem(idx) {
  const cb = document.getElementById('world-cb-' + idx);
  const el = document.getElementById('world-item-' + idx);
  el.classList.toggle('chosen', cb.checked);
}

async function expandirElementsSeleccionats() {
  const checkboxes = document.querySelectorAll('#llista-world input[type=checkbox]:checked');
  if (checkboxes.length === 0) { toast('Selecciona almenys un element per expandir.'); return; }

  const labels = Array.from(checkboxes).map(cb => {
    const item = document.getElementById(cb.id.replace('world-cb-', 'world-item-'));
    return item ? item.dataset.text : '';
  }).filter(t => t.length > 0);

  document.getElementById('world-selector').classList.add('hidden');
  document.getElementById('world-result-wrap').classList.add('hidden');
  showLoader(7);
  document.getElementById('loader-7-text').textContent = 'Generant la bÃ­blia de mÃ³nâ€¦';

  try {
    const res = await fase7_expandirElements(labels, ESTAT.conteText, ESTAT.tematica, ESTAT.history, USER_CONFIG);
    ESTAT.history       = res.history;
    ESTAT.worldbuilding = res.response;
    hideLoader(7);
    mostrarResultatWorldbuilding(res.response);
  } catch (err) {
    hideLoader(7);
    document.getElementById('world-selector').classList.remove('hidden');
    toast('Error: ' + err.message);
  }
}

function mostrarResultatWorldbuilding(text) {
  const cos = document.getElementById('world-result-cos');

  const blocs = text.split(/\n\n+/).filter(b => b.trim().length > 0);
  cos.innerHTML = blocs.map(bloc => {
    const linies = bloc.trim().split('\n');
    const primerLinia = linies[0] || '';
    const esTitol = /^\*\*.+\*\*/.test(primerLinia.trim());
    if (esTitol) {
      const titol = escHtml(primerLinia.trim()).replace(/\*\*(.+?)\*\*/g, '$1');
      const desc  = linies.slice(1).join('\n').trim();
      return `<div class="world-bloc">
        <div class="world-bloc-titol">${titol}</div>
        <div class="world-bloc-desc">${escHtml(desc)}</div>
      </div>`;
    }
    return `<div class="world-bloc"><div class="world-bloc-desc">${escHtml(bloc.trim())}</div></div>`;
  }).join('');

  document.getElementById('world-result-wrap').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-7').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function tornarASeleccioWorld() {
  document.getElementById('world-result-wrap').classList.add('hidden');
  document.getElementById('world-selector').classList.remove('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 7 â†’ FASE 8: Elenc de personatges
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase8() {
  ESTAT.fase = 8;
  updateProgress(8);
  showCard('fase-8');
  document.getElementById('elenc-selector').classList.add('hidden');
  showLoader(8);
  document.getElementById('loader-8-text').textContent = 'Proposant el cast de personatgesâ€¦';

  // Passa el worldbuilding com a context addicional si existeix
  const worldContext = ESTAT.worldbuilding
    ? '\n\nBÃ­blia de mÃ³n disponible:\n' + ESTAT.worldbuilding
    : '';

  try {
    const res = await fase8_elencPersonatges(
      ESTAT.conteText, ESTAT.protagonistaTriat, ESTAT.tematica,
      ESTAT.estil.desc, worldContext, ESTAT.history, USER_CONFIG
    );
    ESTAT.history = res.history;
    hideLoader(8);
    renderElencPersonatges(res.response);
  } catch (err) {
    hideLoader(8);
    toast('Error: ' + err.message);
  }
}

function renderElencPersonatges(text) {
  const wrap  = document.getElementById('llista-elenc');
  const lines = text
    .split('\n')
    .map(l => l.trim())
    .filter(Boolean)
    .filter(l => /^\d+[.)]\s+/.test(l) || /^[-*â€¢]\s+/.test(l) || /\bRol\s*:/i.test(l));

  if (lines.length === 0) {
    wrap.innerHTML = `<pre style="white-space:pre-wrap;font-size:.9rem;">${escHtml(text)}</pre>`;
    ESTAT._elencPersonatges = [];
    document.getElementById('elenc-selector').classList.remove('hidden');
    return;
  }

  const list = lines
    .map(l => l
      .replace(/^\d+[.)]\s*/, '')
      .replace(/^[-*â€¢]\s*/, '')
      .trim())
    .filter(Boolean)
    .slice(0, 8);
  ESTAT._elencPersonatges = list.map(item => item.replace(/\s*\(Recomanat\)\s*/i, '').trim());

  wrap.innerHTML = list.map((item, i) => {
    const esRecomanat = /\(Recomanat\)/i.test(item);
    const textNet     = item.replace(/\s*\(Recomanat\)\s*/i, '').trim();
    const displayHtml = escHtml(textNet).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    const badge       = esRecomanat ? `<span class="badge-recomanat">Recomanat</span>` : '';
    const checkedAttr = esRecomanat ? 'checked' : '';
    const chosenClass = esRecomanat ? 'chosen' : '';
    return `<div class="world-item ${chosenClass}" id="elenc-item-${i}" data-text="${escHtml(textNet)}" onclick="toggleElencItem(${i}, this)">
      <input type="checkbox" id="elenc-cb-${i}" ${checkedAttr} onclick="event.stopPropagation();" onchange="syncElencItem(${i})">
      <label for="elenc-cb-${i}">${badge}${displayHtml}</label>
    </div>`;
  }).join('');

  document.getElementById('elenc-selector').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-8').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function toggleElencItem(idx, el) {
  const cb = document.getElementById('elenc-cb-' + idx);
  cb.checked = !cb.checked;
  el.classList.toggle('chosen', cb.checked);
}

function syncElencItem(idx) {
  const cb = document.getElementById('elenc-cb-' + idx);
  const el = document.getElementById('elenc-item-' + idx);
  el.classList.toggle('chosen', cb.checked);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 8 â†’ FASE 9: Estils de parla
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEstilsParla() {
  const checkboxes = document.querySelectorAll('#llista-elenc input[type=checkbox]:checked');
  if (checkboxes.length === 0) { toast('Selecciona almenys un personatge.'); return; }

  const seleccionats = Array.from(checkboxes).map(cb => {
    const item = document.getElementById(cb.id.replace('elenc-cb-', 'elenc-item-'));
    return item ? item.dataset.text : '';
  }).filter(t => t.length > 0);

  ESTAT._personatgesSeleccionats = seleccionats;
  ESTAT.fase = 9;
  updateProgress(9);
  showCard('fase-9');
  document.getElementById('estils-result').classList.add('hidden');
  showLoader(9);

  try {
    const res = await fase9_estilParla(
      ESTAT.protagonistaTriat, seleccionats, ESTAT.conteText,
      ESTAT.tematica, ESTAT.estil.desc, ESTAT.history, USER_CONFIG
    );
    ESTAT.history    = res.history;
    ESTAT.estilsParla = res.response;
    hideLoader(9);
    mostrarEstilsParla(res.response);
  } catch (err) {
    hideLoader(9);
    toast('Error: ' + err.message);
  }
}

function mostrarEstilsParla(text) {
  const cos = document.getElementById('estils-cos');

  // Partir el text en blocs per personatge (cada bloc comenÃ§a amb **Nom**)
  const lines  = text.split('\n');
  const cards  = [];
  let current  = [];

  for (const line of lines) {
    if (/^\*\*.+\*\*\s*$/.test(line.trim()) && current.length > 0) {
      cards.push(current);
      current = [line];
    } else {
      current.push(line);
    }
  }
  if (current.length > 0) cards.push(current);

  cos.innerHTML = cards.map(cardLines => {
    const nomLine = cardLines[0] || '';
    const nom     = escHtml(nomLine.trim().replace(/\*\*/g, ''));

    const campsHtml = cardLines.slice(1).map(line => {
      const l = line.trim();
      if (!l) return '';

      const match = l.match(/^([^:]+):\s*(.+)$/);
      if (match) {
        const label = escHtml(match[1].trim());
        const val   = escHtml(match[2].trim());
        if (/exemple/i.test(label)) {
          return `<div>
            <div class="veu-camp-label">${label}</div>
            <div class="veu-exemple">${val}</div>
          </div>`;
        }
        return `<div>
          <div class="veu-camp-label">${label}</div>
          <div class="veu-camp-val">${val}</div>
        </div>`;
      }
      return `<div class="veu-camp-val">${escHtml(l)}</div>`;
    }).filter(h => h).join('\n');

    return `<div class="veu-card">
      <div class="veu-card-nom">ğŸ‘¤ ${nom}</div>
      <div class="veu-card-camps">${campsHtml}</div>
    </div>`;
  }).join('\n');

  document.getElementById('estils-result').classList.remove('hidden');
  setTimeout(() => {
    document.getElementById('fase-9').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function tornarAElenc() {
  document.getElementById('estils-result').classList.add('hidden');
  hideLoader(9);
  document.getElementById('fase-8').scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10: Estructura de la novelÂ·la (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase10() {
  ESTAT.fase = 10;
  updateProgress(10);
  showCard('fase-10');
  document.getElementById('estructura-wrap').classList.add('hidden');
  showLoader(10);
  document.getElementById('loader-10-text').textContent = 'ğŸ”µ Opus creant la bÃ­blia narrativaâ€¦';

  try {
    // Primer: crear la bÃ­blia narrativa inicial
    await inicialitzarBiblia(USER_CONFIG);

    // Validar que la bÃ­blia tÃ© fitxes per a tots els personatges
    const persEsperats = (ESTAT._personatgesSeleccionats || []).length;
    const persRebuts = (ESTAT.bibliaNarrativa.fitxes_personatges || []).length;
    if (persEsperats > 0 && persRebuts < persEsperats) {
      console.warn(`BÃ­blia incompleta: ${persRebuts}/${persEsperats} personatges. Completant...`);
      document.getElementById('loader-10-text').textContent = 'ğŸ”µ Completant fitxes de personatgesâ€¦';
      try {
        await completarBibliaPersonatges(USER_CONFIG);
      } catch (retryErr) {
        console.warn('Retry bÃ­blia personatges: ' + retryErr.message);
      }
    }

    // DesprÃ©s: generar l'estructura
    document.getElementById('loader-10-text').textContent = 'ğŸ”µ Opus dissenyant l\'estructuraâ€¦';
    const res = await generarEstructuraNovella(USER_CONFIG);
    ESTAT.estructuraNovella   = res.response;
    ESTAT._estructuraCapitols = parseEstructura(res.response);

    // Retry: si falten capÃ­tols, completar-los amb una segona crida
    const capsEsperats = ESTAT._nombreCapitols || 12;
    if (ESTAT._estructuraCapitols.length > 0 && ESTAT._estructuraCapitols.length < capsEsperats) {
      console.warn(`Estructura incompleta: ${ESTAT._estructuraCapitols.length}/${capsEsperats} capÃ­tols. Completant...`);
      document.getElementById('loader-10-text').textContent = `ğŸ”µ Completant capÃ­tols ${ESTAT._estructuraCapitols.length + 1}-${capsEsperats}â€¦`;
      try {
        const completRes = await completarEstructuraCapitols(ESTAT._estructuraCapitols, capsEsperats, USER_CONFIG);
        const completDades = parseJsonRobust(completRes.response);
        if (completDades && Array.isArray(completDades.capitols) && completDades.capitols.length > 0) {
          const nousCapitols = completDades.capitols.map(cap => ({
            numero:                 cap.numero,
            titol:                  cap.titol,
            text:                   JSON.stringify(cap),
            personatges:            cap.personatges || [],
            fil:                    cap.fil_principal || '',
            toRitme:                cap.to_ritme || '',
            prefiguracionsPlantar:  cap.prefiguracions_a_plantar || [],
            prefiguracionsRecollir: cap.prefiguracions_a_recollir || [],
            resum:                  cap.resum || '',
            connexioAnterior:       cap.connexio_anterior || '',
            connexioSeguent:        cap.connexio_seguent || ''
          }));
          ESTAT._estructuraCapitols = ESTAT._estructuraCapitols.concat(nousCapitols);
          ESTAT._nombreCapitols = ESTAT._estructuraCapitols.length;
          console.log(`Estructura completada: ${ESTAT._estructuraCapitols.length} capÃ­tols`);
        }
      } catch (retryErr) {
        console.warn('Retry estructura: ' + retryErr.message);
      }
    }

    hideLoader(10);
    mostrarEstructura(res.response);
    // Mostrar estimaciÃ³ de cost a la consola i al toast
    try {
      const estimacio = mostrarEstimacioCost();
      console.log('ğŸ“Š ESTIMACIÃ“ DE COST:\n' + estimacio);
      const costEl = document.getElementById('estimacio-cost');
      if (costEl) costEl.textContent = estimacio;
    } catch (e) { /* no bloquejant */ }
  } catch (err) {
    hideLoader(10);
    toast('Error Opus: ' + err.message);
  }
}

// Fallback: parser antic basat en regex (per si la resposta no Ã©s JSON)
function parseEstructuraLegacy(text) {
  if (!text) return [];
  const chapters = [];
  const capPattern = /(?:\*\*|#{1,3}\s*)(?:[Cc]apÃ­tol|[Cc]apitol|[Cc]ap\.?)\s+(\d+)(?::\s*(.+?))?\*{0,2}\s*\n([\s\S]*?)(?=(?:\*\*|#{1,3}\s*)(?:[Cc]apÃ­tol|[Cc]apitol|[Cc]ap\.?)\s+\d+|$)/g;
  let match;
  while ((match = capPattern.exec(text)) !== null) {
    const numero = parseInt(match[1]);
    const titol  = (match[2] || 'CapÃ­tol ' + numero).trim().replace(/\*+$/, '');
    const cos    = (match[3] || '').trim();
    chapters.push({ numero, titol, text: `**CapÃ­tol ${numero}: ${titol}**\n${cos}` });
  }
  if (chapters.length === 0) {
    const parts = text.split(/(?=(?:[Cc]apÃ­tol|[Cc]apitol)\s+\d+)/);
    parts.forEach(part => {
      const m = part.match(/(?:[Cc]apÃ­tol|[Cc]apitol)\s+(\d+)(?::\s*(.+))?/);
      if (m) chapters.push({ numero: parseInt(m[1]), titol: (m[2] || 'CapÃ­tol ' + m[1]).trim(), text: part.trim() });
    });
  }
  chapters.sort((a, b) => a.numero - b.numero);
  return chapters;
}

function parseEstructura(text) {
  if (!text) return [];

  // Intent 1: JSON robust
  const data = parseJsonRobust(text);
  if (data && Array.isArray(data.capitols)) {
    // Desar dades globals a ESTAT
    ESTAT._arcGlobal      = data.arc_global || '';
    ESTAT._temesCentrals  = data.temes_centrals || [];
    ESTAT._prefiguracions = data.prefiguracions || [];
    ESTAT._corbaTensio    = data.corba_tensio || [];

    // ValidaciÃ³ de lÃ­mits 12-14 capÃ­tols
    if (data.capitols.length > 14) {
      console.warn(`Estructura amb ${data.capitols.length} capÃ­tols â€” retallant a 14`);
      while (data.capitols.length > 14) {
        const ultim = data.capitols.pop();
        const penultim = data.capitols[data.capitols.length - 1];
        penultim.resum = (penultim.resum || '') + ' ' + (ultim.resum || '');
        penultim.personatges = [...new Set([...(penultim.personatges || []), ...(ultim.personatges || [])])];
        penultim.numero = data.capitols.length;
      }
    }
    if (data.capitols.length < 12) {
      console.warn(`Estructura amb ${data.capitols.length} capÃ­tols â€” massa pocs, perÃ² continuem`);
    }

    // Guardar el nombre real de capÃ­tols i la justificaciÃ³
    ESTAT._nombreCapitols = data.capitols.length;
    ESTAT._justificacioCapitols = data.justificacio_capitols || '';

    return data.capitols.map(cap => ({
      numero:                cap.numero,
      titol:                 cap.titol,
      text:                  JSON.stringify(cap),
      personatges:           cap.personatges || [],
      fil:                   cap.fil_principal || '',
      toRitme:               cap.to_ritme || '',
      prefiguracionsPlantar: cap.prefiguracions_a_plantar || [],
      prefiguracionsRecollir:cap.prefiguracions_a_recollir || [],
      resum:                 cap.resum || '',
      connexioAnterior:      cap.connexio_anterior || '',
      connexioSeguent:       cap.connexio_seguent || ''
    }));
  }

  // Fallback: parser basat en regex
  return parseEstructuraLegacy(text);
}

function mostrarEstructura(text) {
  const cos = document.getElementById('estructura-cos');

  // Si tenim dades JSON estructurades, renderitzem de forma rica
  if (ESTAT._arcGlobal || ESTAT._corbaTensio.length > 0) {
    let html = '';

    // Arc global
    if (ESTAT._arcGlobal) {
      html += `<div class="world-bloc">
        <div class="world-bloc-titol">ğŸŒ Arc Global</div>
        <div class="world-bloc-desc">${escHtml(ESTAT._arcGlobal)}</div>
      </div>`;
    }

    // Corba de tensiÃ³ visual
    if (ESTAT._corbaTensio.length > 0) {
      const barres = ['â–','â–‚','â–ƒ','â–„','â–…','â–†','â–‡','â–ˆ'];
      const visualCorba = ESTAT._corbaTensio.map(t => {
        const nivell = Math.min(10, Math.max(1, t.nivell || 1));
        const bar    = barres[Math.floor((nivell - 1) / 10 * barres.length)] || 'â–„';
        return `<span title="Cap.${t.capitol}: ${t.tipus || ''} (${nivell}/10)">${bar}</span>`;
      }).join('');
      html += `<div class="world-bloc">
        <div class="world-bloc-titol">ğŸ“ˆ Corba de TensiÃ³</div>
        <div style="font-size:1.4rem;letter-spacing:2px;color:var(--accent2);margin:6px 0;">${visualCorba}</div>
        <div style="font-size:.75rem;color:var(--text2);">${ESTAT._corbaTensio.map(t => `C${t.capitol}:${t.nivell}`).join(' Â· ')}</div>
      </div>`;
    }

    // Prefiguracions
    if (ESTAT._prefiguracions.length > 0) {
      html += `<div class="world-bloc">
        <div class="world-bloc-titol">ğŸŒ± Prefiguracions planificades</div>
        <div class="world-bloc-desc">
          ${ESTAT._prefiguracions.map(p =>
            `<div style="padding:4px 0;border-bottom:1px solid var(--border);font-size:.85rem;">
              <span style="color:var(--accent2);">Cap.${p.plantada_capitol}â†’${p.resolucio_capitol}:</span> ${escHtml(p.element || '')}
            </div>`
          ).join('')}
        </div>
      </div>`;
    }

    // CapÃ­tols
    if (ESTAT._estructuraCapitols.length > 0) {
      html += `<div class="world-bloc"><div class="world-bloc-titol">ğŸ“š CapÃ­tols</div></div>`;
      html += ESTAT._estructuraCapitols.map(cap => {
        let detall = '';
        if (cap.resum)    detall += `<div style="margin-bottom:4px;">${escHtml(cap.resum)}</div>`;
        if (cap.fil)      detall += `<div style="font-size:.8rem;color:var(--text2);">Fil: ${escHtml(cap.fil)}</div>`;
        if (cap.toRitme)  detall += `<div style="font-size:.8rem;color:var(--text2);">To: ${escHtml(cap.toRitme)}</div>`;
        if (cap.personatges && cap.personatges.length > 0)
          detall += `<div style="font-size:.8rem;color:var(--text2);">Personatges: ${escHtml(cap.personatges.join(', '))}</div>`;
        return `<div class="world-bloc" style="border-left:3px solid var(--accent);padding-left:12px;">
          <div class="world-bloc-titol">CapÃ­tol ${cap.numero}: ${escHtml(cap.titol || '')}</div>
          <div class="world-bloc-desc">${detall}</div>
        </div>`;
      }).join('');
    }

    cos.innerHTML = html;
  } else {
    // RenderitzaciÃ³ text pla (legacy)
    const blocs = text.split(/\n\n+/).filter(b => b.trim().length > 0);
    cos.innerHTML = blocs.map(bloc => {
      const linies  = bloc.trim().split('\n');
      const primera = linies[0] || '';
      const esTitol = /^\*\*.+\*\*|^#{1,3}\s/.test(primera.trim());
      if (esTitol) {
        const titol = escHtml(primera.trim()).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/^#+\s/, '');
        const desc  = linies.slice(1).join('\n').trim();
        return `<div class="world-bloc">
          <div class="world-bloc-titol">${titol}</div>
          <div class="world-bloc-desc">${escHtml(desc)}</div>
        </div>`;
      }
      return `<div class="world-bloc"><div class="world-bloc-desc">${escHtml(bloc.trim())}</div></div>`;
    }).join('');
  }

  document.getElementById('estructura-wrap').classList.remove('hidden');
  const total = ESTAT._estructuraCapitols.length;
  if (total > 0) {
    const btn = document.getElementById('estructura-wrap').querySelector('.btn-primary');
    if (btn) btn.textContent = `ğŸ“– Escriure ${total} capÃ­tols`;
  }
  // Inicialitzar NKG amb les dades de l'estructura
  nkgInicialitzar();
  setTimeout(() => document.getElementById('fase-10').scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10.5: Escaleta per Escenes (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFaseEscaleta() {
  showCard('fase-10-5');
  showLoader('10-5');
  document.getElementById('loader-10-5-text').textContent = 'Opus generant escaleta per escenesâ€¦';
  try {
    const caps = ESTAT._estructuraCapitols;
    const BLOC = 4; // ReduÃ¯t de 5 a 4 per donar mÃ©s marge
    let totsResultats = [];
    for (let offset = 0; offset < caps.length; offset += BLOC) {
      const bloc = caps.slice(offset, offset + BLOC);
      document.getElementById('loader-10-5-text').textContent =
        `Generant escaleta: capÃ­tols ${offset + 1}-${Math.min(offset + BLOC, caps.length)} de ${caps.length}â€¦`;

      const res = await generarEscaletaBloc(bloc, offset, USER_CONFIG);
      const parsed = parseJsonRobust(res.response);

      if (parsed && parsed.escaletes) {
        totsResultats = totsResultats.concat(parsed.escaletes);

        // Retry: si falten escaletes d'aquest bloc
        const esperats = bloc.length;
        const rebuts = parsed.escaletes.length;
        if (rebuts < esperats) {
          console.warn(`Escaleta bloc incomplet: ${rebuts}/${esperats}. Completant capÃ­tols que falten...`);
          const capsFaltants = bloc.slice(rebuts);
          try {
            const retryRes = await generarEscaletaBloc(capsFaltants, offset + rebuts, USER_CONFIG);
            const retryParsed = parseJsonRobust(retryRes.response);
            if (retryParsed && retryParsed.escaletes) {
              totsResultats = totsResultats.concat(retryParsed.escaletes);
            }
          } catch (retryErr) {
            console.warn('Retry escaleta: ' + retryErr.message);
          }
        }
      } else {
        console.warn(`Escaleta: bloc ${offset + 1}-${offset + bloc.length} no parsejat. Retry sencer...`);
        try {
          const retryRes = await generarEscaletaBloc(bloc, offset, USER_CONFIG);
          const retryParsed = parseJsonRobust(retryRes.response);
          if (retryParsed && retryParsed.escaletes) {
            totsResultats = totsResultats.concat(retryParsed.escaletes);
          }
        } catch (retryErr) {
          console.warn('Retry escaleta sencer: ' + retryErr.message);
        }
      }
    }
    ESTAT._escaletes = totsResultats;
    hideLoader('10-5');
    mostrarEscaleta(totsResultats);
    document.getElementById('btn-fase11').classList.remove('hidden');
  } catch (e) {
    hideLoader('10-5');
    toast('Error generant escaleta: ' + e.message);
  }
}

function mostrarEscaleta(escaletes) {
  const div = document.getElementById('escaleta-result');
  if (!escaletes || escaletes.length === 0) { div.innerHTML = '<p>No s\'ha pogut generar l\'escaleta.</p>'; return; }
  let html = '<div style="max-height:400px;overflow-y:auto;">';
  escaletes.forEach(e => {
    html += `<details style="margin-bottom:8px;"><summary><strong>CapÃ­tol ${e.capitol}</strong>: ${escHtml(e.titol || '')}</summary><ol>`;
    (e.escenes || []).forEach(sc => {
      html += `<li><strong>${escHtml(sc.nom || '')}</strong> (${sc.paraules_objectiu || '?'} par.)<br>${escHtml(sc.funcio_narrativa || '')}</li>`;
    });
    html += '</ol></details>';
  });
  html += '</div>';
  div.innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 11: Escriptura de capÃ­tols (Sonnet + Registre)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function iniciarFase11() {
  if (ESTAT._estructuraCapitols.length === 0) {
    toast('No hi ha capÃ­tols a l\'estructura. Torna a generar-la.');
    return;
  }
  ESTAT.fase                = 11;
  ESTAT._capitolActual      = 0;
  ESTAT._capitols_generats  = [];
  ESTAT._revisioInstruccions= {};
  ESTAT.llibreRegistre      = { capitols: [], estat_personatges: [], fils_oberts: [], fils_tancats: [] };

  updateProgress(11);
  showCard('fase-11');
  renderLlistaCapitols();
  generarCapitol(0);
}

function renderLlistaCapitols() {
  const wrap  = document.getElementById('capitol-llista');
  const total = ESTAT._estructuraCapitols.length;
  document.getElementById('capitol-progress-text').textContent = `${total} capÃ­tols planificats`;

  wrap.innerHTML = ESTAT._estructuraCapitols.map((cap, i) => {
    const completat = i < ESTAT._capitolActual;
    const actiu     = i === ESTAT._capitolActual;
    const cls  = completat ? 'fet' : actiu ? 'actiu' : '';
    const ico  = completat ? 'âœ“'  : actiu  ? 'âœï¸'   : 'â—‹';
    const teText = !!(ESTAT._capitols_generats && ESTAT._capitols_generats[i]);
    const btnCopia = teText ? `<button class="capitol-copy" onclick="copiarCapitol(${i})" title="Copiar capÃ­tol">â˜</button>` : '';
    return `<div class="capitol-item ${cls}" id="cap-item-${i}">
      <span class="capitol-num">${ico}</span>
      <span class="capitol-titol">${escHtml(cap.titol || 'CapÃ­tol ' + (i + 1))}</span>
      ${btnCopia}
    </div>`;
  }).join('');
}

function copiarCapitol(idx) {
  const text = ESTAT._capitols_generats && ESTAT._capitols_generats[idx];
  if (!text) return;
  if (navigator.clipboard) {
    navigator.clipboard.writeText(text).then(() => toast(`CapÃ­tol ${idx + 1} copiat.`)).catch(() => {});
  } else {
    const ta = document.createElement('textarea');
    ta.value = text; document.body.appendChild(ta); ta.select();
    document.execCommand('copy'); document.body.removeChild(ta);
    toast(`CapÃ­tol ${idx + 1} copiat.`);
  }
}

function actualitzarEstatCapitol(idx, estat) {
  const el = document.getElementById('cap-item-' + idx);
  if (!el) return;
  el.className = 'capitol-item ' + estat;
  el.querySelector('.capitol-num').textContent = estat === 'fet' ? 'âœ“' : estat === 'actiu' ? 'âœï¸' : 'â—‹';
}

async function generarCapitol(idx) {
  if (idx >= ESTAT._estructuraCapitols.length) {
    document.getElementById('btn-control-arcs-wrap').classList.remove('hidden');
    iniciarRevisioGlobal();  // FASE 6: auto-trigger revisiÃ³ global
    return;
  }

  ESTAT._capitolActual = idx;
  renderLlistaCapitols();  // refresca tota la llista
  actualitzarEstatCapitol(idx, 'actiu');

  const cap   = ESTAT._estructuraCapitols[idx];
  const titol = cap.titol || 'CapÃ­tol ' + (idx + 1);

  document.getElementById('capitol-actual-wrap').classList.add('hidden');
  document.getElementById('revisio-panel').classList.add('hidden');
  document.getElementById('btn-control-arcs-wrap').classList.add('hidden');
  showLoader(11);
  document.getElementById('loader-11-text').textContent =
    `ğŸŸ£ Sonnet escrivint el CapÃ­tol ${idx + 1} â€” "${titol}"â€¦`;

  try {
    const res = await generarCapitolNKG(idx, USER_CONFIG);
    ESTAT._capitols_generats[idx] = res.response;
    hideLoader(11);
    mostrarCapitol(idx, res.response);

    // SISTEMA 1: actualitzar bÃ­blia i registre (no bloquejants)
    actualitzarBiblia(res.response, idx, USER_CONFIG).catch(err =>
      console.warn('BÃ­blia async:', err.message)
    );
    actualitzarLlibreRegistreBackground(res.response, idx).catch(err =>
      console.warn('Registre async:', err.message)
    );

    // SISTEMA 4: checkpoint cada 3 capÃ­tols
    const esCheckpoint = (idx + 1) % 3 === 0 && idx + 1 < ESTAT._estructuraCapitols.length;
    if (esCheckpoint) {
      await executarCheckpoint(idx, USER_CONFIG);
    }

    // CompressiÃ³ de memÃ²ria cada 5 capÃ­tols
    const esCompressio = (idx + 1) % 5 === 0 && idx + 1 < ESTAT._estructuraCapitols.length;
    if (esCompressio) {
      document.getElementById('loader-11-text').textContent = 'ğŸ”µ Opus comprimint memÃ²ria narrativaâ€¦';
      await comprimirMemoria(idx + 1, USER_CONFIG);
    }

    mostrarAccionsCapitol(idx, res.response);
  } catch (err) {
    hideLoader(11);
    toast('Error Sonnet: ' + err.message);
  }
}

function mostrarCapitol(idx, text) {
  const cap   = ESTAT._estructuraCapitols[idx];
  const titol = cap ? cap.titol || 'CapÃ­tol ' + (idx + 1) : 'CapÃ­tol ' + (idx + 1);

  document.getElementById('capitol-actual-titol').textContent = `CapÃ­tol ${idx + 1}: ${titol}`;
  const cos  = document.getElementById('capitol-actual-cos');
  const pars = text.split(/\n\n+/).filter(p => p.trim().length > 0);
  cos.innerHTML = pars.map(p => `<p>${escHtml(p.trim())}</p>`).join('');

  const wc = compteParaules(text);
  document.getElementById('capitol-actual-wordcount').textContent = `${wc.toLocaleString('ca')} paraules`;
  document.getElementById('capitol-actual-wrap').classList.remove('hidden');

  setTimeout(() => document.getElementById('fase-11').scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
}

function mostrarAccionsCapitol(idx, text) {
  const accions = document.getElementById('capitol-accions');
  const isLast  = idx >= ESTAT._estructuraCapitols.length - 1;

  if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
    accions.innerHTML = `<span style="color:var(--text2);font-size:.85rem;">ğŸ”µ Opus revisant el capÃ­tolâ€¦</span>`;
    revisarCapitolAmbOpus(text, idx, isLast);
  } else {
    // Si Ã©s l'Ãºltim capÃ­tol, no mostrem "Control d'Arcs" â€” ho gestiona la revisiÃ³ global
    if (isLast) {
      accions.innerHTML = `
        <button class="btn btn-secondary" onclick="iniciarRevisioManual(${idx})">ğŸ” Revisar amb Opus</button>
      `;
      actualitzarEstatCapitol(idx, 'fet');
    } else {
      accions.innerHTML = `
        <button class="btn btn-secondary" onclick="iniciarRevisioManual(${idx})">ğŸ” Revisar amb Opus</button>
        <button class="btn btn-primary" onclick="generarCapitol(${idx + 1})">â¡ï¸ CapÃ­tol ${idx + 2}</button>
      `;
      actualitzarEstatCapitol(idx, 'fet');
    }
  }
}

function iniciarRevisioManual(idx) {
  const text = ESTAT._capitols_generats[idx];
  if (!text) return;
  const isLast = idx >= ESTAT._estructuraCapitols.length - 1;
  document.getElementById('capitol-accions').innerHTML =
    `<span style="color:var(--text2);font-size:.85rem;">ğŸ”µ Opus revisant el capÃ­tolâ€¦</span>`;
  revisarCapitolAmbOpus(text, idx, isLast);
}

async function revisarCapitolAmbOpus(textCapitol, idx, isLast) {
  try {
    const res    = await revisarCapitol(textCapitol, idx, USER_CONFIG);
    const revisat = parseJsonRobust(res.response);
    mostrarRevisioCapitol(revisat, idx, isLast);
  } catch (err) {
    mostrarAccionsCapitolSimple(idx, isLast);
    toast('RevisiÃ³ Opus: ' + err.message);
  }
}

function mostrarRevisioCapitol(revisat, idx, isLast) {
  const panel   = document.getElementById('revisio-panel');
  const accions = document.getElementById('capitol-accions');

  if (!revisat) { mostrarAccionsCapitolSimple(idx, isLast); return; }

  const puntuacio   = revisat.puntuacio !== undefined ? revisat.puntuacio : '?';
  const ok          = revisat.ok_per_continuar !== false;
  const problemes   = Array.isArray(revisat.problemes) ? revisat.problemes : [];
  const instruccions= revisat.instruccions_correccio || '';
  const color = typeof puntuacio === 'number'
    ? (puntuacio >= 8 ? 'var(--success)' : puntuacio >= 6 ? 'var(--warning)' : '#f87171')
    : 'var(--text2)';

  panel.innerHTML = `
    <div style="display:flex;align-items:center;gap:16px;margin-bottom:12px;">
      <div style="font-size:1.8rem;font-weight:700;color:${color};">${puntuacio}<span style="font-size:1rem;color:var(--text2);">/10</span></div>
      <div>
        <div style="font-weight:600;color:var(--text);">RevisiÃ³ Opus</div>
        <div style="font-size:.78rem;color:var(--text2);">${ok ? 'âœ“ Adequat per continuar' : 'âš  Recomana correcciÃ³'}</div>
      </div>
    </div>
    ${problemes.length > 0 ? `<div style="font-size:.83rem;margin-bottom:10px;">
      <strong style="color:var(--text2);">Observacions:</strong>
      <ul style="margin:6px 0 0 16px;color:var(--text);line-height:1.7;">
        ${problemes.map(p => `<li>${escHtml(String(p))}</li>`).join('')}
      </ul></div>` : ''}
    ${instruccions && !ok ? `<div style="font-size:.8rem;color:var(--text2);margin-top:8px;padding:10px 14px;background:var(--surface);border-radius:6px;border-left:2px solid var(--warning);">
      <strong>Instruccions:</strong> ${escHtml(instruccions)}</div>` : ''}`;

  // Hook Review
  const hook = revisat.hook_review;
  if (hook) {
    const cHook = (p) => p >= 7 ? 'var(--success)' : p >= 5 ? 'var(--warning)' : '#f87171';
    panel.innerHTML += `
      <div style="margin-top:14px;padding-top:14px;border-top:1px solid var(--border);">
        <div style="font-weight:600;font-size:.85rem;color:var(--accent2);margin-bottom:8px;">ğŸ“ Enganxament</div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:.8rem;">
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Obertura:</span> <strong style="color:${cHook(hook.obertura_puntuacio)};">${hook.obertura_puntuacio || '?'}/10</strong>
          </div>
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Cliffhanger:</span> <strong style="color:${cHook(hook.cliffhanger_puntuacio)};">${hook.cliffhanger_puntuacio || '?'}/10</strong>
          </div>
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Ritme:</span> <strong style="color:${cHook(hook.ritme_intern_puntuacio)};">${hook.ritme_intern_puntuacio || '?'}/10</strong>
          </div>
          <div style="padding:8px 10px;background:var(--surface);border-radius:6px;">
            <span style="color:var(--text2);">Promesa:</span> <span style="font-size:.75rem;">${escHtml(hook.promesa_narrativa || 'N/A')}</span>
          </div>
        </div>
      </div>`;
  }

  panel.classList.remove('hidden');

  // Golden passage
  if (revisat.golden_passage && revisat.puntuacio >= 7) {
    if (!ESTAT._goldenPassage || revisat.puntuacio > 7) {
      ESTAT._goldenPassage = revisat.golden_passage;
      ESTAT._goldenPassageCapitol = idx;
    }
  }

  const nextLabel  = isLast ? '' : `â¡ï¸ CapÃ­tol ${idx + 2}`;
  const nextAction = isLast ? '' : `generarCapitol(${idx + 1})`;

  // ğŸ”´ CORRECCIÃ“: GestiÃ³ automatitzada real del flux
  if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
    if (!ok && instruccions) {
      accions.innerHTML = `<span style="color:var(--text2);font-size:.85rem;">ğŸ”´ Opus demana correccions. Sonnet reescrivint automÃ ticament...</span>`;
      setTimeout(() => reescriureCapitol(idx), 1500); // Dona 1.5s per llegir el diagnÃ²stic
    } else {
      accions.innerHTML = `<span style="color:var(--success);font-size:.85rem;">âœ… CapÃ­tol aprovat. AvanÃ§ant automÃ ticament...</span>`;
      if (!isLast) {
        setTimeout(() => generarCapitol(idx + 1), 2000); // Dona 2s abans de saltar
      } else {
        generarCapitol(ESTAT._estructuraCapitols.length);
      }
    }
  } else {
    // Mode Manual
    if (!ok && instruccions) {
      accions.innerHTML = `
        <button class="btn btn-secondary" onclick="reescriureCapitol(${idx})">âœï¸ Reescriure (Sonnet)</button>
        ${isLast ? '' : `<button class="btn btn-primary" onclick="${nextAction}">${nextLabel}</button>`}`;
    } else {
      accions.innerHTML = isLast ? '' : `<button class="btn btn-primary" onclick="${nextAction}">${nextLabel}</button>`;
    }
    if (isLast) generarCapitol(ESTAT._estructuraCapitols.length);

    if (hook && hook.cliffhanger_puntuacio < 6 && revisat.instruccions_cliffhanger) {
      const btnCH = document.createElement('button');
      btnCH.className = 'btn btn-secondary';
      btnCH.textContent = 'ğŸ£ Millorar cliffhanger';
      btnCH.onclick = () => millorarCliffhanger(idx, revisat.instruccions_cliffhanger);
      accions.appendChild(btnCH);
    }
  }

  actualitzarEstatCapitol(idx, 'fet');
}

function mostrarAccionsCapitolSimple(idx, isLast) {
  if (isLast) {
    document.getElementById('capitol-accions').innerHTML = '';
    generarCapitol(ESTAT._estructuraCapitols.length);
  } else {
    // ğŸ”´ CORRECCIÃ“: Si Ã©s automÃ tic, no esperem el clic de l'usuari
    if (USER_CONFIG && USER_CONFIG.fluxAutomatic) {
      document.getElementById('capitol-accions').innerHTML = `<span style="color:var(--text2);font-size:.85rem;">AvanÃ§ant automÃ ticament al segÃ¼ent capÃ­tol...</span>`;
      setTimeout(() => generarCapitol(idx + 1), 1500);
    } else {
      document.getElementById('capitol-accions').innerHTML =
        `<button class="btn btn-primary" onclick="generarCapitol(${idx + 1})">â¡ï¸ CapÃ­tol ${idx + 2}</button>`;
    }
  }
  actualitzarEstatCapitol(idx, 'fet');
}

async function reescriureCapitol(idx) {
  const instruccions = ESTAT._revisioInstruccions[idx] || '';
  document.getElementById('capitol-actual-wrap').classList.add('hidden');
  document.getElementById('revisio-panel').classList.add('hidden');
  showLoader(11);
  document.getElementById('loader-11-text').textContent = 'ğŸŸ£ Sonnet aplicant les correccionsâ€¦';

  try {
    const res = await reescriureCapitolAmbInstruccions(idx, instruccions, USER_CONFIG);
    ESTAT._capitols_generats[idx] = res.response;
    hideLoader(11);
    mostrarCapitol(idx, res.response);
    const isLast = idx >= ESTAT._estructuraCapitols.length - 1;
    mostrarAccionsCapitolSimple(idx, isLast);
    toast('CapÃ­tol reescrit.');
  } catch (err) {
    hideLoader(11);
    document.getElementById('capitol-actual-wrap').classList.remove('hidden');
    toast('Error Sonnet: ' + err.message);
  }
}

// FASE 8: registre sÃ­ncron amb retry â€” s'awaita des de generarCapitol
async function actualitzarLlibreRegistreBackgroundLegacy(textCapitol, idx) {
  let intents = 0;
  while (intents < 2) {
    try {
      const res   = await actualitzarRegistre(textCapitol, idx, USER_CONFIG);
      const dades = parseJsonRobust(res.response);
      if (dades) {
        if (!ESTAT.llibreRegistre.capitols) ESTAT.llibreRegistre.capitols = [];
        ESTAT.llibreRegistre.capitols[idx] = dades;

        if (Array.isArray(dades.estat_personatges) && dades.estat_personatges.length > 0)
          ESTAT.llibreRegistre.estat_personatges = dades.estat_personatges;

        if (Array.isArray(dades.fils_tancats) && dades.fils_tancats.length > 0) {
          const tancats = new Set(dades.fils_tancats);
          ESTAT.llibreRegistre.fils_oberts  = (ESTAT.llibreRegistre.fils_oberts  || []).filter(f => !tancats.has(f));
          ESTAT.llibreRegistre.fils_tancats = [...new Set([...(ESTAT.llibreRegistre.fils_tancats || []), ...dades.fils_tancats])];
        }
        if (Array.isArray(dades.fils_oberts) && dades.fils_oberts.length > 0) {
          const existents = new Set(ESTAT.llibreRegistre.fils_oberts || []);
          dades.fils_oberts.forEach(f => existents.add(f));
          ESTAT.llibreRegistre.fils_oberts = [...existents];
        }
        return;  // Ã¨xit
      }
      intents++;
    } catch (err) {
      console.warn(`Registre intent ${intents + 1}:`, err.message);
      intents++;
    }
  }
  console.warn('Registre: no s\'ha pogut actualitzar desprÃ©s de 2 intents');
}

async function actualitzarLlibreRegistreBackground(textCapitol, idx) {
  return await actualitzarLlibreRegistreBackgroundLegacy(textCapitol, idx);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 12: Control d'Arcs (Opus) + EpÃ­leg (Sonnet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarFase12() {
  ESTAT.fase = 12;
  updateProgress(12);
  showCard('fase-12');
  document.getElementById('arcs-result').classList.add('hidden');
  document.getElementById('epileg-loader-wrap').classList.add('hidden');
  document.getElementById('epileg-cos').classList.add('hidden');
  showLoader(12);

  try {
    const res = await controlArcsNovella(USER_CONFIG);
    ESTAT._controlArcs = res.response;
    hideLoader(12);

    const arcosCos = document.getElementById('arcs-cos');
    const blocs = res.response.split(/\n\n+/).filter(b => b.trim().length > 0);
    arcosCos.innerHTML = `<div class="worldbuilding-result">` + blocs.map(bloc => {
      const linies  = bloc.trim().split('\n');
      const primera = linies[0] || '';
      const esTitol = /^\*\*.+\*\*|^#{1,3}\s/.test(primera.trim());
      if (esTitol) {
        const titol = escHtml(primera.trim()).replace(/\*\*(.+?)\*\*/g, '$1').replace(/^#+\s/, '');
        const desc  = linies.slice(1).join('\n').trim();
        return `<div class="world-bloc">
          <div class="world-bloc-titol">${titol}</div>
          <div class="world-bloc-desc">${escHtml(desc)}</div>
        </div>`;
      }
      return `<div class="world-bloc"><div class="world-bloc-desc">${escHtml(bloc.trim())}</div></div>`;
    }).join('') + `</div>`;

    // Si Opus menciona epÃ­leg, mostra el botÃ³
    if (/epÃ­leg|epilog/i.test(res.response)) {
      document.getElementById('btn-epileg').classList.remove('hidden');
    }
    document.getElementById('arcs-result').classList.remove('hidden');
    setTimeout(() => document.getElementById('fase-12').scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
  } catch (err) {
    hideLoader(12);
    toast('Error Opus: ' + err.message);
  }
}

async function escriureEpileg() {
  document.getElementById('btn-epileg').disabled = true;
  document.getElementById('epileg-loader-wrap').classList.remove('hidden');

  try {
    const res = await generarEpileg(ESTAT._controlArcs, USER_CONFIG);
    ESTAT.epileg = res.response;
    document.getElementById('epileg-loader-wrap').classList.add('hidden');

    const epilegText = document.getElementById('epileg-text');
    const pars = res.response.split(/\n\n+/).filter(p => p.trim().length > 0);
    epilegText.innerHTML = pars.map(p => `<p>${escHtml(p.trim())}</p>`).join('');
    document.getElementById('epileg-cos').classList.remove('hidden');
    toast('EpÃ­leg escrit per Sonnet.');
  } catch (err) {
    document.getElementById('epileg-loader-wrap').classList.add('hidden');
    document.getElementById('btn-epileg').disabled = false;
    toast('Error Sonnet: ' + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MODAL: Llibre de Registre
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function obrirLlibreRegistre() {
  const cos = document.getElementById('registre-cos');
  const reg = ESTAT.llibreRegistre;
  const capsFets = (reg.capitols || []).filter(c => c);

  if (capsFets.length === 0) {
    cos.innerHTML = `<p style="color:var(--text2);font-size:.9rem;padding:20px 0;">El registre s'actualitzarÃ  automÃ ticament quan es generin capÃ­tols.</p>`;
  } else {
    const pers       = reg.estat_personatges || [];
    const filsOberts = reg.fils_oberts       || [];
    const filsTancat = reg.fils_tancats      || [];
    cos.innerHTML = `
      <div style="margin-bottom:22px;">
        <div class="world-bloc-titol" style="margin-bottom:10px;">Personatges actuals</div>
        ${pers.length === 0
          ? `<p style="color:var(--text2);font-size:.85rem;">Pendent de procesar.</p>`
          : pers.map(p => `<div style="padding:8px 14px;background:var(--surface2);border-radius:8px;margin-bottom:6px;font-size:.86rem;">
              <strong>${escHtml(p.nom || '')}</strong>
              <span style="color:var(--text2);"> â€” ${escHtml(p.ubicacio || '')} Â· ${escHtml(p.estat_actual || '')}</span>
            </div>`).join('')}
      </div>
      ${filsOberts.length > 0 ? `<div style="margin-bottom:18px;">
        <div class="world-bloc-titol" style="margin-bottom:8px;">Fils oberts</div>
        ${filsOberts.map(f => `<div style="padding:5px 12px;border-left:2px solid var(--warning);margin-bottom:5px;font-size:.84rem;">${escHtml(f)}</div>`).join('')}
      </div>` : ''}
      ${filsTancat.length > 0 ? `<div style="margin-bottom:18px;">
        <div class="world-bloc-titol" style="margin-bottom:8px;">Fils tancats</div>
        ${filsTancat.map(f => `<div style="padding:5px 12px;border-left:2px solid var(--success);margin-bottom:5px;font-size:.84rem;">${escHtml(f)}</div>`).join('')}
      </div>` : ''}
      <div>
        <div class="world-bloc-titol" style="margin-bottom:10px;">Resums per capÃ­tol</div>
        ${(reg.capitols || []).map((c, i) => c ? `
          <div style="padding:10px 14px;background:var(--surface2);border-radius:8px;margin-bottom:8px;">
            <div style="font-weight:600;font-size:.82rem;color:var(--accent2);margin-bottom:4px;">CapÃ­tol ${i + 1}</div>
            <div style="font-size:.84rem;color:var(--text);line-height:1.6;">${escHtml(c.resum_capitol || '(sense resum)')}</div>
          </div>` : '').join('')}
      </div>`;
  }
  document.getElementById('modal-registre').classList.remove('hidden');
}

function tancarModalRegistre() {
  document.getElementById('modal-registre').classList.add('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 6: RevisiÃ³ Global (Opus) â€” UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function iniciarRevisioGlobal() {
  const loaderEl  = document.getElementById('revisio-global-loader');
  const resultEl  = document.getElementById('revisio-global-result');
  const reescrEl  = document.getElementById('revisio-global-reescriptures');
  const btnControl= document.getElementById('btn-control-arcs');

  loaderEl.classList.remove('hidden');
  resultEl.classList.add('hidden');
  reescrEl.innerHTML = '';
  btnControl.classList.add('hidden');

  try {
    const res     = await revisioGlobalOpusAPI(USER_CONFIG);
    const dades   = parseJsonRobust(res.response);
    ESTAT._revisioGlobal = dades;
    loaderEl.classList.add('hidden');
    const repeticions = detectarRepeticions();
    if (repeticions) mostrarRepeticions(repeticions);
    mostrarResultatRevisioGlobal(dades);
  } catch (err) {
    loaderEl.classList.add('hidden');
    resultEl.innerHTML = `<div style="padding:12px;background:var(--surface2);border-radius:8px;color:var(--text2);font-size:.85rem;">RevisiÃ³ global no disponible: ${escHtml(err.message)}</div>`;
    resultEl.classList.remove('hidden');
    btnControl.classList.remove('hidden');
    toast('RevisiÃ³ global: ' + err.message);
  }
}

function mostrarResultatRevisioGlobal(dades) {
  const resultEl = document.getElementById('revisio-global-result');
  const reescrEl = document.getElementById('revisio-global-reescriptures');
  const btnControl= document.getElementById('btn-control-arcs');

  if (!dades) {
    btnControl.classList.remove('hidden');
    return;
  }

  const puntuacio = dades.puntuacio_global !== undefined ? dades.puntuacio_global : '?';
  const color = typeof puntuacio === 'number'
    ? (puntuacio >= 8 ? 'var(--success)' : puntuacio >= 6 ? 'var(--warning)' : '#f87171')
    : 'var(--text2)';

  const problemes = Array.isArray(dades.problemes) ? dades.problemes : [];
  const capitolsReescriure = Array.isArray(dades.capitols_a_reescriure) ? dades.capitols_a_reescriure : [];
  const prefsPendents = Array.isArray(dades.prefiguracions_pendents) ? dades.prefiguracions_pendents : [];

  const problemesHtml = problemes.length > 0
    ? `<div style="margin-top:10px;">
        <div style="font-size:.78rem;font-weight:700;text-transform:uppercase;letter-spacing:.06em;color:var(--text2);margin-bottom:6px;">Problemes detectats:</div>
        ${problemes.map(p => {
          const grav = p.gravetat === 'alta' ? '#f87171' : p.gravetat === 'mitja' ? 'var(--warning)' : 'var(--text2)';
          return `<div style="padding:7px 12px;border-left:2px solid ${grav};margin-bottom:5px;font-size:.83rem;">
            <strong style="color:var(--text);">Cap. ${p.capitol || '?'} [${escHtml(p.tipus || '')}]:</strong> ${escHtml(p.descripcio || '')}
          </div>`;
        }).join('')}
      </div>` : '';

  const prefsHtml = prefsPendents.length > 0
    ? `<div style="margin-top:10px;">
        <div style="font-size:.78rem;font-weight:700;text-transform:uppercase;letter-spacing:.06em;color:var(--text2);margin-bottom:6px;">Prefiguracions pendents:</div>
        ${prefsPendents.map(p => `<div style="padding:5px 12px;border-left:2px solid var(--warning);margin-bottom:4px;font-size:.82rem;">${escHtml(p)}</div>`).join('')}
      </div>` : '';

  resultEl.innerHTML = `
    <div style="background:var(--surface2);border:1px solid var(--border);border-radius:10px;padding:18px 22px;">
      <div style="display:flex;align-items:center;gap:16px;margin-bottom:12px;">
        <div style="font-size:1.8rem;font-weight:700;color:${color};">${puntuacio}<span style="font-size:1rem;color:var(--text2);">/10</span></div>
        <div>
          <div style="font-weight:600;color:var(--text);">RevisiÃ³ Global Opus</div>
          <div style="font-size:.78rem;color:var(--text2);">${dades.veu_consistent ? 'âœ“ Veu consistent' : 'âš  InconsistÃ¨ncies de veu detectades'}</div>
        </div>
      </div>
      ${dades.veredicte ? `<div style="font-size:.88rem;color:var(--text);line-height:1.65;padding:10px 14px;background:var(--surface);border-radius:6px;margin-bottom:8px;">${escHtml(dades.veredicte)}</div>` : ''}
      ${problemesHtml}
      ${prefsHtml}
    </div>`;
  resultEl.classList.remove('hidden');

  // Botons de reescriptura per als capÃ­tols problemÃ tics
  if (capitolsReescriure.length > 0 && dades.instruccions_reescriptura) {
    reescrEl.innerHTML = `
      <div style="width:100%;font-size:.82rem;color:var(--text2);margin-bottom:6px;">Opus suggereix reescriure els capÃ­tols:</div>
      ${capitolsReescriure.map(numCap => {
        const idx = numCap - 1;
        const instruccions = dades.instruccions_reescriptura[String(numCap)] || '';
        return `<button class="btn btn-secondary" onclick="reescriureCapitolGlobal(${idx}, ${escHtml(JSON.stringify(instruccions))})">
          âœï¸ Reescriure Cap. ${numCap}
        </button>`;
      }).join('')}`;
  }

  btnControl.classList.remove('hidden');
}

async function reescriureCapitolGlobal(idx, instruccions) {
  if (!instruccions || !ESTAT._capitols_generats[idx]) return;
  // Reutilitzem la funciÃ³ existent
  ESTAT._revisioInstruccions = ESTAT._revisioInstruccions || {};
  ESTAT._revisioInstruccions[idx] = instruccions;
  await reescriureCapitol(idx);
}

// â”€â”€â”€ SISTEMA 1: BÃ­blia Narrativa â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function obrirBiblia() {
  const modal = document.getElementById('modal-biblia');
  const cos   = document.getElementById('biblia-cos');
  const b     = ESTAT.bibliaNarrativa;

  let html = '';
  if (b.regles_mon && b.regles_mon.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸŒ Regles del MÃ³n</h4><ul style="padding-left:18px">${b.regles_mon.map(r => `<li style="margin-bottom:4px">${r}</li>`).join('')}</ul>`;
  }
  if (b.llocs_importants && b.llocs_importants.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ“ Llocs Importants</h4><ul style="padding-left:18px">${b.llocs_importants.map(l => `<li style="margin-bottom:4px"><strong>${l.nom}</strong>: ${l.descripcio}</li>`).join('')}</ul>`;
  }
  if (b.objectes_clau && b.objectes_clau.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ”‘ Objectes Clau</h4><ul style="padding-left:18px">${b.objectes_clau.map(o => `<li style="margin-bottom:4px"><strong>${o.nom}</strong>: ${o.significat}</li>`).join('')}</ul>`;
  }
  if (b.fitxes_personatges && b.fitxes_personatges.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ‘¤ Personatges</h4>`;
    b.fitxes_personatges.forEach(p => {
      html += `<div style="background:var(--surface2);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:10px">
        <strong style="color:var(--accent)">${p.nom}</strong>
        ${p.estat_actual  ? `<div style="font-size:.85rem;color:var(--text2);margin-top:4px">Estat: ${p.estat_actual}</div>` : ''}
        ${p.motivacions   ? `<div style="font-size:.85rem;margin-top:4px">Motivacions: ${p.motivacions}</div>` : ''}
        ${p.secrets       ? `<div style="font-size:.85rem;color:var(--warning);margin-top:4px">Secrets: ${p.secrets}</div>` : ''}
      </div>`;
    });
  }
  if (b.fets_canonics && b.fets_canonics.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:14px 0 8px">ğŸ“œ Fets CanÃ²nics</h4><ul style="padding-left:18px">${b.fets_canonics.slice(-10).map(f => `<li style="margin-bottom:4px">${f}</li>`).join('')}</ul>`;
  }
  if (!html) {
    html = '<p style="color:var(--text2);text-align:center;padding:24px">La bÃ­blia narrativa encara no s\'ha inicialitzat.</p>';
  }
  cos.innerHTML = html;
  modal.classList.remove('hidden');
}

function tancarModalBiblia() {
  document.getElementById('modal-biblia').classList.add('hidden');
}

function aplicarCanvisBiblia(canvis) {
  if (!canvis) return;
  const b = ESTAT.bibliaNarrativa;
  if (canvis.nous_fets_canonics && canvis.nous_fets_canonics.length > 0) {
    b.fets_canonics = (b.fets_canonics || []).concat(canvis.nous_fets_canonics);
  }
  if (canvis.actualitzar_personatges && canvis.actualitzar_personatges.length > 0) {
    canvis.actualitzar_personatges.forEach(upd => {
      const fitxa = (b.fitxes_personatges || []).find(f => f.nom === upd.nom);
      if (fitxa) {
        if (upd.nou_estat)    fitxa.estat_actual = upd.nou_estat;
        if (upd.nous_secrets) fitxa.secrets      = upd.nous_secrets;
        if (upd.motivacions)  fitxa.motivacions  = upd.motivacions;
      } else if (upd.nom) {
        b.fitxes_personatges = b.fitxes_personatges || [];
        b.fitxes_personatges.push({ nom: upd.nom, estat_actual: upd.nou_estat, motivacions: upd.motivacions, secrets: upd.nous_secrets });
      }
    });
  }
  if (canvis.nous_llocs && canvis.nous_llocs.length > 0) {
    b.llocs_importants = (b.llocs_importants || []).concat(canvis.nous_llocs);
  }
  if (canvis.nous_objectes && canvis.nous_objectes.length > 0) {
    b.objectes_clau = (b.objectes_clau || []).concat(canvis.nous_objectes);
  }
}

// â”€â”€â”€ SISTEMA 2: Fase de Trames â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function iniciarFaseTrames() {
  showCard('fase-9-5');
  updateProgress(9.5);
  showLoader('9-5');
  document.getElementById('trames-result').classList.add('hidden');
  try {
    const res   = await generarTrames(USER_CONFIG);
    const dades = parseJsonRobust(res.response);
    if (dades) {
      ESTAT.trames.trama_principal  = dades.trama_principal  || null;
      ESTAT.trames.subtrames        = dades.subtrames        || [];
      ESTAT.trames.mapa_entrellacat = dades.mapa_entrellacat || [];

      // Retry: si el mapa estÃ  incomplet, completar-lo per separat
      const capsEsperats = ESTAT._nombreCapitols || 12;
      if (!dades.mapa_entrellacat || dades.mapa_entrellacat.length < capsEsperats) {
        console.warn(`Mapa entrellaÃ§at incomplet: ${(dades.mapa_entrellacat||[]).length}/${capsEsperats}. Regenerant...`);
        document.getElementById('loader-9-5-text').textContent = 'ğŸ”µ Completant mapa de tramesâ€¦';
        try {
          const mapaRes = await completarMapaTrames(dades, capsEsperats, USER_CONFIG);
          const mapaDades = parseJsonRobust(mapaRes.response);
          if (mapaDades && mapaDades.mapa_entrellacat && mapaDades.mapa_entrellacat.length >= capsEsperats) {
            ESTAT.trames.mapa_entrellacat = mapaDades.mapa_entrellacat;
            dades.mapa_entrellacat = mapaDades.mapa_entrellacat;
          }
        } catch (retryErr) {
          console.warn('Retry mapa trames: ' + retryErr.message);
        }
      }
    }
    mostrarTrames(res.response, dades);
  } catch (err) {
    hideLoader('9-5');
    alert('Error generant les trames: ' + err.message);
  }
}

function mostrarTrames(textOriginal, dades) {
  hideLoader('9-5');
  const result = document.getElementById('trames-result');
  const cos    = document.getElementById('trames-cos');
  if (!dades) {
    cos.innerHTML = `<pre style="white-space:pre-wrap;font-size:.85rem;color:var(--text2)">${textOriginal}</pre>`;
    result.classList.remove('hidden');
    return;
  }
  let html = '';
  if (dades.trama_principal) {
    const tp = dades.trama_principal;
    html += `<div style="background:var(--surface2);border:1px solid var(--accent);border-radius:10px;padding:16px;margin-bottom:16px">
      <div style="font-weight:700;color:var(--accent2);margin-bottom:8px">ğŸ¯ Trama Principal</div>
      <div style="font-size:.95rem">${tp.descripcio || tp}</div>
      ${tp.conflicte_central ? `<div style="font-size:.85rem;color:var(--text2);margin-top:6px">Conflicte: ${tp.conflicte_central}</div>` : ''}
      ${tp.arc_protagonista  ? `<div style="font-size:.85rem;color:var(--text2);margin-top:4px">Arc: ${tp.arc_protagonista}</div>`   : ''}
    </div>`;
  }
  if (dades.subtrames && dades.subtrames.length > 0) {
    html += `<div style="font-weight:600;color:var(--accent2);margin-bottom:10px">ğŸ•¸ï¸ Subtrames (${dades.subtrames.length})</div>`;
    dades.subtrames.forEach((st, i) => {
      html += `<div style="background:var(--surface2);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:10px">
        <div style="font-weight:600;color:var(--text)">${i + 1}. ${st.nom || 'Subtrama ' + (i + 1)}</div>
        <div style="font-size:.88rem;color:var(--text2);margin-top:4px">${st.descripcio || ''}</div>
        ${st.personatges_implicats ? `<div style="font-size:.83rem;margin-top:6px;color:var(--accent2)">Personatges: ${Array.isArray(st.personatges_implicats) ? st.personatges_implicats.join(', ') : st.personatges_implicats}</div>` : ''}
        ${st.com_entrellaÃ§a ? `<div style="font-size:.83rem;margin-top:4px;color:var(--text2)">Trama principal: ${st.com_entrellaÃ§a}</div>` : ''}
      </div>`;
    });
  }
  if (dades.mapa_entrellacat && dades.mapa_entrellacat.length > 0) {
    html += `<div style="font-weight:600;color:var(--accent2);margin:12px 0 8px">ğŸ—ºï¸ Mapa d'EntrellaÃ§at</div>
    <div style="font-size:.85rem;color:var(--text2)">`;
    dades.mapa_entrellacat.forEach(m => {
      html += `<div style="margin-bottom:4px">Cap. ${m.capitol}: ${m.trames_actives ? m.trames_actives.join(' + ') : (m.notes || '')}</div>`;
    });
    html += '</div>';
  }
  cos.innerHTML = html || `<pre style="white-space:pre-wrap;font-size:.85rem">${textOriginal}</pre>`;
  result.classList.remove('hidden');
}

// â”€â”€â”€ SISTEMA 4: Checkpoint de coherÃ¨ncia â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function mostrarCheckpoint(dades, idx) {
  if (!dades) return;
  const listId   = 'capitols-list';
  const container = document.getElementById(listId) || document.body;
  const panel    = document.createElement('div');
  panel.style.cssText = 'background:var(--surface2);border:2px solid var(--warning);border-radius:12px;padding:18px;margin:16px 0';
  const punts  = dades.puntuacio_coherencia;
  const color  = punts >= 7 ? 'var(--success)' : (punts >= 5 ? 'var(--warning)' : '#f87171');
  panel.innerHTML = `
    <div style="font-weight:700;color:var(--warning);margin-bottom:10px">ğŸ” Checkpoint de CoherÃ¨ncia â€” Cap. ${idx + 1}</div>
    <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px">
      <div style="font-size:2rem;font-weight:700;color:${color}">${punts || '?'}/10</div>
      <div style="font-size:.9rem;color:var(--text2)">${dades.valoracio_general || ''}</div>
    </div>
    ${dades.problemes_detectats && dades.problemes_detectats.length > 0
      ? `<div style="font-weight:600;color:#f87171;margin-bottom:6px">âš ï¸ Problemes detectats</div>
         <ul style="padding-left:18px;font-size:.88rem;color:var(--text2)">${dades.problemes_detectats.map(p => `<li style="margin-bottom:4px">${p}</li>`).join('')}</ul>`
      : '<div style="color:var(--success);font-size:.9rem">âœ“ CoherÃ¨ncia correcta fins ara</div>'}
    ${dades.recomanacions && dades.recomanacions.length > 0
      ? `<div style="font-weight:600;color:var(--accent2);margin:10px 0 6px">ğŸ’¡ Recomanacions per als prÃ²xims capÃ­tols</div>
         <ul style="padding-left:18px;font-size:.88rem">${dades.recomanacions.map(r => `<li style="margin-bottom:4px">${r}</li>`).join('')}</ul>`
      : ''}
  `;
  container.appendChild(panel);
  if (dades.ajustos_rumb) {
    ESTAT._ajustosRumb = dades.ajustos_rumb;
  }
}

// â”€â”€â”€ SISTEMA 3: Millorar Cliffhanger â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function millorarCliffhanger(idx, instruccions) {
  if (!instruccions) return;
  const btn = event && event.target ? event.target : null;
  if (btn) { btn.disabled = true; btn.textContent = 'â³ Millorantâ€¦'; }
  try {
    ESTAT._revisioInstruccions = ESTAT._revisioInstruccions || {};
    ESTAT._revisioInstruccions[idx] = instruccions;
    await reescriureCapitol(idx);
    if (btn) { btn.textContent = 'âœ“ Cliffhanger millorat'; }
  } catch (err) {
    if (btn) { btn.disabled = false; btn.textContent = 'ğŸ£ Millorar cliffhanger'; }
    alert('Error: ' + err.message);
  }
}

function mostrarRepeticions(reps) {
  const div = document.getElementById('revisio-global-result');
  if (!div) return;
  let html = '<div style="margin-top:16px;padding:12px;background:#fff3cd;border-radius:8px;">';
  html += '<h3>ğŸ” Expressions Repetides Detectades</h3>';
  if (reps.trigrames && reps.trigrames.length > 0) {
    html += '<p><strong>Trigrames (3+ capÃ­tols):</strong> ' + reps.trigrames.slice(0,10).map(([ng,c]) => `"${escHtml(ng)}" (${c})`).join(', ') + '</p>';
  }
  if (reps.bigrames && reps.bigrames.length > 0) {
    html += '<p><strong>Bigrames (3+ capÃ­tols):</strong> ' + reps.bigrames.slice(0,10).map(([ng,c]) => `"${escHtml(ng)}" (${c})`).join(', ') + '</p>';
  }
  html += '</div>';
  div.insertAdjacentHTML('beforeend', html);
}
</script>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     BACKEND LOCAL â€” migrat de codigo.gs
     Canvis respecte a l'original:
       Â· Eliminada la funciÃ³ doGet()
       Â· callLLM, callAnthropic, callOpenAI, callGemini â†’ async
       Â· UrlFetchApp.fetch() â†’ await fetch() (API estÃ ndard del navegador)
       Â· parseJsonResponse â†’ async, usa response.status i await response.text()
       Â· Afegit CORS_PROXY per a Anthropic (evita errors CORS des del navegador)
       Â· Totes les funcions de fase â†’ async/await callLLM
       Â· exportarADoc â†’ descÃ rrega local via Blob + URL.createObjectURL (sense DocumentApp)
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>

// â”€â”€â”€ CORS per a Anthropic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Anthropic suporta crides directes des del navegador afegint la capÃ§alera
// 'anthropic-dangerous-direct-browser-access: true'.
// AixÃ² elimina la necessitat de qualsevol proxy extern.

// â”€â”€â”€ URLs i models per defecte â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PROVIDER_DEFAULTS = {
  anthropic: {
    apiUrl: 'https://api.anthropic.com/v1/messages',
    model: 'claude-opus-4-1'
  },
  openai: {
    apiUrl: 'https://api.openai.com/v1/chat/completions',
    model: 'gpt-4o'
  },
  gemini: {
    apiUrlBase: 'https://generativelanguage.googleapis.com/v1beta/models',
    model: 'gemini-1.5-pro'
  }
};

// â”€â”€â”€ Parseig de la resposta fetch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Equivalent a parseJsonResponse de GAS, adaptat a l'API fetch:
//   Â· rawResponse.status       en lloc de rawResponse.getResponseCode()
//   Â· await rawResponse.text() en lloc de rawResponse.getContentText()
async function parseJsonResponse(rawResponse, providerName) {
  const statusCode = rawResponse.status;
  const rawText    = await rawResponse.text() || '';
  let parsed;
  try {
    parsed = JSON.parse(rawText);
  } catch (e) {
    // Resposta no JSON: pot ser pÃ gina HTML del proxy o error de xarxa
    const preview = rawText.slice(0, 300).replace(/\s+/g, ' ');
    throw new Error(
      `${providerName} HTTP ${statusCode} â€” resposta no JSON del proxy.\n` +
      `Comprova la consola del navegador (F12) per mÃ©s detalls.\n` +
      `Inici de la resposta: ${preview}`
    );
  }
  if (statusCode >= 400) {
    const message = parsed && parsed.error
      ? (parsed.error.message || JSON.stringify(parsed.error))
      : rawText.slice(0, 300);
    throw new Error(`${providerName} HTTP ${statusCode}: ${message}`);
  }
  return parsed;
}

// â”€â”€â”€ Router multi-proveÃ¯dor i multi-rol â€” v5.1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// tag: 'generacio' | 'arquitecte' | 'arquitectura'
// config._esDraft: true â†’ usa model Draft (Haiku o equivalent)
// config.model: override explÃ­cit del model (mÃ xima prioritat)
async function callLLMMulti(messages, systemPrompt, config, tag) {
  const safeConfig = config || {};
  
  // Assignem el model segons si la tasca Ã©s d'arquitectura o de generaciÃ³
  let modelId;
  if (tag === 'arquitecte' || tag === 'arquitectura') {
    modelId = safeConfig.modelArquitectura || safeConfig.model;
  } else {
    // Si no Ã©s arquitectura, o Ã©s draft/generaciÃ³, usem el de generaciÃ³
    modelId = safeConfig.modelGeneracio || safeConfig.model;
  }

  const proveidor = safeConfig.provider || 'anthropic';
  
  // Obtenim la clau API corresponent
  let apiKey;
  if (proveidor === 'anthropic') apiKey = ESTAT._anthropicApiKey || safeConfig.apiKey;
  if (proveidor === 'google' || proveidor === 'gemini') apiKey = ESTAT._geminiApiKey || safeConfig.apiKey;
  if (proveidor === 'openai') apiKey = ESTAT._openaiApiKey || safeConfig.apiKey;

  if (!apiKey) throw new Error(`Cal una clau API per al proveÃ¯dor: ${proveidor}`);

  const maxTokens = safeConfig.maxTokens || 2048;

  // Enrutem directament al proveÃ¯dor triat amb el text lliure del model
  if (proveidor === 'anthropic') return await callAnthropic(messages, systemPrompt, apiKey, modelId, maxTokens);
  if (proveidor === 'google' || proveidor === 'gemini') return await callGemini(messages, systemPrompt, apiKey, modelId, maxTokens);
  if (proveidor === 'openai') return await callOpenAI(messages, systemPrompt, apiKey, modelId, maxTokens);
  
  throw new Error(`ProveÃ¯dor desconegut: ${proveidor}`);
}

// â”€â”€â”€ Crida genÃ¨rica a LLM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// rol: 'generacio' (Sonnet) | 'arquitectura' (Opus) â€” nomÃ©s per a Anthropic
async function callLLM(messages, systemPrompt, config, rol) {
  rol = rol || 'generacio';
  const safeConfig = config || {};
  const provider   = String(safeConfig.provider || '').toLowerCase().trim();
  const apiKey     = safeConfig.apiKey;
  const maxTokens  = safeConfig.maxTokens || 2048;

  if (!provider) throw new Error('Falta el provider al config.');
  if (!apiKey)   throw new Error("Falta l'apiKey al config.");

  // SelecciÃ³ del model: si 'model' s'ha passat explÃ­citament com a override, prioritat mÃ xima
  let model;
  if (safeConfig.model) {
    model = safeConfig.model; // override explÃ­cit â€” prioritat mÃ xima (sistema hÃ­brid v5)
  } else if (rol === 'arquitectura' && provider === 'anthropic' && safeConfig.modelArquitectura) {
    model = safeConfig.modelArquitectura;
  } else {
    model = safeConfig.modelGeneracio ||
            (PROVIDER_DEFAULTS[provider] && PROVIDER_DEFAULTS[provider].model);
  }

  if (provider === 'anthropic') return await callAnthropic(messages, systemPrompt, apiKey, model, maxTokens);
  if (provider === 'openai')    return await callOpenAI(messages, systemPrompt, apiKey, model, maxTokens);
  if (provider === 'gemini' || provider === 'google' || provider === 'google-gemini')
    return await callGemini(messages, systemPrompt, apiKey, model, maxTokens);

  throw new Error('Provider no suportat: ' + provider);
}

// â”€â”€â”€ Anthropic (Claude) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Crida directa des del navegador sense proxy extern.
// La capÃ§alera 'anthropic-dangerous-direct-browser-access' habilita CORS
// a l'API d'Anthropic per a Ãºs des del navegador (la clau queda al client,
// acceptable per a Ãºs personal/local).
async function callAnthropic(messages, systemPrompt, apiKey, model, maxTokens) {
  const payload = {
    model:      model || PROVIDER_DEFAULTS.anthropic.model,
    max_tokens: maxTokens,
    system:     systemPrompt || SYSTEM_DEFAULT,
    messages:   messages
  };

  const raw = await fetch(PROVIDER_DEFAULTS.anthropic.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type':                            'application/json',
      'x-api-key':                               apiKey,
      'anthropic-version':                       '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true'
    },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'Anthropic');
  if (result.error) throw new Error(result.error.message || "Error desconegut d'Anthropic.");

  const text = Array.isArray(result.content)
    ? result.content.filter(p => p && p.type === 'text').map(p => p.text || '').join('\n')
    : '';
  return normalizeLLMText(text);
}

// â”€â”€â”€ OpenAI (GPT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// OpenAI permet CORS des del navegador amb la seva API pÃºblica,
// de manera que no cal proxy.
async function callOpenAI(messages, systemPrompt, apiKey, model, maxTokens) {
  const payload = {
    model:      model || PROVIDER_DEFAULTS.openai.model,
    messages:   buildOpenAIMessages(messages, systemPrompt),
    max_tokens: maxTokens
  };

  const raw = await fetch(PROVIDER_DEFAULTS.openai.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type':  'application/json',
      'Authorization': 'Bearer ' + apiKey
    },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'OpenAI');
  if (result.error) throw new Error(result.error.message || "Error desconegut d'OpenAI.");

  const firstChoice    = result.choices && result.choices[0];
  const messageContent = firstChoice && firstChoice.message ? firstChoice.message.content : '';
  return normalizeLLMText(extractContentText(messageContent));
}

// â”€â”€â”€ Google Gemini â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// La clau API va com a parÃ metre de query string a la URL,
// no cal capÃ§alera d'autenticaciÃ³ addicional.
async function callGemini(messages, systemPrompt, apiKey, model, maxTokens) {
  const finalModel = model || PROVIDER_DEFAULTS.gemini.model;
  const endpoint   = PROVIDER_DEFAULTS.gemini.apiUrlBase + '/' +
    encodeURIComponent(finalModel) + ':generateContent?key=' + encodeURIComponent(apiKey);

  const payload = {
    contents:         buildGeminiContents(messages),
    generationConfig: { maxOutputTokens: maxTokens },
    // CORRECCIÃ“: Desactivem els filtres per permetre textos literaris
    safetySettings: [
      { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
    ]
  };
  
  if (systemPrompt || SYSTEM_DEFAULT) {
    payload.systemInstruction = { parts: [{ text: systemPrompt || SYSTEM_DEFAULT }] };
  }

  const raw = await fetch(endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  const result = await parseJsonResponse(raw, 'Gemini');
  if (result.error) {
    throw new Error(
      (result.error.message || 'Error desconegut de Gemini.') +
      (result.error.status ? ' (' + result.error.status + ')' : '')
    );
  }

  const firstCandidate = result.candidates && result.candidates[0];

  // AvÃ­s clar si bloqueja per seguretat
  if (firstCandidate && firstCandidate.finishReason === 'SAFETY') {
     throw new Error("Gemini ha bloquejat la resposta per filtres de seguretat extrems. Prova amb un fragment menys sensible.");
  }

  const parts = firstCandidate && firstCandidate.content ? firstCandidate.content.parts : [];
  const text  = Array.isArray(parts) ? parts.map(p => (p && p.text) ? p.text : '').join('\n') : '';
  
  return normalizeLLMText(text);
}

// â”€â”€â”€ Helpers de construcciÃ³ de missatges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildOpenAIMessages(messages, systemPrompt) {
  const base = [];
  if (systemPrompt || SYSTEM_DEFAULT) base.push({ role: 'system', content: systemPrompt || SYSTEM_DEFAULT });
  return base.concat((messages || []).map(msg => ({
    role:    msg.role,
    content: extractContentText(msg.content)
  })));
}

function buildGeminiContents(messages) {
  return (messages || []).map(msg => ({
    role:  msg.role === 'assistant' ? 'model' : 'user',
    parts: [{ text: extractContentText(msg.content) }]
  }));
}

function extractContentText(content) {
  if (typeof content === 'string') return content;
  if (Array.isArray(content)) return content.map(item => {
    if (typeof item === 'string') return item;
    if (item && typeof item.text === 'string') return item.text;
    return '';
  }).join('\n');
  if (content && typeof content.text === 'string') return content.text;
  return content ? String(content) : '';
}

function normalizeLLMText(text) {
  return (text || '').replace(/^\s+|\s+$/g, '');
}

// â”€â”€â”€ System prompt base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SYSTEM_DEFAULT = `Ets un mestre del conte literari breu en catalÃ .
Apliques el principi d'unitat d'efecte de Poe: cada paraula serveix un Ãºnic impacte emocional final.
Escrius amb economia de paraules, primera frase magnÃ¨tica, tensiÃ³ creixent i finals memorables que ressonen.
Mai desperdicies una frase. Prioritzes mostrar sobre explicar.
Escrius EXCLUSIVAMENT en catalÃ . Mai inclous paraules, frases ni comentaris en anglÃ¨s o cap altra llengua. Mai afegeixes notes meta, indicacions de nÃºmero de part ni cap text fora de la narraciÃ³ literÃ ria. Escriu directament el text.`;

// â”€â”€â”€ ExtensiÃ³ d'estil per autor (reutilitzable per conte i novelÂ·la) â”€â”€â”€
function getGenreStyle(tematica) {
  const isLarsson   = tematica && /larsson|noir|negr[ae]|nÃ²rdi/i.test(tematica);
  const isTolkien   = tematica && /tolkien|fantÃ stic|fantastic|Ã¨pic/i.test(tematica);
  const isDick      = tematica && /philip k\. dick|philip.*dick|dick/i.test(tematica);
  const isCastaneda = tematica && /castaneda|xamÃ nic/i.test(tematica);

  if (isLarsson) return `

â”€â”€ ESTIL STIEG LARSSON â”€â”€
Pensament i visiÃ³ del mÃ³n: Larsson era periodista d'investigaciÃ³ i antifeixista militant. Les seves obres neixen de la convicciÃ³ que la violÃ¨ncia contra les dones i la corrupciÃ³ institucional sÃ³n sistÃ¨miques, no excepcions. Escrius des d'aquesta consciÃ¨ncia polÃ­tica sense abanderats ni discursos.
Prosa directa i funcional, carregada de detall procedimental: cada acciÃ³ d'investigaciÃ³ â€”una trucada, un arxiu consultat, una font protegidaâ€” s'explica amb lÃ²gica interna creÃ¯ble i concreta.
L'entorn nÃ²rdic (hivern escandinau, foscor, aÃ¯llament geogrÃ fic i social) actua com a personatge amb pes propi: el fred Ã©s moral tant com climÃ tic.
Secrets familiars soterrats durant dÃ¨cades que quan surten a la llum destapen patrons de violÃ¨ncia i complicitat que ningÃº volia veure.
Protagonistes traumatitzats amb una obstinaciÃ³ quasi patolÃ²gica: no investiguen per heroisme sinÃ³ perquÃ¨ no poden parar, la ferida personal Ã©s el motor.
CrÃ­tica social concreta i documentada integrada a la trama: noms d'institucions, mecanismes de poder, estadÃ­stiques de violÃ¨ncia que apareixen de forma natural al text.
Estructura de revelaciÃ³ progressiva: el que semblava un cas aÃ¯llat obre pas a un sistema podrit que implica tothom.
Ritme metÃ²dic i pausat en la investigaciÃ³, amb pics d'acciÃ³ breu, directa i brutal quan la violÃ¨ncia irromp.`;

  if (isTolkien) return `

â”€â”€ ESTIL J.R.R. TOLKIEN â”€â”€
Pensament i visiÃ³ del mÃ³n: Tolkien era filÃ²leg, catÃ²lic i veterÃ  de la Primera Guerra Mundial. El seu univers neix de la convicciÃ³ que el llenguatge crea realitat, que el bÃ© i el mal existeixen com a forces cÃ²smiques, i que la humilitat dels petits pot transformar la histÃ²ria. Escrius des d'aquesta fe en la bellesa i el sacrifici.
Prosa Ã¨pica, lÃ­rica i detallada: les descripcions de paisatge i arquitectura transmeten profunditat i antiguitat immemorial, com si el mÃ³n existÃ­s des d'abans que comencÃ©s la histÃ²ria.
Univers tolkieniÃ  complet: races (Eldar, Khazad, hobits, homes, orcs, ents), geografies amb nom i memÃ²ria prÃ²pia, llenguatges inventats amb fonologia coherent, canÃ§ons i poemes intercalats quan l'escena ho demana.
Temes centrals: la corrupciÃ³ del poder i la tentaciÃ³ dels anells, el pes de la responsabilitat sobre les espatlles dels humils, la camaraderia com a valor suprem, la bellesa efÃ­mera davant el pas implacable del temps i l'oblit.
Llenguatge solemne perÃ² accessible: frases llargues i rÃ­tmiques, construccions arcaiques mesurades, Ã¨mfasi en els noms propis com a portadors de destÃ­.
La natura com a presÃ¨ncia viva i moral: boscos, rius i muntanyes tenen memÃ²ria, voluntat i opiniÃ³ sobre els esdeveniments dels mortals.
El mal tÃ© pes fÃ­sic i sensorial: no s'explica, es percep en l'aire que s'espesseix, la llum que s'apaga, el silenci sobtat dels ocells i la por als ulls dels animals.`;

  if (isDick) return `

â”€â”€ ESTIL PHILIP K. DICK â”€â”€
Pensament i visiÃ³ del mÃ³n: Dick era un paranoic funcional fascinat per la gnosi, les drogues, la simulaciÃ³ i la pregunta de si alguna cosa Ã©s real. Les seves obres neixen de la convicciÃ³ que la realitat Ã©s una capa prima que pot trencar-se en qualsevol moment i que el sistema â€”qualsevol sistemaâ€” menteix. Escrius des d'aquesta desconfianÃ§a radical.
Paranoia com a estat cognitiu del protagonista i del lector: les institucions (estat, corporacions, androÃ¯des, drogues prescrites) manipulen la percepciÃ³; ningÃº sap mai si el que veu Ã©s real o induÃ¯t.
Les drogues â€”legals, ilÂ·legals, prescrites per l'estatâ€” com a eina de control social i com a porta ambigua a altres realitats: poden revelar la veritat o ser la mentida mÃ©s sofisticada.
Distopia quotidiana i desgastada: el futur Ã©s una extensiÃ³ deteriorada del present, amb publicitat agressiva, burocrÃ cia kafkiana, androÃ¯des indistingibles dels humans i guerres consumides en segon pla.
Canvis sobtats i irreversibles de realitat: una frase, un objecte, una conversa trenquen el marc que el lector creia ferm. No es recupera l'estat anterior.
Protagonistes ordinaris â€”venedors, taxistes, policies de baixa graduaciÃ³â€” que descobreixen que el mÃ³n que habiten Ã©s una construcciÃ³ i han de decidir si prefereixen la mentida cÃ²moda o la veritat devastadora.
Prosa Ã gil, nerviosa i plena de diÃ leg: les espirals de pensament paranoic del protagonista s'intercalen amb l'acciÃ³ sense aturar el ritme.
Empatia com a Ãºnica brÃºixola moral: en un mÃ³n on res Ã©s real, la capacitat de sentir el dolor de l'altre Ã©s l'Ãºnic criteri per distingir l'humÃ  de la mÃ quina.`;

  if (isCastaneda) return `

â”€â”€ ESTIL CARLOS CASTANEDA â”€â”€
Pensament i visiÃ³ del mÃ³n: Castaneda partia de la tradiciÃ³ tolteca i xamÃ nica per demostrar que la realitat ordinÃ ria Ã©s un acord social, no una veritat absoluta. Les seves obres neixen de la convicciÃ³ que la percepciÃ³ es pot estendre mÃ©s enllÃ  dels lÃ­mits racionals i que hi ha un "punt d'assemblatge" que pot moure's. Escrius des d'aquesta epistemologia alternativa.
Marc antropolÃ²gic o periodÃ­stic que es dissol progressivament: el narrador arriba com a investigador racional i occidental i surt transformat per experiÃ¨ncies que la seva formaciÃ³ no pot contenir.
RelaciÃ³ mestre-aprenent com a eix narratiu: el personatge guia (el bruixot, el nagual, el curandero) no explica mai directament, ensenya a travÃ©s de tasques impossibles, silencis deliberats, paradoxes i situacions lÃ­mit.
Els estats alterats de consciÃ¨ncia â€”induÃ¯ts per plantes de poder, per privaciÃ³ sensorial, per esforÃ§ fÃ­sic extrem o per la voluntat del mestreâ€” es descriuen amb precisiÃ³ sensorial absoluta: colors, sons, sensacions corporals, distorsions temporals. No s'expliquen des de fora, es viuen des de dins.
El mÃ³n natural com a text viu: cada animal, planta, vent o lloc porta intenciÃ³ i missatge per als qui han aprÃ¨s a llegir-los.
DiÃ leg com a vehicle principal de l'ensenyament: les converses entre aprenent i mestre marquen el ritme i transformen la percepciÃ³ del lector.
TensiÃ³ irresoluble entre la racionalitat occidental del protagonista i la "realitat separada" que se li ofereix: el text no resol aquesta tensiÃ³, la mantÃ© viva fins al final.
El desert, la nit, els somnis lÃºcids i les plantes de poder com a espais on les fronteres entre mons es fan permeables.`;

  return '';
}

// â”€â”€â”€ System prompt dinÃ mic per gÃ¨nere (conte breu) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getSystemPrompt(tematica) {
  return SYSTEM_DEFAULT + getGenreStyle(tematica);
}

// â”€â”€â”€ FASE 1: 10 premisses â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase1_premisses(tematica, history, userConfig) {
  history = history || [];
  const userMsg = {
    role: 'user',
    content: `Genera 10 premisses originals per a contes breus del gÃ¨nere: **${tematica}**.

Cada premissa ha de:
- Ser una sola frase que contingui una situaciÃ³ anÃ²mala o conflicte inicial potent
- Tenir un ganxo implÃ­cit que faci preguntar "i llavors?"
- Suggerir potencial de twist o revelaciÃ³ inesperada al final
- Ser concreta, sorprenent, no Ã²bvia ni genÃ¨rica

Afegeix (Recomanat) al final de la premissa que consideris mÃ©s potent literÃ riament.

Format ESTRICTE (res mÃ©s, sense cap introducciÃ³):
1. [premissa]
2. [premissa]
3. [premissa]
4. [premissa]
5. [premissa]
6. [premissa]
7. [premissa]
8. [premissa]
9. [premissa]
10. [premissa]`
  };
  const msgs       = [...history, userMsg];
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096 }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 3: 5 protagonistes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase3_personatges(premissaTriada, estilDesc, history, userConfig, tematica) {
  const isNoir = tematica && /larsson|noir|negr[ae]|nÃ²rdi/i.test(tematica);

  const protagonistePrompt = isNoir
    ? `Genera 5 protagonistes possibles per a aquest conte NEGRE NÃ’RDIC. Han de ser arquetips propis del gÃ¨nere.

Usa exclusivament aquests tipus: detectiu/investigador traumatitzat, periodista d'investigaciÃ³ obstinada, hacker antisocial, advocat incorruptible en un sistema corrupte, o personatge marginal amb accÃ©s a informaciÃ³ perillosa.

Cada protagonista ha de tenir veu prÃ²pia i la ferida personal que el fa avanÃ§ar quan tot indica que ha de parar.`
    : `Genera 5 protagonistes possibles per a aquest conte. Cada un ha de tenir veu prÃ²pia i tensiÃ³ interna que el faci memorable.`;

  const msgs = [
    ...history,
    {
      role: 'user',
      content: `He triat la premissa: "${premissaTriada}". L'estil narratiu serÃ : ${estilDesc}.`
    },
    {
      role: 'assistant',
      content: "Perfecte. Proposo protagonistes rics en contradiccions, coherents amb la premissa i l'estil triat."
    },
    {
      role: 'user',
      content: `${protagonistePrompt}

Afegeix (Recomanat) al final del protagonista que millor encaixi amb la premissa i l'estil triat.

Format ESTRICTE (5 opcions, res mÃ©s):
1. **[Nom, edat]** | Desig: [el que vol conscientment] | Temor: [el que l'aterroritza o amaga] | ContradicciÃ³: [la tensiÃ³ interna que el fa humÃ ] | Veu: [tret narratiu o tic que el fa distintiu]
2. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]
3. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]
4. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]
5. **[Nom, edat]** | Desig: [...] | Temor: [...] | ContradicciÃ³: [...] | Veu: [...]`
    }
  ];
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096 }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 4: 5 localitzacions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase_localitzacions(protagonistaTriat, estilDesc, history, userConfig, tematica) {
  const msgs = [
    ...history,
    { role: 'user',      content: `He triat el protagonista: "${protagonistaTriat}".` },
    { role: 'assistant', content: "Perfecte. Proposo localitzacions que maximitzin el potencial narratiu de la premissa i el protagonista." },
    {
      role: 'user',
      content: `Genera 5 localitzacions possibles per a aquest conte, coherents amb el gÃ¨nere, l'estil i el protagonista triat.

Cada localitzaciÃ³ ha de:
- Tenir una atmosfera concreta que reforci el to del conte
- Incloure un detall fÃ­sic especÃ­fic que pugui tenir rol narratiu
- Suggerir tensions o possibilitats implÃ­cites (no explicar-les)

Afegeix (Recomanat) al final de la localitzaciÃ³ que millor serveixi la premissa i l'estil.

Format ESTRICTE (5 opcions, res mÃ©s):
1. **[Nom/tipus de lloc]** | Atmosfera: [adjectius sensorials] | Detall clau: [element fÃ­sic concret] | Potencial: [possibilitat narrativa breu]
2. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]
3. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]
4. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]
5. **[Nom/tipus de lloc]** | Atmosfera: [...] | Detall clau: [...] | Potencial: [...]`
    }
  ];
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096 }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 5: 5 finals possibles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase4_finals(localitzacioTriada, estilDesc, history, userConfig, tematica) {
  const msgs = [
    ...history,
    { role: 'user',      content: `He triat la localitzaciÃ³: "${localitzacioTriada}".` },
    { role: 'assistant', content: 'Perfecte. Amb totes les decisions preses, proposo possibles finals per al conte.' },
    {
      role: 'user',
      content: `Genera 5 finals possibles per a aquest conte, coherents amb la premissa, l'estil i el protagonista triats.

Cada final ha de:
- Ser diferent en to i resoluciÃ³ dels altres
- Tenir impacte emocional genuÃ­
- Ser inevitable en retrospectiva perÃ² imprevist durant la lectura
- Explicar-se en 2-3 frases que capturin l'essÃ¨ncia sense revelar massa

Afegeix (Recomanat) al final de l'opciÃ³ que consideris mÃ©s poderosa literÃ riament.

Format ESTRICTE (5 opcions, res mÃ©s):
1. [descripciÃ³ del final en 2-3 frases]
2. [descripciÃ³ del final en 2-3 frases]
3. [descripciÃ³ del final en 2-3 frases]
4. [descripciÃ³ del final en 2-3 frases]
5. [descripciÃ³ del final en 2-3 frases]`
    }
  ];
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 4096 }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ ESCRIPTURA: GeneraciÃ³ per parts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function escriureContePart(partNum, totalParts, paraulesPerPart, finalTriat, estilDesc, history, userConfig, tematica) {
  const pp     = parseInt(paraulesPerPart) || 750;
  const isNoir = tematica && /larsson|noir|negr[ae]|nÃ²rdi/i.test(tematica);

  const noirExtra = isNoir
    ? `\nESTIL NORDIC NOIR OBLIGATORI per a aquesta part:
â†’ Descripcions minucioses i procedimentals: cada acciÃ³ d'investigaciÃ³ s'explica amb lÃ²gica creÃ¯ble.
â†’ Integra detalls de procediment policial, forense o periodÃ­stic de forma natural a la narraciÃ³.
â†’ Pinzellades de crÃ­tica social concreta (noms d'institucions, mecanismes de poder) sense discurs explÃ­cit.
â†’ L'entorn nÃ²rdic (fred, silenci, llum escassa) present com a pressiÃ³ constant sobre els personatges.`
    : '';

  let userContent;

  if (totalParts === 1) {
    userContent =
`He triat el final: "${finalTriat}".

Escriu el CONTE COMPLET (~${pp} paraules). Estil: ${estilDesc}.
Final obligatori: "${finalTriat}"

OBERTURA: primera frase magnÃ¨tica, tensiÃ³ immediata. Primers 3 parÃ grafs sense exposiciÃ³ directa.
ESTRUCTURA: unitat d'efecte, tensiÃ³ creixent, punt d'inflexiÃ³ a les 2/3 parts.
ESTIL: mostra no expliquis, detalls sensorials concrets, ritme variat, veu Ãºnica, diÃ legs que revelen carÃ cter.
FINAL: l'Ãºltima frase ressona i tanca un cercle del principi.${noirExtra}
Escriu directament el conte en catalÃ , sense tÃ­tol ni nota de l'autor. Cap paraula en anglÃ¨s ni cap altra llengua.`;

  } else if (partNum === 1) {
    userContent =
`He triat el final: "${finalTriat}".

Escriu la PRIMERA PART del conte (~${pp} paraules). Estil: ${estilDesc}.

Objectiu d'aquesta part:
â†’ Primera frase impossible de no llegir (pregunta o tensiÃ³ immediata).
â†’ Establir la veu, l'atmosfera i el personatge sense exposiciÃ³ directa.
â†’ Plantar la tensiÃ³ central i el conflicte que s'ha de resoldre.
â†’ Acabar en un punt de suspens que demani la continuaciÃ³ (NO resolguis res).
Mostra, no expliquis. Detalls sensorials concrets. Veu Ãºnica.${noirExtra}
Escriu directament en catalÃ , sense tÃ­tol ni cap indicaciÃ³ de "Part 1". Cap paraula en anglÃ¨s ni cap altra llengua.`;

  } else if (partNum < totalParts) {
    userContent =
`Continua el conte amb la PART ${partNum} (~${pp} paraules).

Objectiu d'aquesta part:
â†’ Augmenta el conflicte i la pressiÃ³ sobre el protagonista.
â†’ Introdueix el punt d'inflexiÃ³ o la complicaciÃ³ principal.
â†’ Acaba quan la tensiÃ³ arriba al mÃ xim, just abans de la resoluciÃ³.
â†’ MantÃ©n exactament la mateixa veu narrativa, to i registre de les parts anteriors.${noirExtra}
Continua directament la narraciÃ³ en catalÃ , des d'on s'ha aturat el text anterior. Sense cap indicaciÃ³ de nÃºmero de part ni comentari fora de la ficciÃ³. Cap paraula en anglÃ¨s ni cap altra llengua.`;

  } else {
    userContent =
`Finalitza el conte amb la PART FINAL (~${pp} paraules).

El desenllaÃ§ OBLIGATORI Ã©s: "${finalTriat}"

â†’ Executa el clÃ­max i la resoluciÃ³ amb precisiÃ³ literÃ ria.
â†’ El desenllaÃ§ ha de ser inevitable en retrospectiva perÃ² imprevist durant la lectura.
â†’ L'Ãºltima frase ha de ressonar i tancar un cercle obert al principi.
â†’ MantÃ©n exactament la mateixa veu narrativa i to de les parts anteriors.${noirExtra}
Continua directament la narraciÃ³ en catalÃ , des d'on s'ha aturat el text anterior. Sense cap indicaciÃ³ de nÃºmero de part ni comentari fora de la ficciÃ³. Cap paraula en anglÃ¨s ni cap altra llengua.`;
  }

  const msgs      = [...history, { role: 'user', content: userContent }];
  const maxTokens = Math.min(Math.round(pp * 4) + 1000, 8192);
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ MILLORA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function millorarConte(instruccio, conteActual, estilDesc, history, userConfig, tematica) {
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `AquÃ­ tens el conte actual:\n\n${conteActual}\n\n---\nReescriu el conte complet aplicant aquesta millora: "${instruccio}".\n\nMantÃ©n tot el que funciona bÃ©. Millora especÃ­ficament el que es demana. MantÃ©n la mateixa extensiÃ³ aproximada i l'estil: ${estilDesc}.\n\nEscriu directament el conte millorat, sense cap comentari previ.`
    }
  ];
  const maxTokens  = Math.min(Math.round(conteActual.split(' ').length * 2.5) + 600, 8000);
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 7: Worldbuilding â€” ExtracciÃ³ d'elements â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase7_worldbuilding(conteActual, tematica, estilDesc, history, userConfig) {
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `Has escrit el conte segÃ¼ent:\n\n${conteActual}\n\n---\nAra, com a arquitecte de mons, analitza el conte i proposa 8 elements del mÃ³n que es podrien expandir per convertir-lo en una novelÂ·la. Els elements han de ser:\n\n1. Geografia â€” el territori i els seus llocs rellevants\n2. PolÃ­tica â€” el sistema de poder i les seves tensions\n3. MÃ gia/Tecnologia â€” el sistema mÃ gic o tecnolÃ²gic que regeix el mÃ³n\n4. Religions â€” les creences, rituals i institucions religioses\n5. Faccions â€” els grups, bandes o organitzacions en conflicte\n6. HistÃ²ria pregressa â€” els esdeveniments passats que expliquen el present\n7. Economia â€” els recursos, el comerÃ§ i les desigualtats\n8. Cultura quotidiana â€” els costums, l'art, la gastronomia, les festes\n\nMarca amb "(Recomanat)" els 4 elements mÃ©s rellevants per expandir basant-te en el que ja apareix al conte. Cada element: nom + descripciÃ³ d'1 lÃ­nia del que caldria definir.\n\nFormat ESTRICTE (res mÃ©s, sense cap introducciÃ³):\n1. **Geografia** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n2. **PolÃ­tica** â€” [descripciÃ³ d'1 lÃ­nia]\n3. **MÃ gia/Tecnologia** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n4. **Religions** â€” [descripciÃ³ d'1 lÃ­nia]\n5. **Faccions** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n6. **HistÃ²ria pregressa** â€” [descripciÃ³ d'1 lÃ­nia]\n7. **Economia** â€” [descripciÃ³ d'1 lÃ­nia] (Recomanat)\n8. **Cultura quotidiana** â€” [descripciÃ³ d'1 lÃ­nia]`
    }
  ];
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 2048 }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 7: Worldbuilding â€” ExpansiÃ³ dels elements triats â”€â”€â”€
async function fase7_expandirElements(elementsTriats, conteActual, tematica, history, userConfig) {
  const llistaElements = elementsTriats.join('\n');
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `A partir del conte i dels elements de mÃ³n proposats, desenvolupa una bÃ­blia de mÃ³n per als elements seleccionats.\n\nElements a expandir:\n${llistaElements}\n\nPer a cada element, escriu una descripciÃ³ de 3-5 lÃ­nies que:\n- Defineixi l'element amb precisiÃ³ i profunditat\n- Connecti amb el que ja apareix al conte\n- Suggereixi tensions narratives implÃ­cites\n- Sigui Ãºtil per a un escriptor que vol expandir el mÃ³n\n\nFormat ESTRICTE per a cada element:\n**[Nom de l'element]**\n[descripciÃ³ de 3-5 lÃ­nies]\n\nSepara els elements amb una lÃ­nia en blanc. Escriu exclusivament en catalÃ .`
    }
  ];
  const maxTokens  = Math.min(400 * elementsTriats.length + 800, 4096);
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 8: Elenc de personatges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fase8_elencPersonatges(conteActual, protagonistaTriat, tematica, estilDesc, worldContext, history, userConfig) {
  const msgs = [
    ...history,
    {
      role: 'user',
      content: `A partir del conte escrit i la informaciÃ³ del mÃ³n, proposa un elenc de personatges secundaris per a la seva expansiÃ³ en novelÂ·la.

Conte:
${conteActual}${worldContext}

Protagonista ja definit: ${protagonistaTriat}
GÃ¨nere: ${tematica} | Estil: ${estilDesc}

Proposa fins a 8 personatges secundaris. Cada un ha de:
- Tenir un rol clar en la trama o en el creixement del protagonista
- Tenir una relaciÃ³ especÃ­fica i dramÃ ticament Ãºtil amb el protagonista
- Tenir un tret definitori que el faci memorable en poques paraules
- Tenir una funciÃ³ dramÃ tica concreta a la novelÂ·la

Marca amb (Recomanat) els 4 personatges que consideris essencials per a la trama.

Format ESTRICTE (res mÃ©s, sense cap introducciÃ³):
1. **[Nom, edat]** | Rol: [funciÃ³ narrativa] | RelaciÃ³: [amb el protagonista] | Tret: [caracterÃ­stica definitÃ²ria] | FunciÃ³: [propÃ²sit dramÃ tic a la novelÂ·la]
2. **[Nom, edat]** | Rol: [...] | RelaciÃ³: [...] | Tret: [...] | FunciÃ³: [...]
3. ...`
    }
  ];
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens: 3000 }));
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ FASE 9: Estils de parla â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Genera el perfil de veu per al protagonista + tots els personatges
// secundaris seleccionats, per guiar l'escriptura dels diÃ legs.
async function fase9_estilParla(protagonistaTriat, personatgesSecundaris, conteActual, tematica, estilDesc, history, userConfig) {
  const totsPersonatges = [protagonistaTriat, ...personatgesSecundaris];
  const llista = totsPersonatges.map((p, i) => `${i + 1}. ${p}`).join('\n');

  const msgs = [
    ...history,
    {
      role: 'user',
      content: `Defineix el perfil de veu i estil de parla de cada personatge de l'elenc per guiar l'escriptura dels diÃ legs de la novelÂ·la.

Personatges:
${llista}

GÃ¨nere: ${tematica} | Estil narratiu general: ${estilDesc}

Per a cada personatge defineix els 5 eixos de la seva veu Ãºnica:
- **Vocabulari**: tipus de paraules que usa (culte, colÂ·loquial, tÃ¨cnic, dialectal, argot, arcaic, cientÃ­ficâ€¦)
- **Frases**: estructura sintÃ ctica tÃ­pica (curtes i directes, llargues i subordinades, fragmentades, retÃ²riques, amb elÂ·lipsisâ€¦)
- **Tics**: 2-3 expressions, interjeccions o fÃ³rmules recurrents que el caracteritzen (entre cometes)
- **Registre**: to general predominant (formal, irÃ²nic, directe, evasiu, emocional, fred, sarcÃ stic, poÃ¨ticâ€¦)
- **Exemple**: una frase representativa del personatge en situaciÃ³ de tensiÃ³ o conflicte (entre cometes)

Els perfils han de ser contrastats entre ells: cada personatge ha de sonar inconfusiblement diferent dels altres.

Format ESTRICTE per a cada personatge (res mÃ©s, sense cap introducciÃ³):
**[Nom del personatge]**
Vocabulari: [...]
Frases: [...]
Tics: [...]
Registre: [...]
Exemple: Â«[frase representativa]Â»

Separa cada personatge amb una lÃ­nia en blanc. Escriu exclusivament en catalÃ .`
    }
  ];
  const maxTokens  = Math.min(700 * totsPersonatges.length + 800, 6000);
  // Opus: definir veus Ã©s tasca d'arquitectura narrativa
  const response   = await callLLMMulti(msgs, getSystemPrompt(tematica), Object.assign({}, userConfig, { maxTokens }), 'arquitectura');
  const newHistory = [...msgs, { role: 'assistant', content: response }];
  return { response, history: newHistory };
}

// â”€â”€â”€ EXPORT LOCAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Substitueix l'antiga exportarADoc que usava DocumentApp/DriveApp
// (APIs de Google no disponibles al navegador).
//
// Genera un document HTML semÃ ntic amb <h1> i <p> i el descarrega
// directament al navegador mitjanÃ§ant Blob + URL.createObjectURL.
function exportarADoc(titol, contingut) {
  // â”€â”€ 1. Generar HTML semÃ ntic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const paragraphs   = contingut.split(/\n\n+/).filter(p => p.trim().length > 0);
  const paragrafsHtml = paragraphs.map((p, i) => {
    const text  = escHtml(p.trim());
    const style = i > 0 ? ' style="text-indent:1.8em;"' : '';
    return `  <p${style}>${text}</p>`;
  }).join('\n');

  const ara        = new Date();
  const dataStr    = ara.toLocaleDateString('ca', { year: 'numeric', month: 'long', day: 'numeric' });
  const htmlDoc    = `<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <title>${escHtml(titol)}</title>
  <style>
    body {
      font-family: Georgia, 'Times New Roman', serif;
      max-width: 680px;
      margin: 60px auto;
      line-height: 1.9;
      color: #222;
      padding: 0 24px 80px;
    }
    h1 {
      font-size: 1.8rem;
      text-align: center;
      margin-bottom: 0.25em;
    }
    .meta {
      text-align: center;
      color: #888;
      font-size: 0.85rem;
      margin-bottom: 3em;
      font-family: system-ui, sans-serif;
    }
    p { margin-bottom: 1.1em; }
  </style>
</head>
<body>
  <h1>${escHtml(titol)}</h1>
  <div class="meta">Generat amb Conte IA Â· ${dataStr}</div>
${paragrafsHtml}
</body>
</html>`;

  // â”€â”€ 2. Crear Blob i forÃ§ar descÃ rrega â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const blob = new Blob([htmlDoc], { type: 'text/html;charset=utf-8' });
  const url  = URL.createObjectURL(blob);

  // Netejar el tÃ­tol per convertir-lo en nom de fitxer vÃ lid
  const nomFitxer = titol
    .replace(/[<>:"/\\|?*]/g, '')   // carÃ cters no vÃ lids a fitxers
    .trim()
    .replace(/\s+/g, '_')
    .substring(0, 80) + '.html';

  const a = document.createElement('a');
  a.href     = url;
  a.download = nomFitxer;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);          // alliberar memÃ²ria

  toast('ğŸ“„ Descarregat: ' + nomFitxer);
}

function descarregarNovella() {
  const caps      = ESTAT._capitols_generats || [];
  const estructura = ESTAT._estructuraCapitols || [];
  if (!caps.some(c => c)) { toast('No hi ha cap capÃ­tol generat per descarregar.'); return; }
  const titol = (ESTAT.premissaTriada || 'NovelÂ·la')
    .replace(/\*\*/g, '').replace(/[<>:"/\\|?*]/g, '').trim().substring(0, 80);
  exportarNovella(titol, caps, estructura, ESTAT.epileg || '');
}

function exportarNovella(titol, caps, estructura, epileg) {
  const ara     = new Date();
  const dataStr = ara.toLocaleDateString('ca', { year: 'numeric', month: 'long', day: 'numeric' });

  function capsHtml(text, primeraNoSangria) {
    return text.split(/\n\n+/).filter(p => p.trim().length > 0).map((p, i) => {
      const t     = escHtml(p.trim());
      const style = (primeraNoSangria && i === 0) ? '' : ' style="text-indent:1.8em;"';
      return `  <p${style}>${t}</p>`;
    }).join('\n');
  }

  let cosHtml = '';
  caps.forEach((text, i) => {
    if (!text) return;
    const cap      = estructura[i];
    const numCap   = escHtml(`CapÃ­tol ${i + 1}`);
    const titolCap = escHtml(cap ? (cap.titol || '') : '');
    cosHtml += `\n<div class="capitol">\n  <p class="num-capitol">${numCap}</p>\n  <h2>${titolCap}</h2>\n${capsHtml(text, true)}\n</div>\n`;
  });

  if (epileg && epileg.trim()) {
    cosHtml += `\n<div class="capitol">\n  <p class="num-capitol">â€”</p>\n  <h2>EpÃ­leg</h2>\n${capsHtml(epileg, true)}\n</div>\n`;
  }

  const htmlDoc = `<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <title>${escHtml(titol)}</title>
  <style>
    body { font-family: Georgia, 'Times New Roman', serif; max-width: 660px; margin: 60px auto; line-height: 1.95; color: #1a1a1a; padding: 0 24px 80px; }
    h1 { font-size: 2rem; text-align: center; margin-bottom: 0.3em; font-weight: 700; }
    .meta { text-align: center; color: #999; font-size: 0.82rem; margin-bottom: 4.5em; font-family: system-ui, sans-serif; }
    .capitol { margin-top: 4em; }
    .num-capitol { text-align: center; font-size: 0.78rem; letter-spacing: 0.2em; text-transform: uppercase; color: #aaa; margin: 0 0 0.3em; font-family: system-ui, sans-serif; }
    h2 { font-size: 1.15rem; text-align: center; margin: 0 0 2em; font-weight: 600; }
    p { margin: 0 0 0.15em; }
  </style>
</head>
<body>
  <h1>${escHtml(titol)}</h1>
  <p class="meta">Generat amb Booki Â· ${dataStr}</p>
${cosHtml}
</body>
</html>`;

  const blob      = new Blob([htmlDoc], { type: 'text/html;charset=utf-8' });
  const url       = URL.createObjectURL(blob);
  const nomFitxer = titol.replace(/\s+/g, '_').substring(0, 80) + '.html';
  const a         = document.createElement('a');
  a.href = url; a.download = nomFitxer;
  document.body.appendChild(a); a.click();
  document.body.removeChild(a); URL.revokeObjectURL(url);
  toast('ğŸ“– Descarregat: ' + nomFitxer);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITAT: Parse robust de JSON (evita errors LLM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function parseJsonRobust(text) {
  if (!text || typeof text !== 'string') return null;
  const s = text.trim();

  function parseLenientJson(candidate) {
    if (!candidate || typeof candidate !== 'string') return null;
    const cleaned = candidate
      .replace(/[â€œâ€]/g, '"')
      .replace(/[â€˜â€™]/g, "'")
      .replace(/,\s*([}\]])/g, '$1');
    try { return JSON.parse(cleaned); } catch (e) { return null; }
  }

  // 1. Parse directe
  const direct = parseLenientJson(s);
  if (direct) return direct;

  // 2. Bloc de codi markdown ```json ... ```
  const codeMatch = s.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (codeMatch) {
    const parsedCode = parseLenientJson(codeMatch[1].trim());
    if (parsedCode) return parsedCode;
  }

  // 3. Primer objecte { ... } complet
  const objStart = s.indexOf('{');
  const objEnd   = s.lastIndexOf('}');
  if (objStart !== -1 && objEnd > objStart) {
    const parsedObject = parseLenientJson(s.slice(objStart, objEnd + 1));
    if (parsedObject) return parsedObject;
  }

  // 4. Primer array [ ... ] complet
  const arrStart = s.indexOf('[');
  const arrEnd   = s.lastIndexOf(']');
  if (arrStart !== -1 && arrEnd > arrStart) {
    const parsedArray = parseLenientJson(s.slice(arrStart, arrEnd + 1));
    if (parsedArray) return parsedArray;
  }

  return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SYSTEM PROMPT per a novelÂ·la
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getSystemPromptNovella(tematica) {
  const base = `Ets un novelÂ·lista literari expert en catalÃ . Escrius novelÂ·la amb profunditat psicolÃ²gica, diÃ legs vius i un ritme narratiu sostingut.
Apliques les tÃ¨cniques de Donna Tartt, Elena Ferrante i Carlos Ruiz ZafÃ³n: atmÃ²sferes denses, personatges amb contradiccions genuÃ¯nes i trames que s'informen mÃºtuament.
Escrius EXCLUSIVAMENT en catalÃ . Mai inclous paraules ni comentaris en anglÃ¨s o qualsevol altra llengua.
Mai afegeixes notes meta, indicacions de capÃ­tol ni cap text fora de la narraciÃ³ literÃ ria. Escriu directament el text.
DIÃ€LEGS: Usa SEMPRE el guiÃ³ llarg (â€”) per introduir el parlament i les acotacions. PROHIBIT usar cometes (Â«Â», "", '') per al diÃ leg directe. Format correcte: â€”Hola â€”va dir ella. / â€”Bon dia. / â€”Vine aquÃ­ â€”li ordenÃ .
NOMS DE PERSONA: Aplica l'article personal (en, la, l', na) i les preposicions contractes quan la normativa catalana ho requereix. Exemples: la Maria, en Pere, l'Anna, en Marc, na Joana; amb la JÃºlia, amb en TomÃ s; del senyor Puig, al doctor Ferrer.`;
  return base + getGenreStyle(tematica || ESTAT.tematica);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 1: Brief Narratiu Centralitzat
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildBriefNarratiu() {
  const pers = ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0
    ? ESTAT._personatgesSeleccionats.join('; ')
    : '(No definits)';
  return `DECISIONS NARRATIVES:
- GÃ¨nere: ${ESTAT.tematica || '(No definit)'}
- Premissa: ${ESTAT.premissaTriada || '(No definida)'}
- Estil: ${ESTAT.estil ? ESTAT.estil.desc : '(No definit)'}
- Protagonista: ${ESTAT.protagonistaTriat || '(No definit)'}
- LocalitzaciÃ³: ${ESTAT.localitzacioTriada || '(No definida)'}
- Final planificat: ${ESTAT.finalTriat || '(No definit)'}
- Personatges seleccionats: ${pers}`;
}

function buildResumConteBreu() {
  if (!ESTAT.conteText) return '(No disponible)';
  const paragrafs = ESTAT.conteText.split(/\n\n+/).filter(p => p.trim());
  if (paragrafs.length <= 3) return ESTAT.conteText.substring(0, 800);
  const primer = paragrafs[0].substring(0, 200);
  const mig    = paragrafs[Math.floor(paragrafs.length / 2)].substring(0, 200);
  const ultim  = paragrafs[paragrafs.length - 1].substring(0, 200);
  return `INICI: ${primer}\n[...]\nMIG: ${mig}\n[...]\nFINAL: ${ultim}`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HELPERS per al context de la novelÂ·la
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildSystemPromptCapitolLegacy() {
  const resumConte = buildResumConteBreu();
  const brief      = buildBriefNarratiu();
  const world      = ESTAT.worldbuilding ? ESTAT.worldbuilding.substring(0, 3000) + (ESTAT.worldbuilding.length > 3000 ? '\n[â€¦]' : '') : 'No definida';
  const veus       = ESTAT.estilsParla   ? ESTAT.estilsParla : 'No definits';

  let base = `${getSystemPromptNovella(ESTAT.tematica)}

${brief}

RESUM DEL CONTE ORIGINAL:
${resumConte}

BÃBLIA DE MÃ“N:
${world}

ESTILS DE PARLA DELS PERSONATGES:
${veus}`;

  if (ESTAT._goldenPassage) {
    base += `\n\nREFERÃˆNCIA DE VEU:\nEl segÃ¼ent passatge exemplifica la veu i l'estil que ha de tenir la novelÂ·la. Usa'l com a referÃ¨ncia de qualitat:\n\n${ESTAT._goldenPassage}`;
  }
  if (ESTAT._capitols_generats.filter(t => t).length >= 3) {
    const repsDetectades = detectarRepeticions();
    if (repsDetectades) {
      const trigrames = repsDetectades.trigrames || [];
      const bigrames = repsDetectades.bigrames || [];
      const evitar = [...trigrames.slice(0,5), ...bigrames.slice(0,5)].map(([ng]) => `"${ng}"`);
      if (evitar.length > 0) base += `\n\nEXPRESSIONS A EVITAR (ja massa repetides): ${evitar.join(', ')}`;
    }
  }
  return base;
}

function buildSystemPromptCapitol() {
  // PONT NKG: quan el NKG Ã©s actiu, system prompt reduÃ¯t (el context va al prompt d'escena)
  if (ESTAT._nkg) {
    const parts = [];
    parts.push(getSystemPromptNovella(ESTAT.tematica));
    parts.push(buildBriefNarratiu());

    if (ESTAT.estilsParla) {
      parts.push('\nESTILS DE PARLA DELS PERSONATGES:\n' + ESTAT.estilsParla.substring(0, 2000));
    }
    if (ESTAT._goldenPassage) {
      parts.push('\nREFERÃˆNCIA DE VEU (escriu amb aquest to):\n' + ESTAT._goldenPassage.substring(0, 800));
    }
    if (ESTAT._capitols_generats.filter(t => t).length >= 3) {
      const repsDetectades = detectarRepeticions();
      if (repsDetectades) {
        const trigrames = repsDetectades.trigrames || [];
        const bigrames = repsDetectades.bigrames || [];
        const evitar = [...trigrames.slice(0,5), ...bigrames.slice(0,5)].map(([ng]) => `"${ng}"`);
        if (evitar.length > 0) parts.push(`\nEXPRESSIONS A EVITAR (massa repetides): ${evitar.join(', ')}`);
      }
    }
    if (ESTAT._manualEstil) {
      const m = ESTAT._manualEstil;
      const linies = [];
      if (m.longitud_frases) linies.push(`â€¢ Longitud de frases: ${m.longitud_frases}`);
      if (m.estil_dialeg) linies.push(`â€¢ DiÃ leg: ${m.estil_dialeg}`);
      if (m.sensorialitat) linies.push(`â€¢ Sensorialitat: ${m.sensorialitat}`);
      if (m.ritme) linies.push(`â€¢ Ritme: ${m.ritme}`);
      if (m.vocabulari) linies.push(`â€¢ Vocabulari: ${m.vocabulari}`);
      if (linies.length > 0) parts.push('\nMANUAL D\'ESTIL DE REFERÃˆNCIA:\n' + linies.join('\n'));
    }
    return parts.join('\n');
  }
  return buildSystemPromptCapitolLegacy();
}

function buildRegistreContextLegacy(idx) {
  const reg = ESTAT.llibreRegistre;
  if (!reg || !(reg.capitols || []).some(c => c)) return '';

  const parts = ['ESTAT ACTUAL DEL REGISTRE NARRATIU:'];

  if (reg.estat_personatges && reg.estat_personatges.length > 0) {
    parts.push('Personatges i ubicacions actuals:');
    reg.estat_personatges.forEach(p => parts.push(`- ${p.nom}: ${p.ubicacio} (${p.estat_actual})`));
  }

  if (reg.fils_oberts && reg.fils_oberts.length > 0) {
    parts.push('\nFils narratius oberts (OBLIGATORI tractar en aquest capÃ­tol o deixar explÃ­citament obert):');
    reg.fils_oberts.forEach(f => parts.push(`- ${f}`));
  }

  // Ãšltims 2 resums de capÃ­tol
  const capsFets = (reg.capitols || []).filter(c => c);
  if (capsFets.length > 0) {
    const recents = capsFets.slice(-2);
    parts.push('\nResums dels darrers capÃ­tols:');
    recents.forEach(c => {
      const capNum = (reg.capitols || []).indexOf(c) + 1;
      parts.push(`CapÃ­tol ${capNum}: ${c.resum_capitol}`);
    });
  }

  return '\n' + parts.join('\n');
}

function buildRegistreContext(idx) {
  // PONT NKG: el context ve del NKG (nkgGenerarContextMinim) quan Ã©s actiu
  if (ESTAT._nkg) return '';
  return buildRegistreContextLegacy(idx);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 4: Control de Ritme i TensiÃ³
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getInstruccionsRitme(nivell, tipus) {
  if (nivell <= 3) return 'Ritme pausat. Frases llargues i descriptives. Permet digressions. Estableix atmosfera. Pocs diÃ legs, i si n\'hi ha, sÃ³n reflexius.';
  if (nivell <= 5) return 'Ritme moderat. Alterna descripciÃ³ amb diÃ leg. Introdueix tensiÃ³ subtilment a travÃ©s de detalls, no d\'acciÃ³.';
  if (nivell <= 7) return 'Ritme creixent. Frases mÃ©s curtes a mesura que avanÃ§a el capÃ­tol. DiÃ legs amb subtexte. Les escenes s\'acceleren cap al final.';
  if (nivell <= 9) return 'Ritme alt. Frases curtes i directes. DiÃ legs tensos, tallants. Poc espai per respirar. Cada parÃ graf augmenta la pressiÃ³.';
  return 'CLÃMAX. Ritme frenÃ¨tic. Frases mÃ­nimes. AcciÃ³ directa. El moment de mÃ xima tensiÃ³. Tot s\'accelera cap a la resoluciÃ³.';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 5: Sistema de PrefiguraciÃ³
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getPrefiguracionsActives(idx) {
  const prefs  = ESTAT._prefiguracions || [];
  const capNum = idx + 1;
  const aPlantarAra      = prefs.filter(p => p.plantada_capitol === capNum);
  const aRecollirAra     = prefs.filter(p => p.resolucio_capitol === capNum);
  const plantadesNoResoltes = prefs.filter(p =>
    p.plantada_capitol < capNum && p.resolucio_capitol > capNum
  );
  return { aPlantarAra, aRecollirAra, plantadesNoResoltes };
}

function llistarPrefiguracions() {
  const prefs = ESTAT._prefiguracions || [];
  if (prefs.length === 0) return '(Cap prefiguraciÃ³ planificada)';
  return prefs.map(p =>
    `Cap.${p.plantada_capitol}â†’${p.resolucio_capitol}: ${p.element || ''}`
  ).join('\n');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 3: Context complet per a cada capÃ­tol
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildContextCapitolLegacy(idx) {
  const parts = [];

  // 1. Brief narratiu
  parts.push(buildBriefNarratiu());

  // 2. Resums de capÃ­tols anteriors (amb compressiÃ³ si n'hi ha)
  const resumsReg = (ESTAT.llibreRegistre.capitols || []).map(c => c ? c.resum_capitol : null);
  const compressionsOrdenades = (ESTAT._memoriasComprimides || []).filter(m => m.finsCap <= idx).sort((a,b) => b.finsCap - a.finsCap);
  if (compressionsOrdenades.length > 0) {
    const darrera = compressionsOrdenades[0];
    parts.push(`\n\n## SINOPSI COMPRIMIDA (caps. 1-${darrera.finsCap})\n${darrera.text}`);
    // Resums individuals posteriors a la compressiÃ³
    const posteriores = resumsReg.slice(darrera.finsCap).filter(r => r);
    if (posteriores.length > 0) {
      parts.push('\n\n## RESUMS RECENTS\n' + posteriores.map((r, i) => `Cap. ${darrera.finsCap + 1 + i}: ${r}`).join('\n'));
    }
  } else {
    // Fallback: resums individuals
    const resumsAnteriors = resumsReg.slice(0, idx).filter(r => r);
    if (resumsAnteriors.length > 0) {
      parts.push('\n\nRESUMS DELS CAPÃTOLS ANTERIORS:\n' + resumsAnteriors.map((r, i) => `Cap. ${i + 1}: ${r}`).join('\n'));
    }
  }

  // 3. Ãšltims 2 parÃ grafs del capÃ­tol anterior (continuÃ¯tat de to)
  if (idx > 0 && ESTAT._capitols_generats[idx - 1]) {
    const parasAnterior = ESTAT._capitols_generats[idx - 1].split(/\n\n+/);
    const ultims = parasAnterior.slice(-2).join('\n\n');
    if (ultims.trim()) {
      parts.push('\nFINAL DEL CAPÃTOL ANTERIOR (mantÃ©n la continuÃ¯tat de to i escena):\n' + ultims);
    }
  }

  // 4. Registre actual (personatges, fils)
  parts.push(buildRegistreContext(idx));

  // 5. Prefiguracions actives per a aquest capÃ­tol
  const { aPlantarAra, aRecollirAra, plantadesNoResoltes } = getPrefiguracionsActives(idx);

  if (aPlantarAra.length > 0) {
    parts.push('\nPREFIGURACIONS A PLANTAR EN AQUEST CAPÃTOL (integra-les subtilment, el lector no ha de notar-les en primera lectura):');
    aPlantarAra.forEach(p => parts.push(`- ${p.element}`));
  }

  if (aRecollirAra.length > 0) {
    parts.push('\nPREFIGURACIONS A RECOLLIR (elements plantats abans que ara es resolen):');
    aRecollirAra.forEach(p => parts.push(`- ${p.element}`));
  }

  if (plantadesNoResoltes.length > 0) {
    parts.push('\nPREFIGURACIONS ACTIVES (plantades i encara no resoltes â€” pots fer-hi referÃ¨ncia subtil):');
    plantadesNoResoltes.forEach(p => parts.push(`- ${p.element} (es resoldrÃ  al cap. ${p.resolucio_capitol})`));
  }

  // 6. Instruccions de ritme i to especÃ­fiques
  const cap = ESTAT._estructuraCapitols[idx];
  if (cap && cap.toRitme) {
    parts.push(`\nTO I RITME D'AQUEST CAPÃTOL: ${cap.toRitme}`);
  }

  // 7. Corba de tensiÃ³
  const tensio = (ESTAT._corbaTensio || []).find(t => t.capitol === idx + 1);
  if (tensio) {
    const instrRitme = getInstruccionsRitme(tensio.nivell, tensio.tipus);
    parts.push(`\nNIVELL DE TENSIÃ“ OBJECTIU: ${tensio.nivell}/10 (${tensio.tipus || ''})`);
    parts.push(`INSTRUCCIONS DE PROSA: ${instrRitme}`);
  }

  // 8. Context de la bÃ­blia narrativa
  const biblia = ESTAT.bibliaNarrativa;
  if (biblia) {
    const bibliaLines = [];
    if (biblia.fets_canonics && biblia.fets_canonics.length > 0) {
      bibliaLines.push('FETS CANÃ’NICS ESTABLERTS (NO CONTRADIR):');
      biblia.fets_canonics.slice(-8).forEach(f => bibliaLines.push('- ' + f));
    }
    // Filtrem fitxes dels personatges que apareixen en aquest capÃ­tol
    const capEst = ESTAT._estructuraCapitols[idx];
    const personatgesCap = (capEst && capEst.personatges) ? capEst.personatges : [];
    const fitxesRellevants = (biblia.fitxes_personatges || []).filter(f =>
      personatgesCap.some(nom =>
        nom.toLowerCase().includes((f.nom || '').toLowerCase()) ||
        (f.nom || '').toLowerCase().includes(nom.toLowerCase())
      )
    );
    if (fitxesRellevants.length > 0) {
      bibliaLines.push('ESTAT ACTUAL DELS PERSONATGES PRESENTS:');
      fitxesRellevants.forEach(f => {
        bibliaLines.push(`- ${f.nom}: ${f.estat_actual || '(no definit)'}`);
        if (f.motivacions) bibliaLines.push(`  MotivaciÃ³: ${f.motivacions}`);
      });
    }
    if (biblia.regles_mon && biblia.regles_mon.length > 0) {
      bibliaLines.push('REGLES DEL MÃ“N (respecta-les sempre):');
      biblia.regles_mon.forEach(r => bibliaLines.push('- ' + r));
    }
    if (bibliaLines.length > 0) {
      parts.push('\n' + bibliaLines.join('\n'));
    }
  }

  // 9. Context de trames actives en aquest capÃ­tol
  const trames = ESTAT.trames;
  if (trames && (trames.trama_principal || trames.subtrames.length > 0)) {
    const tramesLines = ['\nTRAMES ACTIVES EN AQUEST CAPÃTOL:'];
    if (trames.trama_principal) {
      const tp = trames.trama_principal;
      tramesLines.push('Trama principal: ' + (typeof tp === 'string' ? tp : (tp.descripcio || JSON.stringify(tp))));
    }
    const mapaEntry = (trames.mapa_entrellacat || []).find(m => m.capitol === idx + 1);
    if (mapaEntry && mapaEntry.trames_actives) {
      const subActive = trames.subtrames.filter(st =>
        mapaEntry.trames_actives.some(t =>
          t === st.nom || t.toLowerCase().includes((st.nom || '').toLowerCase())
        )
      );
      subActive.forEach(st => tramesLines.push(`Subtrama "${st.nom}": ${st.descripcio || ''}`));
    }
    parts.push(tramesLines.join('\n'));
  }

  // 10. Ajustos de rumb del darrer checkpoint
  if (ESTAT._ajustosRumb) {
    const ajustos = typeof ESTAT._ajustosRumb === 'string' ? ESTAT._ajustosRumb : JSON.stringify(ESTAT._ajustosRumb);
    if (ajustos && ajustos.trim()) {
      parts.push(`\nAJUSTOS DE RUMB (indicaciÃ³ del checkpoint de coherÃ¨ncia): ${ajustos}`);
    }
  }

  return parts.join('\n');
}

function buildContextCapitol(idx) {
  // PONT NKG: quan el NKG Ã©s actiu, delega a nkgGenerarContextMinim
  if (ESTAT._nkg) {
    const cap = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols[idx] : null;
    const escenaSpec = {
      capitol: idx + 1,
      escena: 1,
      personatges: cap ? (cap.personatges || []) : [],
      lloc: cap ? (cap.localitzacio || '') : '',
      escaleta: null
    };
    return nkgGenerarContextMinim(escenaSpec);
  }
  return buildContextCapitolLegacy(idx);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10: Estructura de la novelÂ·la (Opus) â€” JSON
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEstructuraNovella(userConfig) {
  const personatgesCtx = ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0
    ? ESTAT._personatgesSeleccionats.join('\n')
    : '(No definit)';

  const brief = buildBriefNarratiu();

  // Context de trames (si s'han generat prÃ¨viament a la fase de trames)
  let tramesCtx = '';
  if (ESTAT.trames && ESTAT.trames.trama_principal) {
    const tp = ESTAT.trames.trama_principal;
    tramesCtx = `\nDISSENY DE TRAMES PREVI (integra'l a l'estructura capÃ­tol a capÃ­tol):
TRAMA PRINCIPAL: ${typeof tp === 'string' ? tp : (tp.descripcio || JSON.stringify(tp))}`;
    if (tp.conflicte_central) tramesCtx += `\nConflicte central: ${tp.conflicte_central}`;
    if (tp.arc_protagonista)  tramesCtx += `\nArc protagonista: ${tp.arc_protagonista}`;
    if (ESTAT.trames.subtrames.length > 0) {
      tramesCtx += '\nSUBTRAMES:';
      ESTAT.trames.subtrames.forEach(st => {
        tramesCtx += `\n- ${st.nom} (caps. ${st.capitol_inici || '?'}-${st.capitol_resolucio || '?'}): ${st.descripcio || ''}`;
      });
    }
  }

  const msgs = [{
    role: 'user',
    content: `A partir del conte original, la bÃ­blia de mÃ³n i l'elenc, crea l'estructura completa de la novelÂ·la.

${brief}

CONTE ORIGINAL (resum):
${ESTAT.conteText ? ESTAT.conteText.substring(0, 2000) + (ESTAT.conteText.length > 2000 ? '\n[â€¦conte truncat per espaiâ€¦]' : '') : '(No disponible)'}

BÃBLIA DE MÃ“N:
${ESTAT.worldbuilding ? ESTAT.worldbuilding.substring(0, 1500) + (ESTAT.worldbuilding.length > 1500 ? '\n[â€¦]' : '') : '(No definida)'}

ELENC DE PERSONATGES SELECCIONATS:
${personatgesCtx}

ESTILS DE PARLA (resum):
${ESTAT.estilsParla ? ESTAT.estilsParla.substring(0, 1000) + (ESTAT.estilsParla.length > 1000 ? '\n[â€¦]' : '') : '(No definits)'}${tramesCtx}

NOMBRE DE CAPÃTOLS: Entre 12 i 14 capÃ­tols. La decisiÃ³ depÃ¨n de la complexitat:
- 12 capÃ­tols: Trama lineal, 1-2 personatges principals, 0-1 subtrames.
  Estructura: 3 actes (4+4+4), ritme Ã gil, cada capÃ­tol aporta quelcom imprescindible.
- 13 capÃ­tols: Trama principal + 1 subtrama significativa, o 3 personatges principals
  que necessiten espai per desenvolupar els seus arcs.
- 14 capÃ­tols: Trama principal + 2 subtrames, o trama complexa amb mÃºltiples girs
  que necessiten preparaciÃ³ i resoluciÃ³ adequada.

REGLA D'OR: Si dubtes entre 12 i 13, tria 12. Si dubtes entre 13 i 14, tria 13.
Cada capÃ­tol ha de justificar la seva existÃ¨ncia â€” si un capÃ­tol es pot fusionar
amb l'anterior o el posterior sense perdre res essencial, fusiona'l.
NO superis MAI 14 capÃ­tols. Una novelÂ·la curta i intensa Ã©s millor que una novelÂ·la llarga i diluÃ¯da.

INSTRUCCIONS DE CORBA DE TENSIÃ“:
La "corba_tensio" ha de seguir una estructura dramÃ tica adaptada al nombre de capÃ­tols:

PER A 12 CAPÃTOLS (estructura 3-5-4):
  - CapÃ­tols 1-3: Acte I (exposiciÃ³ â†’ incident detonant)
    Â· Cap 1: nivell 3 (establir mÃ³n i protagonista)
    Â· Cap 2: nivell 4 (complicaciÃ³, presentar conflicte)
    Â· Cap 3: nivell 6 (primer punt de gir â€” no hi ha marxa enrere)
  - CapÃ­tols 4-8: Acte II (desenvolupament â†’ crisi)
    Â· Cap 4-5: nivell 5-6 (explorar el conflicte, subtrames)
    Â· Cap 6: nivell 7 (punt mig â€” revelaciÃ³ o gir)
    Â· Cap 7: nivell 8 (complicaciÃ³ greu)
    Â· Cap 8: nivell 9 (tot sembla perdut)
  - CapÃ­tols 9-12: Acte III (clÃ­max â†’ resoluciÃ³)
    Â· Cap 9: nivell 8 (reorganitzaciÃ³, pla desesperat)
    Â· Cap 10: nivell 10 (CLÃMAX)
    Â· Cap 11: nivell 7 (resoluciÃ³ del conflicte)
    Â· Cap 12: nivell 4-5 (tancament, epÃ­leg narratiu)

PER A 13-14 CAPÃTOLS: Mateixa estructura perÃ² l'Acte II s'expandeix
amb 1-2 capÃ­tols addicionals de desenvolupament (nivell 5-7).

IMPORTANT: La corba NO Ã©s lineal ascendent. Ha d'OSCILÂ·LAR:
desprÃ©s de cada pic de tensiÃ³, ha d'haver-hi un moment de respir.
Alterna capÃ­tols d'acciÃ³ (frases curtes, diÃ leg rÃ pid) amb capÃ­tols
de respiraciÃ³ (introspectiu, descriptiu, exploraciÃ³ de relacions).

IMPORTANT: Has de completar TOTS els capÃ­tols. El JSON ha de contenir exactament tantes entrades a l'array "capitols" com el "nombre_capitols" que decideixis.
IMPORTANT: L'array "capitols" ha de contenir EXACTAMENT el nombre de capÃ­tols indicat a "nombre_capitols". Prioritza completar tots els capÃ­tols encara que les descripcions dels Ãºltims siguin mÃ©s breus. Un JSON truncat Ã©s INACCEPTABLE.

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "nombre_capitols": 12,
  "justificacio_capitols": "Explica en 2-3 lÃ­nies per quÃ¨ has triat N capÃ­tols i no N-1 o N+1",
  "arc_global": "descripciÃ³ de l'arc narratiu complet en 5-8 lÃ­nies",
  "temes_centrals": ["tema1", "tema2", "tema3"],
  "prefiguracions": [
    {"plantada_capitol": 2, "resolucio_capitol": 8, "element": "descripciÃ³ de l'element plantat"},
    {"plantada_capitol": 3, "resolucio_capitol": 11, "element": "descripciÃ³ de l'element plantat"}
  ],
  "corba_tensio": [
    {"capitol": 1, "nivell": 3, "tipus": "exposiciÃ³"},
    {"capitol": 2, "nivell": 5, "tipus": "complicaciÃ³"}
  ],
  "capitols": [
    {
      "numero": 1,
      "titol": "tÃ­tol evocador",
      "resum": "resum de 3-5 lÃ­nies",
      "personatges": ["nom1", "nom2"],
      "fil_principal": "fil narratiu que avanÃ§a",
      "to_ritme": "lent i introspectiu / trepidant / etc.",
      "prefiguracions_a_plantar": ["element que es plantarÃ  aquÃ­"],
      "prefiguracions_a_recollir": ["element plantat abans que es resol aquÃ­"],
      "connexio_anterior": "com lliga amb l'anterior",
      "connexio_seguent": "com prepara el segÃ¼ent"
    }
  ]
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un arquitecte narratiu expert en estructures de novelÂ·la. Retornes EXCLUSIVAMENT un objecte JSON vÃ lid, sense cap text addicional ni markdown. Escrius els valors de text en catalÃ .',
    Object.assign({}, userConfig, { maxTokens: 16384 }),
    'arquitectura'
  );
  return { response };
}

async function completarEstructuraCapitols(capitolsExistents, capsEsperats, userConfig) {
  const ultimCapitol = capitolsExistents[capitolsExistents.length - 1];
  const primerACompletar = ultimCapitol ? ultimCapitol.numero + 1 : capitolsExistents.length + 1;
  const capsQueFalten = capsEsperats - capitolsExistents.length;

  const resumExistents = capitolsExistents.map(c =>
    `Cap. ${c.numero}: "${c.titol}" â€” ${(c.resum || '').substring(0, 80)}`
  ).join('\n');

  const msgs = [{
    role: 'user',
    content: `L'estructura de la novelÂ·la estÃ  incompleta. Tens els primers ${capitolsExistents.length} capÃ­tols i falten els capÃ­tols ${primerACompletar} a ${capsEsperats}.

CAPÃTOLS JA DEFINITS:
${resumExistents}

ARC GLOBAL: ${ESTAT._arcGlobal || '(no disponible)'}
FINAL PLANIFICAT: ${ESTAT.finalTriat || '(no definit)'}

CORBA DE TENSIÃ“ per als capÃ­tols que falten:
${(ESTAT._corbaTensio || []).filter(t => t.capitol >= primerACompletar).map(t => `Cap.${t.capitol}: nivell ${t.nivell} (${t.tipus})`).join(', ') || '(no disponible)'}

Genera EXACTAMENT ${capsQueFalten} capÃ­tols (del ${primerACompletar} al ${capsEsperats}).

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "capitols": [
    {
      "numero": ${primerACompletar},
      "titol": "tÃ­tol evocador",
      "resum": "resum de 2-3 lÃ­nies",
      "personatges": ["nom1", "nom2"],
      "fil_principal": "fil narratiu",
      "to_ritme": "to i ritme",
      "prefiguracions_a_plantar": [],
      "prefiguracions_a_recollir": [],
      "connexio_anterior": "com lliga amb l'anterior",
      "connexio_seguent": "com prepara el segÃ¼ent"
    }
  ]
}

CRÃTIC: Han de ser EXACTAMENT ${capsQueFalten} capÃ­tols. L'Ãºltim (${capsEsperats}) ha de conduir al final planificat.`
  }];

  const response = await callLLMMulti(msgs,
    'Ets un arquitecte narratiu. Retorna EXCLUSIVAMENT JSON vÃ lid amb els capÃ­tols que falten.',
    Object.assign({}, userConfig, { maxTokens: 6000 }), 'arquitectura');
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 11: Escriure capÃ­tol (Sonnet) â€” FASE 3: Context complet
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function escriureCapitol(idx, userConfig) {
  const cap          = ESTAT._estructuraCapitols[idx];
  const capPlanificacio = cap ? (cap.resum || cap.text) : `CapÃ­tol ${idx + 1}`;
  const context      = buildContextCapitol(idx);
  const systemPrompt = buildSystemPromptCapitol();

  // Instruccions de personatges presents i els seus estils
  const persPresents = cap && cap.personatges ? cap.personatges : [];
  let instruccionsVeu = '';
  if (persPresents.length > 0 && ESTAT.estilsParla) {
    instruccionsVeu = `\n\nPERSONATGES EN AQUEST CAPÃTOL I ELS SEUS ESTILS DE PARLA:
Aplica estrictament l'estil de veu definit per a cada personatge en els seus diÃ legs.
Cada personatge ha de sonar inconfusiblement diferent dels altres.
Personatges presents: ${persPresents.join(', ')}`;
  }

  const msgs = [{
    role: 'user',
    content: `Escriu el CAPÃTOL ${idx + 1} de la novelÂ·la.

PLANIFICACIÃ“ D'AQUEST CAPÃTOL:
${capPlanificacio}

${context}
${instruccionsVeu}

INSTRUCCIONS D'ESCRIPTURA:
- Entre 1800 i 2500 paraules
- ComenÃ§a directament amb la narraciÃ³, sense titular el capÃ­tol
- Si hi ha prefiguracions a plantar, integra-les de forma subtil i natural (el lector no ha de notar-les en primera lectura)
- Si hi ha prefiguracions a recollir, dona'ls resoluciÃ³ satisfactÃ²ria
- Respecta el nivell de tensiÃ³ objectiu i el to indicat
- Si no Ã©s el primer capÃ­tol, la primera frase ha de connectar fluÃ¯dament amb el final del capÃ­tol anterior
- Escriu en catalÃ `
  }];

  const response = await callLLMMulti(msgs, systemPrompt, Object.assign({}, userConfig, { maxTokens: 6000 }), 'generacio');
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Actualitzar Llibre de Registre (Sonnet â€” background)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function actualitzarRegistre(textCapitol, idx, userConfig) {
  const reg = ESTAT.llibreRegistre;
  const registreAnterior = reg.capitols && reg.capitols[idx - 1]
    ? JSON.stringify(reg.capitols[idx - 1], null, 2)
    : JSON.stringify({ estat_personatges: [], fils_oberts: [], fils_tancats: [] });

  const msgs = [{
    role: 'user',
    content: `Ets un Script Supervisor. A partir del Llibre de Registre actual i el nou capÃ­tol, actualitza l'estat.

LLIBRE DE REGISTRE ACTUAL:
${registreAnterior}

CAPÃTOL ${idx + 1} ACABAT DE GENERAR:
${textCapitol.substring(0, 4000)}${textCapitol.length > 4000 ? '\n[â€¦text truncatâ€¦]' : ''}

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense cap text addicional, sense markdown):
{
  "resum_capitol": "resum de 2-3 frases del capÃ­tol",
  "estat_personatges": [{"nom": "nom", "ubicacio": "on Ã©s ara", "estat_actual": "situaciÃ³ emocional/fÃ­sica actual"}],
  "fils_oberts": ["fil narratiu que queda obert o s'ha introduÃ¯t"],
  "fils_tancats": ["fil narratiu que s'ha resolt en aquest capÃ­tol"],
  "prefiguracions_detectades": ["element que apareix en aquest capÃ­tol i podria ser una prefiguraciÃ³ o referÃ¨ncia a una"]
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un supervisor narratiu. Retornes EXCLUSIVAMENT un objecte JSON vÃ lid, sense cap altre text.',
    Object.assign({}, userConfig, { maxTokens: 1500 }),
    'generacio'
  );
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RevisiÃ³ inter-capÃ­tol (Opus) â€” FASE 5: verifica prefiguracions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function revisarCapitol(textCapitol, idx, userConfig) {
  const cap       = ESTAT._estructuraCapitols[idx];
  const capText   = cap ? cap.resum || cap.text : '';
  const registreCtx = buildRegistreContext(idx);
  const { aPlantarAra, aRecollirAra } = getPrefiguracionsActives(idx);

  let prefCtx = '';
  if (aPlantarAra.length > 0) {
    prefCtx += '\nPREFIGURACIONS QUE CALIA PLANTAR EN AQUEST CAPÃTOL:\n' +
      aPlantarAra.map(p => `- ${p.element}`).join('\n');
  }
  if (aRecollirAra.length > 0) {
    prefCtx += '\nPREFIGURACIONS QUE CALIA RECOLLIR EN AQUEST CAPÃTOL:\n' +
      aRecollirAra.map(p => `- ${p.element}`).join('\n');
  }

  const msgs = [{
    role: 'user',
    content: `Revisa aquest capÃ­tol i comprova la coherÃ¨ncia amb la planificaciÃ³ i el Registre narratiu.

PLANIFICACIÃ“ D'AQUEST CAPÃTOL:
${capText}
${registreCtx}
${prefCtx}

CAPÃTOL ${idx + 1} GENERAT:
${textCapitol.substring(0, 5000)}${textCapitol.length > 5000 ? '\n[â€¦text truncatâ€¦]' : ''}

Verifica especÃ­ficament:
- Si el capÃ­tol havia de plantar una prefiguraciÃ³, s'ha fet de forma subtil?
- Si el capÃ­tol havia de recollir una prefiguraciÃ³, s'ha resolt satisfactÃ²riament?
- Hi ha algun element que contradigui una prefiguraciÃ³ plantada anteriorment?

AVALUACIÃ“ DE GANXOS (Hook Review):
Avalua els elements narratius de ganxo del capÃ­tol:
1. OBERTURA: El primer parÃ graf captura l'atenciÃ³? (escena in medias res, pregunta o tensiÃ³ immediata?)
2. CLIFFHANGER: El final del capÃ­tol deixa el lector amb ganes de continuar? Hi ha una tensiÃ³ sense resoldre, una revelaciÃ³ o un dilema?
3. RITME INTERN: El capÃ­tol mantÃ© un ritme adequat al seu tipus (acciÃ³/respiraciÃ³)? Hi ha un equilibri entre diÃ leg, acciÃ³ i descripciÃ³?
4. PROMESA NARRATIVA: El capÃ­tol avanÃ§a alguna trama o planteja una pregunta que el lector vol veure resolta?

SELECCIÃ“ DE PASSATGE:
A mÃ©s de la revisiÃ³, selecciona el MILLOR passatge del capÃ­tol (entre 150 i 250 paraules) que millor exemplifiqui la veu narrativa. Copia'l literalment del text.

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense cap text addicional, sense markdown):
{
  "puntuacio": 8,
  "problemes": ["descripciÃ³ concreta del problema 1"],
  "instruccions_correccio": "instruccions clares per a Sonnet per reescriure si cal (buit si no cal)",
  "ok_per_continuar": true,
  "prefiguracions_ok": true,
  "prefiguracions_problemes": ["descripciÃ³ del problema de prefiguraciÃ³ si n'hi ha"],
  "hook_review": {
    "obertura_puntuacio": 7,
    "obertura_comentari": "comentari breu sobre l'obertura",
    "cliffhanger_puntuacio": 6,
    "cliffhanger_comentari": "comentari breu sobre el cliffhanger",
    "ritme_puntuacio": 8,
    "ritme_comentari": "comentari breu sobre el ritme intern",
    "promesa_puntuacio": 7,
    "promesa_comentari": "comentari breu sobre la promesa narrativa"
  },
  "instruccions_cliffhanger": "instruccions concretes per millorar el cliffhanger si la puntuaciÃ³ Ã©s < 6 (buit si no cal)",
  "golden_passage": "el text del millor passatge (150-250 paraules)"
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari sÃ¨nior especialitzat en narrativa de pÃ gina. Retornes EXCLUSIVAMENT un objecte JSON vÃ lid, sense cap altre text.',
    Object.assign({}, userConfig, { maxTokens: 2000 }),
    'arquitectura'
  );

  // Desa les instruccions per si cal reescriure
  const revisat = parseJsonRobust(response);
  if (revisat && revisat.instruccions_correccio) {
    ESTAT._revisioInstruccions = ESTAT._revisioInstruccions || {};
    ESTAT._revisioInstruccions[idx] = revisat.instruccions_correccio;
  }

  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 6: RevisiÃ³ Global Transversal (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function revisioGlobalOpusAPI(userConfig) {
  // Fragments clau de cada capÃ­tol: primer + mig + Ãºltim parÃ graf
  const fragments = ESTAT._capitols_generats.map((text, i) => {
    if (!text) return null;
    const pars = text.split(/\n\n+/).filter(p => p.trim());
    if (pars.length === 0) return null;
    const primer = pars[0].substring(0, 300);
    const mig    = pars.length > 2 ? pars[Math.floor(pars.length / 2)].substring(0, 300) : '';
    const ultim  = pars[pars.length - 1].substring(0, 300);
    return `--- CAPÃTOL ${i + 1} ---\nINICI: ${primer}${mig ? '\nMIG: ' + mig : ''}\nFINAL: ${ultim}`;
  }).filter(Boolean).join('\n\n');

  // Resums del registre
  const resums = (ESTAT.llibreRegistre.capitols || [])
    .map((c, i) => c ? `Cap.${i + 1}: ${c.resum_capitol || ''}` : '')
    .filter(Boolean).join('\n');

  const prefLlistat = llistarPrefiguracions();

  const msgs = [{
    role: 'user',
    content: `Revisa la novelÂ·la transversalment. Tens fragments representatius de cada capÃ­tol i els resums complets.

${buildBriefNarratiu()}

PREFIGURACIONS PLANIFICADES:
${prefLlistat}

RESUMS DE TOTS ELS CAPÃTOLS:
${resums || '(No disponibles)'}

FRAGMENTS REPRESENTATIUS DELS CAPÃTOLS:
${fragments || '(No disponibles)'}

Avalua:
1. COHERÃˆNCIA DE VEU: El narrador mantÃ© el mateix registre al llarg de la novelÂ·la? Detecta canvis de to injustificats.
2. REPETICIONS: Hi ha escenes, diÃ legs o descripcions que es repeteixen entre capÃ­tols?
3. COHERÃˆNCIA FACTUAL: Detalls concrets (colors, noms, distÃ ncies, dates) sÃ³n consistents?
4. PREFIGURACIONS: Totes les plantades s'han resolt? N'hi ha alguna pendent?
5. ARCS DE PERSONATGE: Cada personatge ha evolucionat? Algun s'ha estancat o ha desaparegut?
6. RITME GLOBAL: La novelÂ·la respira bÃ©? Hi ha zones mortes o massa llargues?

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "puntuacio_global": 7,
  "veu_consistent": true,
  "problemes": [{"capitol": 3, "tipus": "repeticiÃ³", "descripcio": "descripciÃ³ del problema", "gravetat": "mitja"}],
  "capitols_a_reescriure": [3],
  "instruccions_reescriptura": {"3": "instruccions concretes per al capÃ­tol 3"},
  "prefiguracions_pendents": ["element no resolt"],
  "veredicte": "text lliure amb el diagnÃ²stic general en catalÃ "
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari sÃ¨nior fent una revisiÃ³ global transversal. Retornes EXCLUSIVAMENT un objecte JSON vÃ lid. Els textos han de ser en catalÃ .',
    Object.assign({}, userConfig, { maxTokens: 3000 }),
    'arquitectura'
  );
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Reescriure capÃ­tol amb instruccions d'Opus (Sonnet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function reescriureCapitolAmbInstruccions(idx, instruccions, userConfig) {
  const textActual  = ESTAT._capitols_generats[idx] || '';
  const cap         = ESTAT._estructuraCapitols[idx];
  const capText     = cap ? cap.text : '';
  const systemPrompt= buildSystemPromptCapitol();

  const msgs = [{
    role: 'user',
    content: `Reescriu el CapÃ­tol ${idx + 1} incorporant les correccions de l'editor.

PLANIFICACIÃ“ DEL CAPÃTOL:
${capText}

CAPÃTOL ACTUAL:
${textActual.substring(0, 4000)}${textActual.length > 4000 ? '\n[â€¦]' : ''}

INSTRUCCIONS DE CORRECCIÃ“ DE L'EDITOR (Opus):
${instruccions}

Reescriu el capÃ­tol complet incorporant les correccions. MantÃ©n la mateixa veu i extensiÃ³ (~2000 paraules). Escriu directament la narraciÃ³ en catalÃ , sense tÃ­tol ni notes.`
  }];

  const response = await callLLMMulti(msgs, systemPrompt, Object.assign({}, userConfig, { maxTokens: 6000 }), 'generacio');
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 12: Control d'Arcs Narratius (Opus) â€” FASE 9: context complet
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function controlArcsNovella(userConfig) {
  const reg = ESTAT.llibreRegistre;
  const resums = (reg.capitols || [])
    .map((c, i) => c ? `CapÃ­tol ${i + 1}: ${c.resum_capitol || '(sense resum)'}` : '')
    .filter(Boolean)
    .join('\n');

  const filsOberts  = (reg.fils_oberts  || []).map(f => `- ${f}`).join('\n') || '(Cap registrat)';
  const filsTancats = (reg.fils_tancats || []).map(f => `- ${f}`).join('\n') || '(Cap registrat)';

  // Estructura completa (JSON si disponible, text si legacy)
  const estructuraCompleta = ESTAT.estructuraNovella || '(No disponible)';

  // Prefiguracions i si s'han resolt
  const prefCtx = llistarPrefiguracions();

  // Resultats de la revisiÃ³ global (si existeix)
  const revisioGlobalCtx = ESTAT._revisioGlobal
    ? ESTAT._revisioGlobal.veredicte || '(No disponible)'
    : '(No s\'ha realitzat revisiÃ³ global)';

  const msgs = [{
    role: 'user',
    content: `Ets un editor sÃ¨nior avaluant una novelÂ·la a partir dels resums dels capÃ­tols.

${buildBriefNarratiu()}

PREFIGURACIONS PLANIFICADES:
${prefCtx}

RESULTAT DE LA REVISIÃ“ GLOBAL (Opus transversal):
${revisioGlobalCtx}

ESTRUCTURA PLANIFICADA ORIGINALMENT:
${estructuraCompleta}

RESUMS DELS CAPÃTOLS ESCRITS:
${resums || '(Cap capÃ­tol generat)'}

FILS NARRATIUS OBERTS: ${filsOberts}
FILS NARRATIUS TANCATS: ${filsTancats}

Revisa i diagnostica:
1. S'ha complert la premissa original?
2. El final planificat s'ha executat adequadament?
3. Queden fils oberts greus que fan la novelÂ·la incompleta?
4. Hi ha incoherÃ¨ncies de personatges o de trama detectades als resums?
5. Totes les prefiguracions planificades s'han resolt? Indica explÃ­citament quines queden obertes.

Retorna un diagnÃ²stic detallat en catalÃ . Si hi ha fils oberts greus, prefiguracions no resoltes o el final no s'ha resolt adequadament, proposa detalladament el contingut d'un EPÃLEG que els tanqui (secciÃ³ clarament marcada com "PROPOSTA D'EPÃLEG").`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor sÃ¨nior de novelÂ·la. Analitzes amb rigor i retornes un diagnÃ²stic constructiu i accionable en catalÃ .',
    Object.assign({}, userConfig, { maxTokens: 3500 }),
    'arquitectura'
  );
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EpÃ­leg Resolutiu (Sonnet) â€” FASE 7: context real
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEpileg(instruccionsOpus, userConfig) {
  const registreCtx  = buildRegistreContext(ESTAT._estructuraCapitols.length);
  const systemPrompt = buildSystemPromptCapitol();

  // Ãšltim capÃ­tol complet (o Ãºltims 3000 chars)
  const numCaps      = ESTAT._capitols_generats.length;
  const ultimCapText = numCaps > 0 && ESTAT._capitols_generats[numCaps - 1]
    ? ESTAT._capitols_generats[numCaps - 1].slice(-3000)
    : '(No disponible)';

  // Primer parÃ graf del primer capÃ­tol (per tancament circular)
  const primerCapText = ESTAT._capitols_generats[0]
    ? ESTAT._capitols_generats[0].split(/\n\n+/).filter(p => p.trim())[0] || ''
    : '';

  // Prefiguracions pendents (de la revisiÃ³ global si existeix)
  const prefsPendents = ESTAT._revisioGlobal && Array.isArray(ESTAT._revisioGlobal.prefiguracions_pendents)
    ? ESTAT._revisioGlobal.prefiguracions_pendents
    : [];

  const msgs = [{
    role: 'user',
    content: `Escriu l'EPÃLEG de la novelÂ·la seguint les instruccions de l'editor.

${buildBriefNarratiu()}

DIAGNÃ’STIC I INSTRUCCIONS DE L'EDITOR (Opus):
${instruccionsOpus ? instruccionsOpus.substring(0, 2000) : '(No disponible)'}
${registreCtx}

PRIMER PARÃ€GRAF DE LA NOVELÂ·LA (per tancar el cercle narratiu):
${primerCapText || '(No disponible)'}

ÃšLTIM CAPÃTOL (per continuÃ¯tat de to i escena):
${ultimCapText}

${prefsPendents.length > 0 ? 'PREFIGURACIONS PENDENTS DE RESOLUCIÃ“:\n' + prefsPendents.map(p => `- ${p}`).join('\n') : ''}

L'epÃ­leg ha de:
- Tancar els fils narratius indicats per l'editor
- Connectar directament amb l'escena final de l'Ãºltim capÃ­tol (continuÃ¯tat de to)
- Fer eco del primer parÃ graf de la novelÂ·la (tancament circular)
- Tenir entre 600 i 1200 paraules
- Resoldre les prefiguracions pendents si n'hi ha

Escriu directament el text de l'epÃ­leg en catalÃ , sense tÃ­tol ni notes de l'autor.`
  }];

  const response = await callLLMMulti(msgs, systemPrompt, Object.assign({}, userConfig, { maxTokens: 3500 }), 'generacio');
  return { response };
}

// â”€â”€â”€ SISTEMA 1: BÃ­blia Narrativa â€” backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function inicialitzarBiblia(userConfig) {
  const brief = buildBriefNarratiu();
  const personatgesCtx = ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0
    ? ESTAT._personatgesSeleccionats.join('\n')
    : '(No definit)';

  const msgs = [{
    role: 'user',
    content: `Crea una bÃ­blia narrativa estructurada a partir del material existent.

${brief}

CONTE ORIGINAL (resum):
${ESTAT.conteText ? ESTAT.conteText.substring(0, 2000) + (ESTAT.conteText.length > 2000 ? '\n[â€¦]' : '') : '(No disponible)'}

BÃBLIA DE MÃ“N:
${ESTAT.worldbuilding ? ESTAT.worldbuilding.substring(0, 1500) + (ESTAT.worldbuilding.length > 1500 ? '\n[â€¦]' : '') : '(No definida)'}

ELENC DE PERSONATGES:
${personatgesCtx}

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "regles_mon": ["regla del mÃ³n 1", "regla del mÃ³n 2"],
  "llocs_importants": [{"nom": "nom del lloc", "descripcio": "descripciÃ³ breu del lloc i el seu paper"}],
  "objectes_clau": [{"nom": "nom de l'objecte", "significat": "significat narratiu o simbÃ²lic"}],
  "fitxes_personatges": [
    {
      "nom": "nom",
      "motivacions": "motivaciÃ³ principal (1 frase)",
      "secrets": "secret principal o buit",
      "estat_actual": "estat breu (1 frase)"
    }
  ],
  "fets_canonics": ["fet establert que NO es pot contradir 1", "fet establert 2"]
}

IMPORTANT: El JSON ha de ser COMPLET amb TOTS els personatges de l'elenc. MantÃ©n les descripcions concises (1 frase per camp) per assegurar que el JSON no es talli.`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari creant una bÃ­blia narrativa de referÃ¨ncia. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 6000 }),
    'arquitectura'
  );

  const dades = parseJsonRobust(response);
  if (dades) {
    if (dades.regles_mon)         ESTAT.bibliaNarrativa.regles_mon         = dades.regles_mon;
    if (dades.llocs_importants)   ESTAT.bibliaNarrativa.llocs_importants   = dades.llocs_importants;
    if (dades.objectes_clau)      ESTAT.bibliaNarrativa.objectes_clau      = dades.objectes_clau;
    if (dades.fitxes_personatges) ESTAT.bibliaNarrativa.fitxes_personatges = dades.fitxes_personatges;
    if (dades.fets_canonics)      ESTAT.bibliaNarrativa.fets_canonics      = dades.fets_canonics;
  }
  return { response };
}

async function completarBibliaPersonatges(userConfig) {
  const biblia = ESTAT.bibliaNarrativa;
  const nomsExistents = (biblia.fitxes_personatges || []).map(f => f.nom.toLowerCase());
  const personatgesFaltants = (ESTAT._personatgesSeleccionats || []).filter(nom => {
    const nomNet = nom.replace(/\*\*/g, '').split('|')[0].split(',')[0].trim().toLowerCase();
    return !nomsExistents.some(n => n.includes(nomNet) || nomNet.includes(n));
  });

  if (personatgesFaltants.length === 0) return;

  const msgs = [{
    role: 'user',
    content: `Crea fitxes per als personatges que falten a la bÃ­blia narrativa.

PERSONATGES QUE JA TENEN FITXA: ${nomsExistents.join(', ') || '(cap)'}

PERSONATGES QUE FALTEN:
${personatgesFaltants.join('\n')}

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "fitxes_personatges": [
    {
      "nom": "nom",
      "motivacions": "motivaciÃ³ principal (1 frase)",
      "secrets": "secret principal o buit",
      "estat_actual": "estat breu (1 frase)"
    }
  ]
}

Descripcions concises: 1 frase per camp.`
  }];

  const response = await callLLMMulti(msgs,
    'Retorna EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 2000 }), 'arquitectura');

  const dades = parseJsonRobust(response);
  if (dades && dades.fitxes_personatges) {
    biblia.fitxes_personatges = (biblia.fitxes_personatges || []).concat(dades.fitxes_personatges);
    console.log(`BÃ­blia completada: ${biblia.fitxes_personatges.length} fitxes totals`);
  }
}

async function actualitzarBiblia(textCapitol, idx, userConfig) {
  const biblia = ESTAT.bibliaNarrativa;
  const bibliaCurrent = JSON.stringify({
    fitxes_personatges: biblia.fitxes_personatges || [],
    fets_canonics:      (biblia.fets_canonics || []).slice(-10)
  });

  const msgs = [{
    role: 'user',
    content: `Actualitza la bÃ­blia narrativa amb el que ha passat en el CapÃ­tol ${idx + 1}.

BÃBLIA ACTUAL (resum):
${bibliaCurrent}

CAPÃTOL ${idx + 1} GENERAT:
${textCapitol.substring(0, 4000)}${textCapitol.length > 4000 ? '\n[â€¦text truncatâ€¦]' : ''}

Identifica NOMÃ‰S canvis reals (no repeteixis el que ja Ã©s a la bÃ­blia):

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid:
{
  "nous_fets_canonics": ["nou fet establert en aquest capÃ­tol"],
  "actualitzar_personatges": [
    {"nom": "nom", "nou_estat": "nou estat emocional/fÃ­sic", "nous_secrets": "secrets revelats o nous", "motivacions": "motivaciÃ³ actualitzada si ha canviat"}
  ],
  "nous_llocs": [{"nom": "lloc nou", "descripcio": "descripciÃ³"}],
  "nous_objectes": [{"nom": "objecte nou", "significat": "significat"}]
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari actualitzant una bÃ­blia narrativa. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 1500 }),
    'arquitectura'
  );

  const canvis = parseJsonRobust(response);
  aplicarCanvisBiblia(canvis);
  return { response };
}

// â”€â”€â”€ SISTEMA 2: Fase de Trames â€” backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function generarTrames(userConfig) {
  const brief = buildBriefNarratiu();
  const bibliaCtx = ESTAT.bibliaNarrativa.fitxes_personatges && ESTAT.bibliaNarrativa.fitxes_personatges.length > 0
    ? '\nPERSONATGES (bÃ­blia):\n' + ESTAT.bibliaNarrativa.fitxes_personatges.map(p => `${p.nom}: ${p.motivacions || ''}`).join('\n')
    : '';

  const msgs = [{
    role: 'user',
    content: `Dissenya l'arquitectura de trames per a aquesta novelÂ·la.

${brief}

CONTE ORIGINAL:
${ESTAT.conteText || '(No disponible)'}

BÃBLIA DE MÃ“N:
${ESTAT.worldbuilding || '(No definida)'}

ELENC DE PERSONATGES:
${ESTAT._personatgesSeleccionats ? ESTAT._personatgesSeleccionats.join('\n') : '(No definit)'}${bibliaCtx}

ESTILS DE PARLA:
${ESTAT.estilsParla || '(No definits)'}

Crea un disseny de trames entrellaÃ§ades que:
1. Tingui una trama principal clara que connecti amb el final planificat
2. 2-4 subtrames que enriqueixin el mÃ³n i els personatges secundaris
3. Un mapa de com les trames s'entrelaÃ§en capÃ­tol a capÃ­tol (aproximat, 12-14 capÃ­tols)
4. Cada subtrama ha de tenir una resoluciÃ³ prÃ²pia (no necessÃ riament al capÃ­tol final)

IMPORTANT: El JSON ha de ser COMPLET. El mapa_entrellacat ha de cobrir TOTS els capÃ­tols (12-14 entrades). Les notes del mapa han de ser MOLT breus (3-5 paraules mÃ xim per estalviar espai).

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid (sense markdown, sense text addicional):
{
  "trama_principal": {
    "descripcio": "descripciÃ³ de la trama principal en 3-5 lÃ­nies",
    "conflicte_central": "el conflicte central en una frase",
    "arc_protagonista": "com evoluciona el protagonista",
    "resolucio": "com i quan es resol"
  },
  "subtrames": [
    {
      "nom": "nom de la subtrama",
      "descripcio": "descripciÃ³ breu",
      "personatges_implicats": ["nom1", "nom2"],
      "capitol_inici": 2,
      "capitol_resolucio": 10,
      "com_entrellaÃ§a": "com s'entrellaÃ§a amb la trama principal"
    }
  ],
  "mapa_entrellacat": [
    {"capitol": 1, "trames_actives": ["trama_principal"], "notes": "establiment del mÃ³n"},
    {"capitol": 2, "trames_actives": ["trama_principal", "subtrama_1"], "notes": "s'introdueix la subtrama 1"}
  ]
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un arquitecte narratiu expert en construcciÃ³ de trames entrellaÃ§ades. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 8192 }),
    'arquitectura'
  );

  return { response };
}

async function completarMapaTrames(tramesTotals, capsEsperats, userConfig) {
  const tp = tramesTotals.trama_principal;
  const tpDesc = tp ? (typeof tp === 'string' ? tp : (tp.descripcio || JSON.stringify(tp))) : '?';
  const subtramesNoms = (tramesTotals.subtrames || []).map(st => st.nom).join(', ');
  const msgs = [{
    role: 'user',
    content: `Genera el mapa d'entrellaÃ§at COMPLET per a exactament ${capsEsperats} capÃ­tols.

TRAMA PRINCIPAL: ${tpDesc}
SUBTRAMES: ${subtramesNoms || '(cap)'}

Retorna EXCLUSIVAMENT un JSON vÃ lid amb EXACTAMENT ${capsEsperats} entrades:
{
  "mapa_entrellacat": [
    {"capitol": 1, "trames_actives": ["trama_principal"], "notes": "breu 3-5 paraules"},
    {"capitol": 2, "trames_actives": ["trama_principal", "nom_subtrama"], "notes": "breu"},
    ... fins a capitol ${capsEsperats}
  ]
}

CRÃTIC: Han de ser EXACTAMENT ${capsEsperats} entrades. Notes de 3-5 paraules MÃ€XIM.`
  }];
  const response = await callLLMMulti(msgs,
    'Retorna EXCLUSIVAMENT JSON vÃ lid. Cap text addicional.',
    Object.assign({}, userConfig, { maxTokens: 2048 }), 'arquitectura');
  return { response };
}

// â”€â”€â”€ SISTEMA 4: Checkpoint de coherÃ¨ncia â€” backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function executarCheckpoint(idx, userConfig) {
  const brief = buildBriefNarratiu();

  const capitolsEscrits = ESTAT._capitols_generats
    .slice(0, idx + 1)
    .map((text, i) => {
      if (!text) return null;
      const resum = (ESTAT.llibreRegistre.capitols[i] && ESTAT.llibreRegistre.capitols[i].resum_capitol)
        || text.substring(0, 300) + 'â€¦';
      return `CapÃ­tol ${i + 1}: ${resum}`;
    })
    .filter(Boolean)
    .join('\n');

  const ajustosAnteriors = ESTAT._ajustosRumb
    ? '\nAJUSTOS DE RUMB ANTERIORS:\n' + (typeof ESTAT._ajustosRumb === 'string' ? ESTAT._ajustosRumb : JSON.stringify(ESTAT._ajustosRumb))
    : '';

  const tramesCtx = ESTAT.trames.trama_principal
    ? `\nTRAMA PRINCIPAL: ${typeof ESTAT.trames.trama_principal === 'string' ? ESTAT.trames.trama_principal : (ESTAT.trames.trama_principal.descripcio || '')}
SUBTRAMES: ${ESTAT.trames.subtrames.length > 0 ? ESTAT.trames.subtrames.map(st => st.nom + ': ' + (st.descripcio || '')).join(' | ') : '(cap)'}`
    : '';

  const msgs = [{
    role: 'user',
    content: `Fes un checkpoint de coherÃ¨ncia narrativa desprÃ©s del CapÃ­tol ${idx + 1}.

${brief}${tramesCtx}

CAPÃTOLS ESCRITS FINS ARA:
${capitolsEscrits}${ajustosAnteriors}

Verifica:
1. CoherÃ¨ncia entre capÃ­tols (no contradiccions, no lapsus de memÃ²ria dels personatges)
2. Les subtrames s'estan desenvolupant com estava planificat
3. El ritme narratiu Ã©s adequat (ni massa accelerat ni estancat)
4. Les prefiguracions plantades es mantenen sense resoldre prematurament

Retorna EXCLUSIVAMENT un objecte JSON vÃ lid:
{
  "puntuacio_coherencia": 8,
  "valoracio_general": "descripciÃ³ breu de l'estat de la novelÂ·la en una frase",
  "problemes_detectats": ["problema concret 1 si n'hi ha"],
  "recomanacions": ["recomanaciÃ³ especÃ­fica per als prÃ²xims capÃ­tols"],
  "ajustos_rumb": "instruccions especÃ­fiques per als capÃ­tols ${idx + 2}-${idx + 4} si cal ajustar el rumb (buit si tot va bÃ©)"
}`
  }];

  const response = await callLLMMulti(
    msgs,
    'Ets un editor literari fent un checkpoint de coherÃ¨ncia narrativa. Retornes EXCLUSIVAMENT JSON vÃ lid.',
    Object.assign({}, userConfig, { maxTokens: 1500 }),
    'arquitectura'
  );

  const dades = parseJsonRobust(response);
  mostrarCheckpoint(dades, idx);
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 10.5: Generar Escaleta per Bloc de CapÃ­tols (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function generarEscaletaBloc(capitols, offset, userConfig) {
  const brief = buildBriefNarratiu();
  const capsText = capitols.map((c, i) => `Cap. ${offset + i + 1}: ${c.titol || ''} â€” ${c.resum || ''}`).join('\n');
  const corbaTensio = ESTAT._corbaTensio || [];
  const prompt = `Ets un dramaturg expert. Genera una escaleta detallada per escenes per als capÃ­tols segÃ¼ents de la novelÂ·la.

BRIEF:
${brief}

CAPÃTOLS A ESCALETEJAR:
${capsText}

ESCENES PER CAPÃTOL (adapta al ritme del capÃ­tol):
- CapÃ­tols d'exposiciÃ³/respiraciÃ³ (nivell tensiÃ³ â‰¤4): 3 escenes (~450 paraules/escena)
- CapÃ­tols de desenvolupament (nivell tensiÃ³ 5-7): 3-4 escenes (~500 paraules/escena)
- CapÃ­tols de clÃ­max/acciÃ³ (nivell tensiÃ³ â‰¥8): 4 escenes curtes (~400 paraules/escena, ritme rÃ pid)
- CapÃ­tol final/resoluciÃ³: 3 escenes (~550 paraules/escena, ritme pausat)

TOTAL OBJECTIU: ~1800-2200 paraules per capÃ­tol. La novelÂ·la completa ha de fer entre 24.000 i 31.000 paraules (12-14 capÃ­tols Ã— ~2000 paraules).

CORBA DE TENSIÃ“ (per orientar el ritme de cada capÃ­tol):
${corbaTensio.length > 0 ? corbaTensio.map(t => `Cap.${t.capitol}: nivell ${t.nivell} (${t.tipus})`).join(', ') : '(no disponible)'}

Cada escena ha d'incloure (camps OBLIGATORIS, res mÃ©s):
- nom: tÃ­tol breu (3-5 paraules)
- paraules_objectiu: nombre enter
- funcio_narrativa: 1 frase curta (mÃ xim 10 paraules)
- personatges: array de noms
- beat_narratiu: "diÃ leg" | "acciÃ³" | "introspecciÃ³" | "descripciÃ³"

NO incloguis emocio_entrada, emocio_sortida ni punt_inflexio per estalviar espai.

Retorna EXCLUSIVAMENT JSON vÃ lid:
{
  "escaletes": [
    {
      "capitol": 1,
      "titol": "tÃ­tol del capÃ­tol",
      "escenes": [
        {
          "nom": "nom breu",
          "paraules_objectiu": 450,
          "funcio_narrativa": "frase curta",
          "personatges": ["nom1"],
          "beat_narratiu": "diÃ leg"
        }
      ]
    }
  ]
}`;
  const msgs = [{ role: 'user', content: prompt }];
  const models = getModelConfig(userConfig);
  const response = await callLLMMulti(
    msgs,
    'Ets un dramaturg expert en narrativa i estructura d\'escenes.',
    Object.assign({}, userConfig, { maxTokens: 8192, model: models.modelArquitecte }),
    'arquitectura'
  );
  return { response };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FASE 11: Escriure capÃ­tol per escenes (usa escaleta)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function escriureCapitolPerEscenes(idx, userConfig) {
  const escaletaCapitol = ESTAT._escaletes.find(e => e.capitol === idx + 1);
  if (!escaletaCapitol || !escaletaCapitol.escenes || escaletaCapitol.escenes.length === 0) {
    return await escriureCapitol(idx, userConfig);
  }
  const systemPrompt = buildSystemPromptCapitol();
  const contextCapitol = buildContextCapitol(idx);
  const escenes = escaletaCapitol.escenes;
  let textsEscenes = [];
  for (let i = 0; i < escenes.length; i++) {
    const escena = escenes[i];
    if (document.getElementById('loader-11-text')) {
      document.getElementById('loader-11-text').textContent = `Escrivint capÃ­tol ${idx + 1} â€” Escena ${i + 1}/${escenes.length}: ${escena.nom || ''}â€¦`;
    }
    const promptEscena = `${contextCapitol}

## ESCENA ACTUAL A ESCRIURE
Escena ${i + 1} de ${escenes.length}: **${escena.nom || ''}**
FunciÃ³ narrativa: ${escena.funcio_narrativa || ''}
Personatges: ${(escena.personatges || []).join(', ')}
Paraules objectiu: ${escena.paraules_objectiu || 400}
${escena.punt_inflexio ? 'âš¡ Aquesta escena contÃ© un punt d\'inflexiÃ³ important.' : ''}

${i > 0 ? `TEXT DE L'ESCENA ANTERIOR:\n${textsEscenes[i-1].slice(-500)}\n\n` : ''}Escriu ara aquesta escena en prosa literÃ ria completa, sense tÃ­tols ni metadades. Aproximadament ${escena.paraules_objectiu || 400} paraules.`;
    const msgs = [{ role: 'user', content: promptEscena }];
    const res = await callLLMMulti(
      msgs,
      systemPrompt,
      Object.assign({}, userConfig, { maxTokens: Math.max(1200, (escena.paraules_objectiu || 400) * 2) }),
      'generacio'
    );
    textsEscenes.push(res || '');
  }
  return { response: textsEscenes.join('\n\n') };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CompressiÃ³ de MemÃ²ria Narrativa (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function comprimirMemoria(finsCapitol, userConfig) {
  const resumsAComprimir = (ESTAT.llibreRegistre.capitols || [])
    .slice(0, finsCapitol)
    .map(c => c ? c.resum_capitol : null)
    .filter(r => r);
  if (resumsAComprimir.length < 3) return;
  const prompt = `Ets un expert en narrativa. A continuaciÃ³ tens els resums dels primers ${finsCapitol} capÃ­tols d'una novelÂ·la. Crea una sinopsi comprimida en prosa fluÃ¯da de 400-500 paraules que capturi els elements essencials: trames principals, desenvolupament dels personatges, moments clau, i l'estat emocional i narratiu en aquest punt de la novelÂ·la.

RESUMS:
${resumsAComprimir.map((r, i) => `Cap. ${i + 1}: ${r}`).join('\n\n')}

Escriu la sinopsi en prosa contÃ­nua, sense llistes ni tÃ­tols. Ha de ser Ãºtil com a context per escriure els capÃ­tols segÃ¼ents.`;
  const msgs = [{ role: 'user', content: prompt }];
  const res = await callLLMMulti(
    msgs,
    'Ets un expert en sÃ­ntesi narrativa.',
    Object.assign({}, userConfig, { maxTokens: 1200 }),
    'arquitectura'
  );
  ESTAT._memoriasComprimides.push({
    finsCap: finsCapitol,
    text: res || ''
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NKG v4: Narrative Knowledge Graph
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function crearNKG() {
  return {
    personatges: {},
    llocs: {},
    objectes: {},
    fets_canonics: [],
    esdeveniments: [],
    relacions: [],
    ultima_actualitzacio: { capitol: 0, escena: 0 },
    versio: 1
  };
}

function nkgNormalitzarNom(nom) {
  if (!nom) return '';
  return nom.toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/\s+/g, '_').trim();
}

function nkgQueryPersonatge(nom) {
  const nkg = ESTAT._nkg;
  if (!nkg) return null;
  const clau = nkgNormalitzarNom(nom);
  const pers = nkg.personatges[clau];
  if (!pers) return null;

  const rels = nkg.relacions.filter(r =>
    nkgNormalitzarNom(r.origen) === clau || nkgNormalitzarNom(r.desti) === clau
  );
  const objectes = Object.values(nkg.objectes).filter(o =>
    o.posseidor && nkgNormalitzarNom(o.posseidor) === clau
  );
  const events = nkg.esdeveniments
    .filter(e => e.personatges_involucrats.some(p => nkgNormalitzarNom(p) === clau))
    .slice(-3);

  return { ...pers, relacions: rels, objectes_possedits: objectes, ultims_esdeveniments: events };
}

function nkgQueryEscenaContext(escenaSpec) {
  const nkg = ESTAT._nkg;
  if (!nkg) return '';

  const parts = [];
  const persPresents = escenaSpec.personatges || [];

  if (persPresents.length > 0) {
    parts.push('PERSONATGES EN ESCENA:');
    persPresents.forEach(nom => {
      const p = nkgQueryPersonatge(nom);
      if (p) {
        let desc = `â€¢ ${p.nom}: ${p.estat_emocional || 'neutre'}`;
        if (p.ubicacio) desc += ` | A: ${p.ubicacio}`;
        if (p.objectius && p.objectius.length > 0) desc += ` | Vol: ${p.objectius[0]}`;
        if (p.secrets && p.secrets.length > 0) desc += ` | Amaga: ${p.secrets[0]}`;
        parts.push(desc);

        if (p.relacions) {
          p.relacions.forEach(r => {
            const altreNom = nkgNormalitzarNom(r.origen) === nkgNormalitzarNom(nom) ? r.desti : r.origen;
            if (persPresents.some(pp => nkgNormalitzarNom(pp) === nkgNormalitzarNom(altreNom))) {
              parts.push(`  â†” ${altreNom}: ${r.tipus} (confianÃ§a:${r.confianca}/10, tensiÃ³:${r.tensio}/10)`);
            }
          });
        }
      }
    });
  }

  if (escenaSpec.lloc) {
    const lloc = nkg.llocs[nkgNormalitzarNom(escenaSpec.lloc)];
    if (lloc) {
      parts.push(`\nLLOC: ${lloc.nom} â€” ${lloc.descripcio_sensorial || ''} (${lloc.ambient || ''})`);
    }
  }

  const objectesRellevants = Object.values(nkg.objectes).filter(o => {
    if (o.ubicacio && escenaSpec.lloc && nkgNormalitzarNom(o.ubicacio) === nkgNormalitzarNom(escenaSpec.lloc)) return true;
    if (o.posseidor && persPresents.some(p => nkgNormalitzarNom(p) === nkgNormalitzarNom(o.posseidor))) return true;
    return false;
  });
  if (objectesRellevants.length > 0) {
    parts.push('\nOBJECTES PRESENTS:');
    objectesRellevants.forEach(o => {
      parts.push(`â€¢ ${o.nom}${o.significat_simbolic ? ' â€” ' + o.significat_simbolic : ''}`);
    });
  }

  return parts.join('\n');
}

function nkgDetectarContradiccions(nouFet) {
  const nkg = ESTAT._nkg;
  if (!nkg) return [];
  const contradiccions = [];

  nkg.fets_canonics.forEach(() => {
    if (nouFet.personatge) {
      const nomNorm = nkgNormalitzarNom(nouFet.personatge);
      const pers = nkg.personatges[nomNorm];
      if (pers && !pers.viu && nouFet.descripcio && nouFet.descripcio.toLowerCase().includes(pers.nom.toLowerCase())) {
        contradiccions.push(`âš  ${pers.nom} Ã©s mort perÃ² apareix al nou fet`);
      }
    }
  });

  if (nouFet.tipus === 'ubicaciÃ³' && nouFet.personatge) {
    const nomNorm = nkgNormalitzarNom(nouFet.personatge);
    const pers = nkg.personatges[nomNorm];
    if (pers && pers.ubicacio && nouFet.descripcio !== pers.ubicacio) {
      contradiccions.push(`â„¹ ${pers.nom} estava a "${pers.ubicacio}", nou fet el posa a "${nouFet.descripcio}"`);
    }
  }

  return contradiccions;
}

function obtenirUltimesEscenes(n, capitolActual, escenaActual) {
  const fragments = [];

  if (ESTAT._escenes_generades && Object.keys(ESTAT._escenes_generades).length > 0) {
    const totesEscenes = [];
    for (const [capIdx, escenes] of Object.entries(ESTAT._escenes_generades)) {
      for (const [escIdx, text] of Object.entries(escenes)) {
        totesEscenes.push({ cap: parseInt(capIdx), esc: parseInt(escIdx), text: text });
      }
    }
    totesEscenes.sort((a, b) => a.cap !== b.cap ? a.cap - b.cap : a.esc - b.esc);

    const anteriors = totesEscenes.filter(e =>
      e.cap < capitolActual - 1 || (e.cap === capitolActual - 1 && e.esc < escenaActual)
    );
    const ultimes = anteriors.slice(-n);
    ultimes.forEach(e => {
      const text = e.text.length > 1600 ? '...' + e.text.slice(-1600) : e.text;
      fragments.push(text);
    });
  } else if (ESTAT._capitols_generats) {
    const capAnterior = capitolActual - 2;
    if (capAnterior >= 0 && ESTAT._capitols_generats[capAnterior]) {
      const text = ESTAT._capitols_generats[capAnterior];
      const ultims = text.split(/\n\n+/).slice(-3).join('\n\n');
      fragments.push(ultims.length > 1600 ? '...' + ultims.slice(-1600) : ultims);
    }
  }

  return fragments.length > 0 ? fragments.join('\n\n---\n\n') : '';
}

function nkgGenerarContextMinim(escenaSpec) {
  const parts = [];

  // CAPA 1: Estat viu del NKG (~200-300 tokens)
  const contextNKG = nkgQueryEscenaContext(escenaSpec);
  if (contextNKG) parts.push(contextNKG);

  // CAPA 2: Resum narratiu compacte (~400 tokens fix)
  if (ESTAT._resumCompacte) {
    parts.push('\nFINS ARA A LA NOVELÂ·LA:\n' + ESTAT._resumCompacte);
  } else {
    // Fallback: resums del registre si no hi ha resum compacte
    const resumsReg = (ESTAT.llibreRegistre.capitols || []).map(c => c ? c.resum_capitol : null).filter(r => r);
    if (resumsReg.length > 0) {
      parts.push('\nRESUMS DELS CAPÃTOLS ANTERIORS:\n' + resumsReg.map((r, i) => `Cap. ${i + 1}: ${r}`).join('\n'));
    }
  }

  // CAPA 3: Ãšltimes 2 escenes literals (~800 tokens)
  const ultimesEscenes = obtenirUltimesEscenes(2, escenaSpec.capitol, escenaSpec.escena || 1);
  if (ultimesEscenes) {
    parts.push('\nTEXT RECENT (mantÃ© continuÃ¯tat de veu i to):\n' + ultimesEscenes);
  }

  // Escaleta de l'escena actual
  if (escenaSpec.escaleta) {
    parts.push('\nESCALETA D\'AQUESTA ESCENA:');
    if (escenaSpec.escaleta.objectiu_dramatic) parts.push(`Objectiu dramÃ tic: ${escenaSpec.escaleta.objectiu_dramatic}`);
    if (escenaSpec.escaleta && (escenaSpec.escaleta.emocio_entrada || escenaSpec.escaleta.emocio_sortida)) {
      parts.push(`TransiciÃ³ emocional: ${escenaSpec.escaleta.emocio_entrada || '?'} â†’ ${escenaSpec.escaleta.emocio_sortida || '?'}`);
    }
    if (escenaSpec.escaleta.beat_narratiu) parts.push(`Beat narratiu: ${escenaSpec.escaleta.beat_narratiu}`);
  }

  // Prefiguracions actives
  const prefs = getPrefiguracionsActives(escenaSpec.capitol - 1);
  if (prefs.aPlantarAra.length > 0) {
    parts.push('\nPREFIGURACIONS A PLANTAR (subtilment):');
    prefs.aPlantarAra.forEach(p => parts.push(`- ${p.element}`));
  }
  if (prefs.aRecollirAra.length > 0) {
    parts.push('\nPREFIGURACIONS A RECOLLIR:');
    prefs.aRecollirAra.forEach(p => parts.push(`- ${p.element}`));
  }

  return parts.join('\n');
}

function nkgInicialitzar() {
  ESTAT._nkg = crearNKG();
  const nkg = ESTAT._nkg;

  // Poblar personatges des de l'elenc
  if (ESTAT._personatgesSeleccionats && ESTAT._personatgesSeleccionats.length > 0) {
    ESTAT._personatgesSeleccionats.forEach(nom => {
      const clau = nkgNormalitzarNom(nom);
      if (clau) {
        nkg.personatges[clau] = {
          nom: nom,
          estat_fisic: '',
          estat_emocional: 'neutre',
          ubicacio: '',
          objectius: [],
          secrets: [],
          viu: true,
          primera_aparicio: 0
        };
      }
    });
  }

  // Poblar lloc principal des del worldbuilding
  if (ESTAT.localitzacioTriada) {
    const clau = nkgNormalitzarNom(ESTAT.localitzacioTriada);
    const wbText = ESTAT.worldbuilding
      ? (typeof ESTAT.worldbuilding === 'string' ? ESTAT.worldbuilding : JSON.stringify(ESTAT.worldbuilding))
      : '';
    nkg.llocs[clau] = {
      nom: ESTAT.localitzacioTriada,
      descripcio_sensorial: wbText.substring(0, 200),
      ambient: ''
    };
  }

  // Fet canÃ²nic inicial des de l'arc global
  if (ESTAT._arcGlobal) {
    nkg.fets_canonics.push({
      descripcio: `Arc global: ${ESTAT._arcGlobal.substring(0, 200)}`,
      capitol_origen: 0,
      categoria: 'estructura'
    });
  }

  // Inicialitzar emmagatzematge d'escenes
  ESTAT._escenes_generades = {};

  console.log('NKG inicialitzat:', Object.keys(nkg.personatges).length, 'personatges,', Object.keys(nkg.llocs).length, 'llocs');
}

function nkgAplicarActualitzacions(dades, capitol, escena) {
  const nkg = ESTAT._nkg;
  if (!nkg) return;

  if (dades.personatges_actualitzats) {
    dades.personatges_actualitzats.forEach(p => {
      const clau = nkgNormalitzarNom(p.nom);
      if (!nkg.personatges[clau]) {
        nkg.personatges[clau] = {
          nom: p.nom,
          estat_fisic: '',
          estat_emocional: p.estat_emocional || '',
          ubicacio: p.ubicacio || '',
          objectius: p.nous_objectius || [],
          secrets: p.nous_secrets || [],
          viu: p.viu !== undefined ? p.viu : true,
          primera_aparicio: capitol
        };
      } else {
        const ex = nkg.personatges[clau];
        if (p.estat_emocional) ex.estat_emocional = p.estat_emocional;
        if (p.ubicacio) ex.ubicacio = p.ubicacio;
        if (p.viu !== undefined) ex.viu = p.viu;
        if (p.nous_objectius) {
          p.nous_objectius.forEach(o => { if (!ex.objectius.includes(o)) ex.objectius.push(o); });
          if (ex.objectius.length > 2) ex.objectius = ex.objectius.slice(-2);
        }
        if (p.nous_secrets) {
          p.nous_secrets.forEach(s => { if (!ex.secrets.includes(s)) ex.secrets.push(s); });
        }
      }
    });
  }

  if (dades.nous_llocs) {
    dades.nous_llocs.forEach(ll => {
      const clau = nkgNormalitzarNom(ll.nom);
      if (!nkg.llocs[clau]) {
        nkg.llocs[clau] = { nom: ll.nom, descripcio_sensorial: ll.descripcio_sensorial || '', ambient: ll.ambient || '' };
      }
    });
  }

  if (dades.nous_objectes) {
    dades.nous_objectes.forEach(o => {
      const clau = nkgNormalitzarNom(o.nom);
      nkg.objectes[clau] = { nom: o.nom, ubicacio: o.ubicacio || '', posseidor: o.posseidor || null, significat_simbolic: o.significat_simbolic || '' };
    });
  }

  if (dades.canvis_relacions) {
    dades.canvis_relacions.forEach(r => {
      const existentIdx = nkg.relacions.findIndex(rel =>
        (nkgNormalitzarNom(rel.origen) === nkgNormalitzarNom(r.personatge_a) && nkgNormalitzarNom(rel.desti) === nkgNormalitzarNom(r.personatge_b)) ||
        (nkgNormalitzarNom(rel.origen) === nkgNormalitzarNom(r.personatge_b) && nkgNormalitzarNom(rel.desti) === nkgNormalitzarNom(r.personatge_a))
      );
      if (existentIdx >= 0) {
        const rel = nkg.relacions[existentIdx];
        if (r.tipus) rel.tipus = r.tipus;
        if (r.confianca !== undefined) rel.confianca = r.confianca;
        if (r.tensio !== undefined) rel.tensio = r.tensio;
        if (r.nota) {
          if (!rel.historial) rel.historial = [];
          rel.historial.push(`Cap.${capitol}: ${r.nota}`);
          if (rel.historial.length > 4) rel.historial = rel.historial.slice(-4);
        }
      } else {
        nkg.relacions.push({
          origen: r.personatge_a,
          desti: r.personatge_b,
          tipus: r.tipus || 'coneix',
          confianca: r.confianca || 5,
          tensio: r.tensio || 0,
          historial: r.nota ? [`Cap.${capitol}: ${r.nota}`] : []
        });
      }
    });
  }

  if (dades.nous_fets_canonics) {
    dades.nous_fets_canonics.forEach(fc => {
      nkg.fets_canonics.push({ descripcio: fc, capitol_origen: capitol, categoria: 'general' });
    });
    if (nkg.fets_canonics.length > 20) nkg.fets_canonics = nkg.fets_canonics.slice(-20);
  }

  if (dades.resum_esdeveniment) {
    nkg.esdeveniments.push({
      capitol: capitol,
      escena: escena,
      descripcio: dades.resum_esdeveniment,
      personatges_involucrats: (dades.personatges_actualitzats || []).map(p => p.nom),
      consequencies: []
    });
    if (nkg.esdeveniments.length > 30) nkg.esdeveniments = nkg.esdeveniments.slice(-30);
  }

  nkg.ultima_actualitzacio = { capitol, escena };
}

async function nkgActualitzarPostEscena(textEscena, capitol, escena, userConfig) {
  const nkg = ESTAT._nkg;
  if (!nkg) return;

  const persConeguts = Object.values(nkg.personatges).map(p => p.nom).join(', ');

  const msgs = [{
    role: 'user',
    content: `Analitza aquest fragment de novelÂ·la i extreu-ne la informaciÃ³ narrativa estructurada.

PERSONATGES CONEGUTS: ${persConeguts || '(cap encara)'}

TEXT:
${textEscena.substring(0, 3000)}${textEscena.length > 3000 ? '\n[â€¦text truncatâ€¦]' : ''}

Retorna EXCLUSIVAMENT un JSON vÃ lid:
{
  "personatges_actualitzats": [
    {
      "nom": "Nom Exacte",
      "estat_emocional": "descripciÃ³ breu del seu estat emocional al FINAL del fragment",
      "ubicacio": "on Ã©s al final",
      "nous_objectius": ["objectiu nou si n'hi ha"],
      "nous_secrets": ["secret revelat o adquirit"],
      "viu": true
    }
  ],
  "nous_llocs": [
    {
      "nom": "Nom del lloc",
      "descripcio_sensorial": "descripciÃ³ amb detalls de sentits",
      "ambient": "atmosfera"
    }
  ],
  "nous_objectes": [
    {
      "nom": "Nom objecte",
      "ubicacio": "on Ã©s",
      "posseidor": null,
      "significat_simbolic": "significat narratiu si en tÃ©"
    }
  ],
  "canvis_relacions": [
    {
      "personatge_a": "Nom",
      "personatge_b": "Nom",
      "tipus": "tipus de relaciÃ³",
      "confianca": 7,
      "tensio": 3,
      "nota": "breu descripciÃ³ del canvi"
    }
  ],
  "nous_fets_canonics": ["fet immutable establert en aquest fragment"],
  "resum_esdeveniment": "1-2 frases: quÃ¨ ha passat en aquest fragment"
}`
  }];

  const models = getModelConfig(userConfig);
  try {
    const response = await callLLMMulti(
      msgs,
      'Ets un analista narratiu. Extreu NOMÃ‰S informaciÃ³ explÃ­cita del text, no infereixis. Respon EXCLUSIVAMENT amb JSON vÃ lid.',
      Object.assign({}, userConfig, { maxTokens: 2000, model: models.modelDraft, _esDraft: true }),
      'generacio'
    );
    const dades = parseJsonRobust(response);
    if (dades) nkgAplicarActualitzacions(dades, capitol, escena);
    else console.warn('NKG: No s\'ha pogut parsejar la resposta d\'actualitzaciÃ³');
  } catch (err) {
    console.warn('NKG: Error actualitzant post-escena:', err.message);
  }
}

async function generarResumCompacte(finsCapitol, userConfig) {
  const nkg = ESTAT._nkg;
  if (!nkg) return;

  const eventsResum = nkg.esdeveniments
    .filter(e => e.capitol <= finsCapitol)
    .map(e => `Cap.${e.capitol}: ${e.descripcio}`)
    .join('\n');

  const persResum = Object.values(nkg.personatges)
    .map(p => `${p.nom}: ${p.estat_emocional}, a ${p.ubicacio || '?'}`)
    .join('; ');

  if (!eventsResum && !persResum) return;

  const msgs = [{
    role: 'user',
    content: `Genera un resum narratiu compacte de la novelÂ·la fins al capÃ­tol ${finsCapitol}.

ESDEVENIMENTS FINS ARA:
${eventsResum || '(cap registrat)'}

ESTAT ACTUAL DELS PERSONATGES:
${persResum || '(cap registrat)'}

INSTRUCCIONS:
- MÃ xim 400 paraules (ESTRICTE)
- Escriu en prosa fluÃ¯da, no en llista
- Inclou: trama principal, estat dels personatges clau, tensions obertes, girs importants
- NO incloguis detalls sensorials ni cites de diÃ legs
- El resum ha de permetre entendre on som a la novelÂ·la
- Escriu en catalÃ `
  }];

  const models = getModelConfig(userConfig);
  try {
    const response = await callLLMMulti(
      msgs,
      'Ets un editor literari. Genera resums narratius compactes i precisos.',
      Object.assign({}, userConfig, { maxTokens: 800, model: models.modelArquitecte }),
      'arquitectura'
    );
    ESTAT._resumCompacte = response || '';
    console.log('NKG: Resum compacte actualitzat fins al capÃ­tol', finsCapitol);
  } catch (err) {
    console.warn('NKG: Error generant resum compacte:', err.message);
  }
}

async function escriureEscenaDirecta(capitol, escenaIdx, escenaSpec, contextNKG, userConfig) {
  const systemPrompt = buildSystemPromptCapitol();
  const msgs = [{
    role: 'user',
    content: `Escriu l'escena ${escenaIdx + 1} del capÃ­tol ${capitol}.

${contextNKG}

INSTRUCCIONS:
- ${escenaSpec.paraules_objectiu || 500}-${(escenaSpec.paraules_objectiu || 500) + 150} paraules
- Escriu en catalÃ 
- Mostra, no expliquis`
  }];

  const res = await callLLMMulti(msgs, systemPrompt, Object.assign({}, userConfig, { maxTokens: 3000 }), 'generacio');
  return res || '';
}

async function escriureEscenaDualPass(capitol, escenaIdx, escenaSpec, userConfig) {
  const systemPrompt = buildSystemPromptCapitol();
  const idx = capitol - 1;

  const nkgSpec = {
    capitol: capitol,
    escena: escenaIdx + 1,
    personatges: escenaSpec.personatges || [],
    lloc: escenaSpec.lloc || escenaSpec.localitzacio || '',
    escaleta: escenaSpec
  };

  // Obtenir context mÃ­nim del NKG
  const contextNKG = nkgGenerarContextMinim(nkgSpec);

  // Instruccions de ritme
  const tensio = (ESTAT._corbaTensio || []).find(t => t.capitol === capitol);
  const instruccionsRitme = tensio ? getInstruccionsRitme(tensio.nivell, tensio.tipus) : 'moderat';

  // â”€â”€ PAS 1: DRAFT NARRATIU â”€â”€
  const promptDraft = [{
    role: 'user',
    content: `DRAFT NARRATIU â€” CapÃ­tol ${capitol}, Escena ${escenaIdx + 1}

${contextNKG}

INSTRUCCIONS DE DRAFT:
- Escriu l'ESQUELET narratiu d'aquesta escena en ~300 paraules
- Prioritza: QUÃˆ PASSA, en quin ordre, quins diÃ legs avancen la trama
- NO et preocupis per la prosa, les descripcions ni els detalls sensorials
- Indica els beats principals: [DIÃ€LEG], [ACCIÃ“], [INTROSPECCIÃ“], [DESCRIPCIÃ“]
- Ritme: ${instruccionsRitme}
- Escriu en catalÃ `
  }];

  const models = getModelConfig(userConfig);

  let draft;
  try {
    draft = await callLLMMulti(promptDraft, systemPrompt,
      Object.assign({}, userConfig, { maxTokens: 1500, model: models.modelDraft, _esDraft: true }), 'generacio');
  } catch (err) {
    console.error('NKG: Error al draft:', err.message);
    return await escriureEscenaDirecta(capitol, escenaIdx, escenaSpec, contextNKG, userConfig);
  }

  // ValidaciÃ³ de contradiccions (programÃ tic, 0 tokens)
  const contradiccions = [];
  if (ESTAT._nkg && draft) {
    Object.values(ESTAT._nkg.personatges).forEach(p => {
      if (!p.viu && draft.toLowerCase().includes(p.nom.toLowerCase())) {
        contradiccions.push(`${p.nom} Ã©s mort perÃ² apareix al draft`);
      }
    });
  }

  if (contradiccions.length > 0) {
    console.warn('NKG: Contradiccions al draft:', contradiccions);
    const promptCorreccio = [{
      role: 'user',
      content: `CORRECCIÃ“ DEL DRAFT â€” Hi ha errors factuals:
${contradiccions.map(c => `- ${c}`).join('\n')}

DRAFT ORIGINAL:
${draft}

Reescriu el draft corregint NOMÃ‰S els errors indicats. MantÃ© la mateixa estructura. ~300 paraules. Escriu en catalÃ .`
    }];
    try {
      const correccio = await callLLMMulti(promptCorreccio, systemPrompt,
        Object.assign({}, userConfig, { maxTokens: 1500, model: models.modelDraft, _esDraft: true }), 'generacio');
      draft = correccio || draft;
    } catch (err) {
      console.warn('NKG: Error a la correcciÃ³ del draft, usant original:', err.message);
    }
  }

  // â”€â”€ PAS 2: EXPANSIÃ“ LITERÃ€RIA â”€â”€
  const goldenRef = ESTAT._goldenPassage
    ? `\nREFERÃˆNCIA DE VEU (mantÃ© aquest to i estil):\n${ESTAT._goldenPassage.substring(0, 800)}`
    : '';

  let estilsPresents = '';
  if (ESTAT.estilsParla && escenaSpec.personatges && escenaSpec.personatges.length > 0) {
    const estils = [];
    escenaSpec.personatges.forEach(nom => {
      if (typeof ESTAT.estilsParla === 'string' && ESTAT.estilsParla.includes(nom)) {
        const nomIdx = ESTAT.estilsParla.indexOf(nom);
        const nextIdx = ESTAT.estilsParla.indexOf('\n\n', nomIdx + nom.length);
        const bloc = ESTAT.estilsParla.substring(nomIdx, nextIdx > nomIdx ? nextIdx : nomIdx + 300);
        estils.push(bloc.substring(0, 200));
      }
    });
    if (estils.length > 0) estilsPresents = '\n\nESTILS DE PARLA:\n' + estils.join('\n');
  }

  let instruccionsBeat = '';
  const beat = (escenaSpec.beat_narratiu || escenaSpec.funcio_narrativa || '').toLowerCase();
  if (beat.includes('diÃ leg') || beat.includes('dialog')) {
    instruccionsBeat = 'MÃ­nim 60% diÃ leg directe. Cada personatge ha de sonar diferent. Acotacions mÃ­nimes.';
  } else if (beat.includes('acciÃ³') || beat.includes('accio')) {
    instruccionsBeat = 'Frases curtes i directes. Ritme trepidant. Verbs d\'acciÃ³. Poc diÃ leg.';
  } else if (beat.includes('introspecciÃ³') || beat.includes('introspeccio')) {
    instruccionsBeat = 'Ritme pausat. Pensaments del personatge. Reflexions internes.';
  } else if (beat.includes('descripciÃ³') || beat.includes('descripcio')) {
    instruccionsBeat = 'Detalls sensorials: olors, sons, textures, llum. El lloc cobra vida.';
  }

  // Millora 8: VariÃ ncia de veu (programÃ tic, 0 tokens LLM)
  const ultimaEscenaText = obtenirUltimesEscenes(1, capitol, escenaIdx + 1);
  const instruccionsVariancia = ultimaEscenaText
    ? generarInstruccionsVariancia(analitzarVarianciaVeu(ultimaEscenaText))
    : '';

  // Millora 6: Manual d'estil de referÃ¨ncia
  let manualRef = '';
  if (ESTAT._manualEstil) {
    const m = ESTAT._manualEstil;
    const linies = [];
    if (m.longitud_frases) linies.push(`â€¢ ${m.longitud_frases}`);
    if (m.estil_dialeg) linies.push(`â€¢ DiÃ leg: ${m.estil_dialeg}`);
    if (m.sensorialitat) linies.push(`â€¢ Sensorialitat: ${m.sensorialitat}`);
    if (m.ritme) linies.push(`â€¢ Ritme: ${m.ritme}`);
    if (linies.length > 0) manualRef = '\nMANUAL D\'ESTIL:\n' + linies.join('\n');
  }

  const promptExpansio = [{
    role: 'user',
    content: `EXPANSIÃ“ LITERÃ€RIA â€” CapÃ­tol ${capitol}, Escena ${escenaIdx + 1}

DRAFT (esquelet narratiu â€” mantÃ© l'estructura i els beats):
${draft}
${goldenRef}
${estilsPresents}${manualRef}

INSTRUCCIONS D'EXPANSIÃ“:
- Expandeix el draft a prosa literÃ ria completa: ${escenaSpec.paraules_objectiu || 500}-${(escenaSpec.paraules_objectiu || 500) + 150} paraules
- El draft Ã©s l'esquelet; tu poses la carn, la pell i la sang
- Afegeix: detalls sensorials (mÃ­nim 2 sentits per escena), subtexte als diÃ legs, ritme de la prosa
- ${instruccionsBeat || 'Equilibra narraciÃ³, diÃ leg i descripciÃ³'}
- Mostra, no expliquis: NO escriguis "estava trist" â†’ mostra-ho amb gestos, paraules, mirada
- ComenÃ§a directament amb la narraciÃ³, sense titular${instruccionsVariancia ? '\n- VARIÃ€NCIA: ' + instruccionsVariancia : ''}
- Escriu en catalÃ `
  }];

  try {
    const textFinal = await callLLMMulti(promptExpansio, systemPrompt,
      Object.assign({}, userConfig, { maxTokens: 3000, model: models.modelGeneracio }), 'generacio');

    if (!ESTAT._escenes_generades) ESTAT._escenes_generades = {};
    if (!ESTAT._escenes_generades[idx]) ESTAT._escenes_generades[idx] = {};
    ESTAT._escenes_generades[idx][escenaIdx] = textFinal;

    // Actualitzar NKG amb el text generat
    await nkgActualitzarPostEscena(textFinal, capitol, escenaIdx + 1, userConfig);

    return textFinal || '';
  } catch (err) {
    console.error('NKG: Error a l\'expansiÃ³:', err.message);
    return draft || '';
  }
}

async function generarCapitolNKG(idx, userConfig) {
  const capitol = idx + 1;
  const escaletaCap = ESTAT._escaletes ? ESTAT._escaletes.find(e => e.capitol === capitol) : null;
  const escenes = escaletaCap ? (escaletaCap.escenes || null) : null;

  let textComplet = '';

  if (ESTAT._nkg && escenes && Array.isArray(escenes) && escenes.length > 0) {
    // Escriptura per escenes amb Dual-Pass
    for (let i = 0; i < escenes.length; i++) {
      const escena = escenes[i];
      const loaderEl = document.getElementById('loader-11-text');
      if (loaderEl) {
        loaderEl.textContent = `âœï¸ CapÃ­tol ${capitol}: Escena ${i + 1}/${escenes.length} (draft â†’ expansiÃ³)â€¦`;
      }
      const text = await escriureEscenaDualPass(capitol, i, escena, userConfig);
      textComplet += (i > 0 ? '\n\n' : '') + text;
    }
  } else if (ESTAT._nkg) {
    // NKG actiu perÃ² sense escaleta: escriptura dual-pass del capÃ­tol com una sola escena
    const cap = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols[idx] : null;
    const escenaSpec = {
      personatges: cap ? (cap.personatges || []) : [],
      lloc: cap ? (cap.localitzacio || '') : '',
      objectiu_dramatic: cap ? (cap.resum || '') : '',
      funcio_narrativa: cap ? (cap.fil_principal || '') : '',
      beat_narratiu: cap ? (cap.to_ritme || 'equilibrat') : 'equilibrat',
      paraules_objectiu: 1800
    };
    const loaderEl = document.getElementById('loader-11-text');
    if (loaderEl) loaderEl.textContent = `âœï¸ CapÃ­tol ${capitol}: draft â†’ expansiÃ³â€¦`;
    textComplet = await escriureEscenaDualPass(capitol, 0, escenaSpec, userConfig);
  } else {
    // Fallback: sistema antic sense NKG
    const res = await escriureCapitolPerEscenes(idx, userConfig);
    return res;
  }

  // Guardar capÃ­tol complet
  if (!ESTAT._capitols_generats) ESTAT._capitols_generats = [];
  ESTAT._capitols_generats[idx] = textComplet;

  // Generar resum compacte cada 3 capÃ­tols o al primer
  if (capitol === 1 || capitol % 3 === 0) {
    const loaderEl = document.getElementById('loader-11-text');
    if (loaderEl) loaderEl.textContent = 'ğŸ”µ Actualitzant resum narratiuâ€¦';
    await generarResumCompacte(capitol, userConfig);
  }

  // Millora 7: Micro-reescriptura cada 3 capÃ­tols (Sonnet diagnostica i reescriu)
  const totalCapitols = ESTAT._estructuraCapitols ? ESTAT._estructuraCapitols.length : 12;
  if (capitol % 3 === 0 || capitol === totalCapitols) {
    try {
      const loaderEl = document.getElementById('loader-11-text');
      if (loaderEl) loaderEl.textContent = 'ğŸ”´ Revisant passatges feblesâ€¦';
      await microReescripturaBlocOpus(Math.max(0, idx - 2), idx, userConfig);
      if (capitol === totalCapitols && totalCapitols >= 12) {
        console.log('Micro-reescriptura final: verificant tancament narratiu');
      }
    } catch (err) {
      console.warn('Micro-reescriptura: error no bloquejant:', err.message);
    }
  }

  return { response: textComplet };
}

function renderitzarNKG() {
  const nkg = ESTAT._nkg;
  if (!nkg) return '<p style="color:var(--text2)">NKG no inicialitzat</p>';

  let html = '<div>';

  html += `<h4 style="color:var(--accent2);margin-bottom:8px;">ğŸ“‹ Personatges (${Object.keys(nkg.personatges).length})</h4>`;
  Object.values(nkg.personatges).forEach(p => {
    const color = p.viu ? 'var(--success)' : '#dc3545';
    html += `<div style="border-left:3px solid ${color};padding-left:8px;margin:4px 0;font-size:.85rem;">`;
    html += `<strong>${escHtml(p.nom)}</strong>`;
    if (p.estat_emocional) html += ` â€” ${escHtml(p.estat_emocional)}`;
    if (p.ubicacio) html += ` | ğŸ“ ${escHtml(p.ubicacio)}`;
    if (p.objectius && p.objectius.length > 0) html += `<br>ğŸ¯ ${escHtml(p.objectius.join(', '))}`;
    html += '</div>';
  });

  if (nkg.relacions.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:12px 0 8px;">ğŸ”— Relacions (${nkg.relacions.length})</h4>`;
    nkg.relacions.forEach(r => {
      html += `<div style="font-size:.82rem;padding:2px 0;">${escHtml(r.origen)} â†” ${escHtml(r.desti)}: ${escHtml(r.tipus)} (âš¡${r.tensio}/10)</div>`;
    });
  }

  const eventsRecents = nkg.esdeveniments.slice(-5);
  if (eventsRecents.length > 0) {
    html += `<h4 style="color:var(--accent2);margin:12px 0 8px;">ğŸ“… Esdeveniments recents</h4>`;
    eventsRecents.forEach(e => {
      html += `<div style="font-size:.82rem;padding:2px 0;">Cap.${e.capitol}: ${escHtml(e.descripcio)}</div>`;
    });
  }

  html += '</div>';
  return html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DetecciÃ³ de Repeticions (anÃ lisi local, sense LLM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function detectarRepeticions() {
  const capitolsAmbText = ESTAT._capitols_generats.filter(t => t && t.length > 0);
  if (capitolsAmbText.length < 3) return null;

  function getNgrams(text, n) {
    const paraules = text.toLowerCase().replace(/[.,;:!?Â«Â»""''()\[\]]/g, ' ').split(/\s+/).filter(p => p.length > 2);
    const ngrams = {};
    for (let i = 0; i <= paraules.length - n; i++) {
      const ng = paraules.slice(i, i + n).join(' ');
      ngrams[ng] = (ngrams[ng] || 0) + 1;
    }
    return ngrams;
  }

  // Bigrames i trigrames per capÃ­tol
  const bigramesPerCapitol = capitolsAmbText.map(t => getNgrams(t, 2));
  const trigramesPerCapitol = capitolsAmbText.map(t => getNgrams(t, 3));

  // Paraules de stop (comunes en catalÃ /castellÃ /anglÃ¨s)
  const stopWords = new Set(['que', 'del', 'les', 'els', 'una', 'uns', 'unes', 'per', 'amb', 'com', 'tot', 'tots', 'tota', 'totes', 'mÃ©s', 'molt', 'perÃ²', 'quan', 'fins', 'des', 'pel', 'als', 'sense', 'sobre', 'entre', 'cap', 'seu', 'seva', 'seus', 'seves', 'era', 'eren', 'havia', 'havien', 'ser', 'estar', 'han', 'has', 'hem']);

  function filtrarNgrams(ngramsList) {
    // Compta en quants capÃ­tols apareix cada ngram
    const comptador = {};
    ngramsList.forEach(ngrams => {
      Object.keys(ngrams).forEach(ng => {
        const paraules = ng.split(' ');
        // Filtra si totes les paraules sÃ³n stop words
        if (paraules.every(p => stopWords.has(p))) return;
        comptador[ng] = (comptador[ng] || 0) + 1;
      });
    });
    return Object.entries(comptador)
      .filter(([, c]) => c >= 3)
      .sort((a, b) => b[1] - a[1]);
  }

  const bigramesRepetits = filtrarNgrams(bigramesPerCapitol);
  const trigramesRepetits = filtrarNgrams(trigramesPerCapitol);

  if (bigramesRepetits.length === 0 && trigramesRepetits.length === 0) return null;
  return { bigrames: bigramesRepetits, trigrames: trigramesRepetits };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MILLORA 6: VEU SEMILLA â€” Analitzar estil de referÃ¨ncia (Opus)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function manualEstilMassaCurt(manual) {
  if (!manual || typeof manual !== 'object') return true;
  const camps = ['longitud_frases', 'estil_dialeg', 'sensorialitat', 'ritme', 'vocabulari', 'punt_de_vista'];
  const presents = camps.filter(c => manual[c] != null && String(manual[c]).trim().length > 20);
  const charsTotals = presents.reduce((acc, c) => acc + String(manual[c]).trim().length, 0);
  return presents.length < 4 || charsTotals < 260;
}

async function analitzarVeuSemilla(textReferencia, userConfig) {
  const promptBase = `Ets un expert en estil literari. Analitza el fragment de text d'un autor de referÃ¨ncia i genera un MANUAL D'ESTIL concret i accionable per a un escriptor.

FRAGMENT DE REFERÃˆNCIA:
${textReferencia.substring(0, 4000)}

IMPORTANT:
- Cada camp textual ha de tenir com a mÃ­nim 2 frases i ser especÃ­fic.
- No retallis idees a mitja frase.
- Evita resumir en una sola lÃ­nia.

Retorna EXCLUSIVAMENT JSON (sense cap altre text) amb el format:
{
  "longitud_frases": "descripciÃ³ concreta (ex: frases curtes 8-12 paraules, entremesclades amb perÃ­odes llargs)",
  "estil_dialeg": "com es construeixen els diÃ legs (ex: acotacions mÃ­nimes, diÃ leg tallat per acciÃ³)",
  "sensorialitat": "quins sentits predominen i com s'usen (ex: tÃ ctil i visual, metÃ fores kinÃ¨stiques)",
  "ritme": "patrÃ³ rÃ­tmic (ex: acceleraciÃ³ a l'acciÃ³ amb frases curtes, pauses reflexives amb subordinades)",
  "vocabulari": "registre i trets lexicals (ex: colÂ·loquial amb arcaismes puntuals, evita adjectius abstractes)",
  "punt_de_vista": "focalitzaciÃ³ i distÃ ncia narrativa",
  "trets_distinctius": ["tret 1", "tret 2", "tret 3"]
}`;

  const prompt = [{ role: 'user', content: promptBase }];

  const res = await callLLMMulti(prompt, 'Ets un crÃ­tic literari expert en anÃ lisi estilÃ­stica. Analitza amb precisiÃ³ quirÃºrgica.',
    Object.assign({}, userConfig, { maxTokens: 1500 }), 'arquitectura');

  let manual = parseJsonRobust(res) || parseManualEstilFallback(res);
  if (!manualEstilMassaCurt(manual)) return manual;

  const promptRetry = [{
    role: 'user',
    content: promptBase + '\n\nReescriu la resposta amb MÃ‰S DETALL i assegura que tots els camps estiguin complets i no tallats.'
  }];

  const resRetry = await callLLMMulti(promptRetry, 'Ets un crÃ­tic literari expert en anÃ lisi estilÃ­stica. Analitza amb precisiÃ³ quirÃºrgica.',
    Object.assign({}, userConfig, { maxTokens: 2200 }), 'arquitectura');

  manual = parseJsonRobust(resRetry) || parseManualEstilFallback(resRetry);
  return manual;
}

function parseManualEstilFallback(text) {
  if (!text || typeof text !== 'string') return null;

  const clean = text
    .replace(/```(?:json)?/gi, '')
    .replace(/```/g, '')
    .replace(/\r/g, '')
    .trim();

  const manual = {};
  const fieldMap = {
    longitud_frases: ['longitud_frases', 'longitud de frases'],
    estil_dialeg: ['estil_dialeg', 'estil de dialeg', 'estil de diÃ leg', 'dialeg', 'diÃ leg'],
    sensorialitat: ['sensorialitat'],
    ritme: ['ritme'],
    vocabulari: ['vocabulari'],
    punt_de_vista: ['punt_de_vista', 'punt de vista']
  };

  const lines = clean.split('\n').map(l => l.trim()).filter(Boolean);
  for (const line of lines) {
    const normalized = line
      .replace(/^[-*â€¢\d.)\s]+/, '')
      .replace(/^\*\*(.*?)\*\*$/, '$1')
      .trim();

    const m = normalized.match(/^([^:]+):\s*(.+)$/);
    if (!m) continue;

    const rawKey = m[1].trim().replace(/^"|"$/g, '').replace(/^'|'$/g, '');
    const key = rawKey.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').trim();
    const value = m[2].trim().replace(/^"|"$/g, '').replace(/^'|'$/g, '').replace(/,$/, '').trim();
    if (!value) continue;

    for (const [target, aliases] of Object.entries(fieldMap)) {
      if (aliases.includes(key)) {
        manual[target] = value;
        break;
      }
    }
  }

  const trets = [];
  const tretsBlock = clean.match(/(?:trets?_distinctius|trets? distintius)\s*:\s*([\s\S]{0,500})/i);
  if (tretsBlock) {
    const rawTrets = tretsBlock[1].trim();
    const arrayMatch = rawTrets.match(/^\[(.*)\]$/s);
    if (arrayMatch) {
      arrayMatch[1]
        .split(',')
        .map(v => v.replace(/^\s*["']?|["']?\s*$/g, '').trim())
        .filter(Boolean)
        .slice(0, 6)
        .forEach(t => trets.push(t));
    } else {
      const tretsLines = rawTrets
        .split('\n')
        .map(l => l.replace(/^[-*â€¢\d.)\s]+/, '').replace(/[",]$/g, '').trim())
        .filter(Boolean)
        .slice(0, 6);
      trets.push(...tretsLines);
    }
  }

  if (trets.length === 0) {
    lines
      .filter(l => /^[-*â€¢]/.test(l) || /^\d+[.)]/.test(l))
      .map(l => l.replace(/^[-*â€¢\d.)\s]+/, '').trim())
      .filter(Boolean)
      .slice(0, 3)
      .forEach(t => trets.push(t));
  }

  if (trets.length > 0) manual.trets_distinctius = trets;

  return Object.keys(manual).length > 0 ? manual : null;
}

async function processarVeuSemilla() {
  const textarea = document.getElementById('veuSemilla');
  const resultDiv = document.getElementById('veuSemilla-result');
  if (!textarea || !resultDiv) return;

  const text = textarea.value.trim();
  if (text.length < 200) {
    resultDiv.style.color = 'var(--danger)';
    resultDiv.textContent = 'âš ï¸ Enganxa almenys 200 carÃ cters de text de referÃ¨ncia.';
    return;
  }

  resultDiv.style.color = 'var(--text2)';
  resultDiv.textContent = 'ğŸ”µ Opus analitzant estil de referÃ¨nciaâ€¦';

  try {
    const manual = await analitzarVeuSemilla(text, USER_CONFIG);
    if (manual) {
      ESTAT._veuSemilla = text;
      ESTAT._manualEstil = manual;

      const CAMPS_CONEGUTS = ['trets_distinctius', 'longitud_frases', 'estil_dialeg', 'sensorialitat', 'ritme', 'vocabulari', 'punt_de_vista'];

      let tretsHtml = '';
      if (manual.trets_distinctius != null) {
        const trets = Array.isArray(manual.trets_distinctius)
          ? manual.trets_distinctius
          : String(manual.trets_distinctius).split(/[,Â·\n]+/).map(t => t.trim()).filter(Boolean);
        if (trets.length > 0) {
          tretsHtml = `<div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:12px">${trets.map(t => `<span style="background:var(--surface2);border:1px solid var(--border);border-radius:16px;padding:2px 10px;font-size:.82rem;color:var(--text2)">${escHtml(t)}</span>`).join('')}</div>`;
        }
      }

      const ETIQUETES = { longitud_frases: 'Longitud de frases', estil_dialeg: 'Estil de diÃ leg', sensorialitat: 'Sensorialitat', ritme: 'Ritme', vocabulari: 'Vocabulari', punt_de_vista: 'Punt de vista' };
      let campsHtml = '';
      for (const [clau, etiqueta] of Object.entries(ETIQUETES)) {
        if (manual[clau] != null) {
          campsHtml += `<div style="margin-bottom:8px"><span style="font-size:.78rem;font-weight:600;color:var(--accent2);text-transform:uppercase;letter-spacing:.04em">${etiqueta}</span><div style="font-size:.88rem;color:var(--text);margin-top:2px">${escHtml(String(manual[clau]))}</div></div>`;
        }
      }

      const extresHtml = Object.keys(manual)
        .filter(k => !CAMPS_CONEGUTS.includes(k) && manual[k] != null)
        .map(k => `<div style="margin-bottom:8px"><span style="font-size:.78rem;font-weight:600;color:var(--accent2);text-transform:uppercase;letter-spacing:.04em">${escHtml(k)}</span><div style="font-size:.88rem;color:var(--text);margin-top:2px">${escHtml(String(manual[k]))}</div></div>`)
        .join('');

      resultDiv.style.color = '';
      resultDiv.innerHTML = `<div style="background:var(--surface2);border:1px solid var(--border);border-radius:10px;padding:16px;margin-top:8px"><div style="font-weight:600;color:var(--success);margin-bottom:10px">âœ… Manual d'estil generat</div>${tretsHtml}${campsHtml}${extresHtml}</div>`;
    } else {
      resultDiv.style.color = 'var(--danger)';
      resultDiv.textContent = 'âš ï¸ No s\'ha pogut analitzar l\'estil. Intenta-ho de nou.';
    }
  } catch (err) {
    resultDiv.style.color = 'var(--danger)';
    resultDiv.textContent = `âš ï¸ Error: ${err.message}`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MILLORA 8: DETECTOR DE VEU PLANA â€” anÃ lisi programÃ tica (0 LLM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function analitzarVarianciaVeu(text) {
  if (!text || text.length < 50) return null;

  // Segmentar en frases
  const frases = text.split(/[.!?]+/).map(f => f.trim()).filter(f => f.length > 5);
  if (frases.length < 3) return null;

  const longituds = frases.map(f => f.split(/\s+/).length);
  const mitja = longituds.reduce((a, b) => a + b, 0) / longituds.length;
  const variancia = longituds.reduce((a, b) => a + Math.pow(b - mitja, 2), 0) / longituds.length;
  const cv = mitja > 0 ? Math.sqrt(variancia) / mitja : 0;

  // Frases consecutives de longitud similar (diferÃ¨ncia <= 2 paraules)
  let consecutivesSimilars = 0;
  for (let i = 1; i < longituds.length; i++) {
    if (Math.abs(longituds[i] - longituds[i - 1]) <= 2) consecutivesSimilars++;
  }
  const ratioConsecutives = longituds.length > 1 ? consecutivesSimilars / (longituds.length - 1) : 0;

  // Starts repetitius (primers 2 mots)
  const starts = frases.map(f => f.split(/\s+/).slice(0, 2).join(' ').toLowerCase());
  const startCounts = {};
  starts.forEach(s => { startCounts[s] = (startCounts[s] || 0) + 1; });
  const startsRepetits = Object.values(startCounts).filter(c => c >= 2).reduce((a, b) => a + b, 0);
  const ratioStarts = frases.length > 0 ? startsRepetits / frases.length : 0;

  // Adverbis en -ment
  const adverbis = (text.match(/\b\w+ment\b/gi) || []).length;
  const adverbisPerfrase = frases.length > 0 ? adverbis / frases.length : 0;

  // ProporciÃ³ de diÃ leg (per senyals tipogrÃ fics)
  const dialogLines = (text.match(/[Â«Â»"â€”]/g) || []).length;
  const ratioDialeg = text.length > 0 ? dialogLines / (text.length / 100) : 0;

  return { cv, mitja, ratioConsecutives, ratioStarts, adverbisPerfrase, ratioDialeg, nFrases: frases.length };
}

function generarInstruccionsVariancia(metriques) {
  if (!metriques) return '';

  const instruccions = [];

  if (metriques.cv < 0.25) {
    instruccions.push('alterna frases curtes (3-5 paraules) amb frases llargues (15+ paraules) per trencar la monotonia rÃ­tmica');
  }
  if (metriques.ratioConsecutives > 0.6) {
    instruccions.push('evita que 3 frases seguides tinguin la mateixa longitud; trenca el paralÂ·lelisme');
  }
  if (metriques.ratioStarts > 0.3) {
    instruccions.push('varia els inicis de frase (no repeteixis el mateix subjecte o connector)');
  }
  if (metriques.adverbisPerfrase > 0.5) {
    instruccions.push('substitueix adverbis en -ment per verbs mÃ©s precisos');
  }

  return instruccions.join('; ');
}

function renderitzarAnalisiVeu(capitolIdx) {
  const text = ESTAT._capitols_generats ? ESTAT._capitols_generats[capitolIdx] : null;
  if (!text) return '';

  const m = analitzarVarianciaVeu(text);
  if (!m) return '';

  const cvPct = Math.round(m.cv * 100);
  const cvColor = m.cv >= 0.35 ? 'var(--success)' : m.cv >= 0.2 ? '#ffc107' : 'var(--danger)';
  const consec = Math.round(m.ratioConsecutives * 100);
  const adv = m.adverbisPerfrase.toFixed(2);

  return `<div style="margin-top:12px;padding:10px;background:var(--surface2);border-radius:8px;font-size:.82rem;">
  <strong style="color:var(--accent2);">ğŸ“Š AnÃ lisi de Veu â€” CapÃ­tol ${capitolIdx + 1}</strong>
  <div style="margin-top:6px;display:grid;grid-template-columns:1fr 1fr;gap:4px;">
    <span>VariÃ ncia de ritme (CV):</span><span style="color:${cvColor};font-weight:600">${cvPct}% ${m.cv >= 0.35 ? 'âœ“' : m.cv >= 0.2 ? '~' : 'âš '}</span>
    <span>Frases consecutives similars:</span><span style="color:${consec > 60 ? 'var(--danger)' : 'var(--text)'}">${consec}%</span>
    <span>Adverbis per frase:</span><span style="color:${m.adverbisPerfrase > 0.5 ? 'var(--danger)' : 'var(--text)'}">${adv}</span>
    <span>Longitud mitja:</span><span>${Math.round(m.mitja)} paraules</span>
  </div>
</div>`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MILLORA 7: MICRO-REESCRIPTURA PER BLOCS (Opus + Sonnet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function microReescripturaBlocOpus(blocIniciIdx, blocFinalIdx, userConfig) {
  const capitolsBloc = [];
  for (let i = blocIniciIdx; i <= blocFinalIdx; i++) {
    if (ESTAT._capitols_generats && ESTAT._capitols_generats[i]) {
      capitolsBloc.push({ idx: i, text: ESTAT._capitols_generats[i] });
    }
  }
  if (capitolsBloc.length === 0) return;

  // PAS 1: Opus diagnostica els passatges febles
  const textsPerDiagnosi = capitolsBloc.map(c =>
    `=== CapÃ­tol ${c.idx + 1} ===\n${c.text.substring(0, 2000)}`
  ).join('\n\n');

  const promptDiagnosi = [{
    role: 'user',
    content: `Analitza els capÃ­tols i identifica exactament 3-5 passatges febles (telling, clixÃ©s, prosa plana, diÃ leg genÃ¨ric).

${textsPerDiagnosi}

Retorna EXCLUSIVAMENT JSON:
{
  "passatges": [
    {
      "capitol_idx": 0,
      "text_original": "fragment exacte de mÃ xim 150 paraules",
      "problema": "descripciÃ³ breu del problema",
      "instruccio": "instrucciÃ³ especÃ­fica per reescriure'l"
    }
  ]
}`
  }];

  const models = getModelConfig(userConfig);
  let diagnosi;
  try {
    const res = await callLLMMulti(promptDiagnosi,
      'Ets un editor literari professional. Sigues precÃ­s i exigent. Respon EXCLUSIVAMENT amb JSON vÃ lid.',
      Object.assign({}, userConfig, { maxTokens: 1200, model: models.modelArquitecte }), 'arquitectura');
    diagnosi = parseJsonRobust(res);
  } catch (err) {
    console.warn('Micro-reescriptura: diagnosi fallida:', err.message);
    return;
  }

  if (!diagnosi || !diagnosi.passatges || diagnosi.passatges.length === 0) return;

  // PAS 2: Sonnet reescriu cada passatge identificat
  let goldenActualitzat = false;
  for (const passatge of diagnosi.passatges) {
    const capIdx = passatge.capitol_idx;
    if (!ESTAT._capitols_generats || !ESTAT._capitols_generats[capIdx] || !passatge.text_original) continue;

    const promptReescriptura = [{
      role: 'user',
      content: `Reescriu aquest passatge aplicant la instrucciÃ³. MantÃ©n la mateixa longitud aproximada i la continuÃ¯tat narrativa.

PASSATGE ORIGINAL:
${passatge.text_original}

PROBLEMA: ${passatge.problema}
INSTRUCCIÃ“: ${passatge.instruccio}

Retorna NOMÃ‰S el text reescrit, sense cap explicaciÃ³ ni metadades.`
    }];

    try {
      const reescrit = await callLLMMulti(promptReescriptura,
        'Ets un escriptor literari expert en revisiÃ³ de prosa. Reescriu amb precisiÃ³ quirÃºrgica.',
        Object.assign({}, userConfig, { maxTokens: 600, model: models.modelGeneracio }), 'generacio');

      if (reescrit && reescrit.length > 50) {
        const capActual = ESTAT._capitols_generats[capIdx];
        const textOrigNorm = passatge.text_original.substring(0, 100);
        if (capActual.includes(textOrigNorm)) {
          ESTAT._capitols_generats[capIdx] = capActual.replace(passatge.text_original, reescrit);
        }

        // Actualitzar golden passage si el reescrit tÃ© la longitud adequada
        if (!goldenActualitzat) {
          const nParaules = reescrit.split(/\s+/).length;
          if (nParaules >= 150 && nParaules <= 250) {
            if (ESTAT._goldenPassageCapitol < 0 || capIdx >= ESTAT._goldenPassageCapitol) {
              ESTAT._goldenPassage = reescrit.substring(0, 1200);
              ESTAT._goldenPassageCapitol = capIdx;
              goldenActualitzat = true;
            }
          }
        }
      }
    } catch (err) {
      console.warn(`Micro-reescriptura: error al passatge del capÃ­tol ${capIdx}:`, err.message);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALCULADORA DE COST I QUALITAT â€” v5.1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function calcularEstimacioNovella() {
  const models = getModelConfig();
  const numCaps = ESTAT._nombreCapitols || 12;
  const escenesMitjana = 3.5;
  const totalEscenes = Math.round(numCaps * escenesMitjana);

  const regDraft = MODEL_REGISTRY[models.modelDraft];
  const regGen   = MODEL_REGISTRY[models.modelGeneracio];
  const regArq   = MODEL_REGISTRY[models.modelArquitecte];
  if (!regDraft || !regGen || !regArq) return null;

  // â”€â”€â”€ COST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const factor = numCaps / 12;
  const tD = ROLS_MODEL.draft.tokens_estimats;
  const tG = ROLS_MODEL.generacio.tokens_estimats;
  const tA = ROLS_MODEL.arquitecte.tokens_estimats;

  const costDraft = (tD.input * factor * regDraft.input_per_m / 1000000) +
                    (tD.output * factor * regDraft.output_per_m / 1000000);
  const costGen   = (tG.input * factor * regGen.input_per_m / 1000000) +
                    (tG.output * factor * regGen.output_per_m / 1000000);
  const costArq   = (tA.input * factor * regArq.input_per_m / 1000000) +
                    (tA.output * factor * regArq.output_per_m / 1000000);
  const costTotal = costDraft + costGen + costArq;

  // â”€â”€â”€ QUALITAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const totalTok = (tD.input + tD.output) + (tG.input + tG.output) + (tA.input + tA.output);
  const pesDraft = (tD.input + tD.output) / totalTok;
  const pesGen   = (tG.input + tG.output) / totalTok;
  const pesArq   = (tA.input + tA.output) / totalTok;

  const qDraft = regDraft.qualitat[ROLS_MODEL.draft.clau_qualitat];
  const qGen   = regGen.qualitat[ROLS_MODEL.generacio.clau_qualitat];
  const qArq   = regArq.qualitat[ROLS_MODEL.arquitecte.clau_qualitat];

  const qGlobal = Math.round(
    qDraft * pesDraft * 0.7 +
    qGen   * pesGen   * 1.4 +
    qArq   * pesArq   * 0.9
  );

  let penalitzacioCatala = 0;
  if (regGen.proveidor !== 'anthropic')   penalitzacioCatala += 5;
  if (regDraft.proveidor !== 'anthropic') penalitzacioCatala += 2;
  if (regArq.proveidor !== 'anthropic')   penalitzacioCatala += 3;

  const qualitatFinal = Math.max(40, qGlobal - penalitzacioCatala);
  const estrelles = qualitatFinal >= 85 ? 5 : qualitatFinal >= 78 ? 4 :
                    qualitatFinal >= 70 ? 3 : qualitatFinal >= 60 ? 2 : 1;
  const ratioQP = qualitatFinal / (costTotal || 0.01);
  const etiquetaRatio = ratioQP > 25 ? 'ğŸ† Excepcional' : ratioQP > 18 ? 'âœ… Molt bo' :
                        ratioQP > 12 ? 'ğŸ‘ Bo' : ratioQP > 8 ? 'âš ï¸ Car' : 'ğŸ’¸ Molt car';

  return {
    modelDraft: regDraft.nomCurt, modelGeneracio: regGen.nomCurt, modelArquitecte: regArq.nomCurt,
    costDraft: costDraft.toFixed(2), costGeneracio: costGen.toFixed(2),
    costArquitecte: costArq.toFixed(2), costTotal: costTotal.toFixed(2),
    qualitatDraft: qDraft, qualitatGeneracio: qGen, qualitatArquitecte: qArq,
    qualitatGlobal: qualitatFinal, penalitzacioCatala, estrelles, etiquetaRatio,
    capitols: numCaps, escenes: totalEscenes, paraulesEstimades: totalEscenes * 530,
    avisos: generarAvisos(models, regDraft, regGen, regArq)
  };
}

function generarAvisos(models, regDraft, regGen, regArq) {
  const avisos = [];
  if (regGen.proveidor !== 'anthropic')
    avisos.push(`âš ï¸ ${regGen.nomCurt} genera prosa en catalÃ  menys natural que els models Claude.`);
  if (regArq.proveidor !== 'anthropic')
    avisos.push(`â„¹ï¸ ${regArq.nomCurt} pot interpretar pitjor instruccions en catalÃ  als prompts d'arquitectura.`);
  if (regDraft.context_max < 200000)
    avisos.push(`âš ï¸ ${regDraft.nomCurt} tÃ© context limitat (${Math.round(regDraft.context_max/1000)}K). Pot afectar escenes amb molt context NKG.`);
  if (regDraft.input_per_m > regGen.input_per_m)
    avisos.push(`ğŸ’¡ El model de draft (${regDraft.nomCurt}) Ã©s mÃ©s car que el de generaciÃ³ (${regGen.nomCurt}). Considera intercanviar-los.`);
  if (regGen.qualitat.prosa < 70)
    avisos.push(`âš ï¸ ${regGen.nomCurt} tÃ© qualitat de prosa limitada (${regGen.qualitat.prosa}/100). La novelÂ·la necessitarÃ  mÃ©s ediciÃ³ humana.`);
  const proveidors = new Set([regDraft.proveidor, regGen.proveidor, regArq.proveidor]);
  if (proveidors.size > 1)
    avisos.push(`â„¹ï¸ CombinaciÃ³ multi-proveÃ¯dor (${[...proveidors].join(', ')}). Assegura't de tenir claus API per a tots.`);
  return avisos;
}

// Backward-compatible alias (cridat des de la fase d'estructura)
function estimarCostNovella() { return calcularEstimacioNovella(); }
function mostrarEstimacioCost() {
  const est = calcularEstimacioNovella();
  if (!est) return '';
  const veuLine = '';
  return `ğŸ“Š ${est.capitols} capÃ­tols Â· ~${est.escenes} escenes Â· ~${est.paraulesEstimades.toLocaleString()} paraules\nğŸ’° $${est.costTotal} ${est.etiquetaRatio} Â· Qualitat: ${est.qualitatGlobal}/100 ${'â˜…'.repeat(est.estrelles)}${'â˜†'.repeat(5-est.estrelles)}\n   Draft: $${est.costDraft} Â· GeneraciÃ³: $${est.costGeneracio} Â· Arquitectura: $${est.costArquitecte}`;
}

// â”€â”€ UI: Funcions del panell de models â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function poblarSelectorsModels() {
  const selectors = {
    'selectModelDraft': 'draft',
    'selectModelGen':   'generacio',
    'selectModelArq':   'arquitecte'
  };
  Object.entries(selectors).forEach(([selectId, rol]) => {
    const select = document.getElementById(selectId);
    if (!select) return;
    select.innerHTML = '';
    Object.entries(MODEL_REGISTRY).forEach(([modelId, info]) => {
      const qualitat = info.qualitat[ROLS_MODEL[rol].clau_qualitat];
      const option = document.createElement('option');
      option.value = modelId;
      option.textContent = `${info.nomCurt} â€” $${info.input_per_m}/$${info.output_per_m}/M â€” Q:${qualitat}`;
      select.appendChild(option);
    });
  });
  const models = getModelConfig();
  const selDraft = document.getElementById('selectModelDraft');
  const selGen   = document.getElementById('selectModelGen');
  const selArq   = document.getElementById('selectModelArq');
  if (selDraft) selDraft.value = models.modelDraft;
  if (selGen)   selGen.value   = models.modelGeneracio;
  if (selArq)   selArq.value   = models.modelArquitecte;
  actualitzarEstimacio();
}

function actualitzarEstimacio() {
  const est = calcularEstimacioNovella();
  if (!est) return;

  const qDraftEl = document.getElementById('qualitatDraft');
  const qGenEl   = document.getElementById('qualitatGen');
  const qArqEl   = document.getElementById('qualitatArq');
  if (qDraftEl) qDraftEl.innerHTML = renderBarraQualitat(est.qualitatDraft, '$' + est.costDraft);
  if (qGenEl)   qGenEl.innerHTML   = renderBarraQualitat(est.qualitatGeneracio, '$' + est.costGeneracio);
  if (qArqEl)   qArqEl.innerHTML   = renderBarraQualitat(est.qualitatArquitecte, '$' + est.costArquitecte);

  const panell = document.getElementById('panellEstimacio');
  if (panell) {
    const estrellesHTML = 'â˜…'.repeat(est.estrelles) + 'â˜†'.repeat(5 - est.estrelles);
    panell.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;">
        <div><strong style="font-size:1.3em;">$${est.costTotal}</strong><span style="color:#666;margin-left:8px;">${est.etiquetaRatio}</span></div>
        <div><span style="color:#f5a623;font-size:1.2em;">${estrellesHTML}</span><span style="margin-left:6px;">Qualitat: ${est.qualitatGlobal}/100</span></div>
      </div>
      <div style="margin-top:8px;color:#666;font-size:0.85em;">
        ${est.capitols} capÃ­tols Â· ~${est.escenes} escenes Â· ~${est.paraulesEstimades.toLocaleString()} paraules${est.penalitzacioCatala > 0 ? ` Â· <span style="color:#e67e22;">-${est.penalitzacioCatala}pts catalÃ </span>` : ''}
      </div>
      <div style="margin-top:6px;font-size:0.8em;color:#888;">
        Draft: $${est.costDraft} Â· GeneraciÃ³: $${est.costGeneracio} Â· Arquitectura: $${est.costArquitecte}
      </div>`;
  }

  const panellAvisos = document.getElementById('panellAvisos');
  if (panellAvisos) {
    panellAvisos.innerHTML = est.avisos.length > 0
      ? est.avisos.map(a => `<div style="padding:4px 0;border-bottom:1px solid #eee;">${a}</div>`).join('')
      : '';
  }

  // Actualitzar tambÃ© el div de l'estructura (si Ã©s visible)
  const costEl = document.getElementById('estimacio-cost');
  if (costEl && costEl.textContent) costEl.textContent = mostrarEstimacioCost();
}

function renderBarraQualitat(qualitat, cost) {
  const color = qualitat >= 85 ? '#28a745' : qualitat >= 75 ? '#5cb85c' :
                qualitat >= 65 ? '#f0ad4e' : '#d9534f';
  const ample = Math.min(100, qualitat);
  return `<div style="display:flex;align-items:center;gap:6px;"><div style="flex:1;background:#e9ecef;border-radius:4px;height:8px;overflow:hidden;"><div style="width:${ample}%;background:${color};height:100%;border-radius:4px;"></div></div><span style="font-size:0.8em;min-width:30px;">${qualitat}</span><span style="font-size:0.75em;color:#999;">${cost}</span></div>`;
}

function guardarClausAPI() {
  const anthropic = document.getElementById('anthropicApiKey')?.value?.trim();
  const gemini    = document.getElementById('geminiApiKey')?.value?.trim();
  const openai    = document.getElementById('openaiApiKey')?.value?.trim();
  if (anthropic) ESTAT._anthropicApiKey = anthropic;
  if (gemini)    ESTAT._geminiApiKey    = gemini;
  if (openai)    ESTAT._openaiApiKey    = openai;
  actualitzarModelsDisponibles();
}

function actualitzarModelsDisponibles() {
  const teAnthropic = !!(ESTAT._anthropicApiKey || (USER_CONFIG && USER_CONFIG.provider === 'anthropic' && USER_CONFIG.apiKey));
  const teGemini    = !!ESTAT._geminiApiKey;
  const teOpenai    = !!ESTAT._openaiApiKey;

  document.querySelectorAll('#panellModels select option').forEach(option => {
    const model = MODEL_REGISTRY[option.value];
    if (!model) return;
    const disponible =
      (model.proveidor === 'anthropic' && teAnthropic) ||
      (model.proveidor === 'google'    && teGemini) ||
      (model.proveidor === 'openai'    && teOpenai);
    option.disabled = !disponible;
    if (!disponible && !option.textContent.includes('(sense clau)')) {
      option.textContent += ' (sense clau)';
    } else if (disponible) {
      option.textContent = option.textContent.replace(' (sense clau)', '');
    }
  });
}

// â”€â”€ InicialitzaciÃ³ del selector de models en carregar la pÃ gina â”€â”€
document.addEventListener('DOMContentLoaded', function() {
  // Aplicar preset econÃ²mic per defecte i poblar selectors
  aplicarPreset('economic');
  poblarSelectorsModels();
});

</script>
</body>
</html>
